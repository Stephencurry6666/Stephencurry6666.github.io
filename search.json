[{"title":"2020HDU多校第五场","url":"/2020/08/07/2020HDU多校第五场/","content":"\n### Tetrahedron （HDU-6814）（1001）\n\n**题意：已知直角四面体三个直角边长，求E(1/h^2)。**\n\n<!--more-->\n\n**思路：这道题的话，等体积法，把1/h^2表示出来，E(1/h^2)=3E(1/a平方)。**\n\n**AC代码：**\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxn = 6000010;\nconst int inf = 0x3f3f3f3f;\nconst int mod = 998244353;\nusing namespace std;\nll fastpow(ll base, ll n, ll mod)\n{\n    ll ans = 1;\n    while (n)\n    {\n        if (n & 1)\n            ans *= base % mod, ans %= mod;\n        base *= base, base %= mod;\n        n >>= 1;\n    }\n    return ans % mod;\n}\nint T;\nint n;\nint sum[maxn];\nint main()\n{\n    scanf(\"%d\", &T);\n    for (ll i = 1; i <= 6e6; i++)\n    {\n        sum[i] = (sum[i - 1] + fastpow(i * i % mod, mod - 2, mod)) % mod;\n    }\n    while (T--)\n    {\n\n        scanf(\"%d\", &n);\n        printf(\"%lld\\n\", 3ll * sum[n] * fastpow(n, mod - 2, mod) % mod); \n    }\n}\n```\n\n\n### Paperfolding   （HDU-6822） （1009）\n\n**题意：将一张纸折n次，四个方向都可以折，折完后取中点，横竖分别切一刀（切十字），问最后纸被分成的数量的期望（模998244353）。**\n\n**思路：<https://www.cnblogs.com/stelayuri/p/13435083.html>**\n\n**AC代码：**\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxn = 100010;\nconst int inf = 0x3f3f3f3f;\nconst ll mod = 998244353;\nusing namespace std;\nll qpow(ll a, ll n)\n{\n    ll ans = 1;\n    a %= mod;\n    while (n)\n    {\n        if (n & 1)\n            ans = (ans * a) % mod;\n        n >>= 1;\n        a = (a * a) % mod;\n    }\n    return ans;\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int t;\n    cin >> t;\n    while (t--)\n    {\n        ll n;\n        cin >> n;\n        ll cnt1 = qpow(2, n);\n        ll cnt2 = qpow(3, n);\n        ll cnt3 = qpow(cnt1, mod - 2);\n        cout << (cnt1 + 1 + 2 * cnt2 * cnt3) % mod << endl;\n    }\n    return 0;\n}\n```\n","tags":["HDU"],"categories":["多校"]},{"title":"Codeforces 637(Div.2)","url":"/2020/08/05/Codeforces 637(Div.2)/","content":"\n### A题\n\n**题意：给你n包零食，每包零食的重量为c-d~c+d之间，每包零食里面的每片的重量在a-b~a+b之间。现在给你一些数据，问你质量从a-b到a+b的n片能不能构成总质量从c-d到c+d的零食。**\n\n<!--more-->\n\n**思路：这道题的话，我们分别把最小最大求出，比较一下即可。**\n\n**AC代码：**\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxn = 100010;\nconst int inf = 0x3f3f3f3f;\nusing namespace std;\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int t, n, a, b, c, d;\n    cin >> t;\n    while (t--)\n    {\n        cin >> n >> a >> b >> c >> d;\n        int minn1 = a - b;\n        int minn2 = c - d;\n        int maxx1 = a + b;\n        int maxx2 = c + d;\n        if (maxx1 * n < minn2 || minn1 * n > maxx2)\n            cout << \"NO\" << endl;\n        else\n            cout << \"YES\" << endl;\n    }\n    return 0;\n}\n```\n\n\n### B题\n\n**题意：定义“顶”：对于任意一个i，若满足a[i] > a[i - 1] 与 a[i] > a[i + 1]，则称i为“顶点”。给定区间长度为k，要求滑动窗口，统计[L，L + k - 1]中“顶点”个数（不含区间端点），“顶点”个数最多且左端点下标最小的的区间，输出该区间的L和共有的“顶点”个数。**\n\n**思路：这道题的话，预处理一下前面有多少个山峰，sum[i]就是前i个数的山峰数量（包括第i个数），这样区间内的山峰数量就可以计算了。**\n\n**AC代码：**\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxn = 200010;\nconst int inf = 0x3f3f3f3f;\nusing namespace std;\nint a[maxn], sum[maxn];\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int t, n, m;\n    cin >> t;\n    while (t--)\n    {\n        cin >> n >> m;\n        for (int i = 1; i <= n; i++)\n            cin >> a[i];\n        memset(sum, 0, sizeof(sum));\n        int k = 0, l = 1;\n        for (int i = 2; i <= n; i++)\n        {\n            if (a[i] > a[i - 1] && a[i] > a[i + 1] && i < n)\n                sum[i] = sum[i - 2] + 1;\n            else\n                sum[i] = sum[i - 1];\n            if (i >= m && sum[i - 1] - sum[i - m + 1] + 1 > k)\n            {\n                l = i - m + 1;\n                k = sum[i - 1] - sum[i - m + 1] + 1;\n            }\n        }\n        cout << k << \" \" << l << endl;\n    }\n    return 0;\n}\n```\n\n\n### C题\n\n**题意：一个序列生成器按照规则生成序列：依次考虑1~n，对于每个数i，我们为其选择在生成序列中位置，有生成的规则：生成一个数组r，第j个数的值记作r[j]，满足：j <= r[j] <= n，且当前生成序列当中（没有完全生成好，也就是有的位置没有生成的数），第r[j]个位置必须保证没有数生成（换句话说，若在先前操作中该位置已经填上了数了，那么r[j]不可以是该位置的下标），同时r[j]须越小越好（如果3、4和5均可，则选择3，因为值最小）。再生成count数组，记录r数组中每一个值的个数。譬如：r[3] = {2, 2, 3}，则count[4] = {0, 2, 1}（统计出现次数）。言归正传，在生成环节结束后（r和count数组生成完毕了），对于i生成的位置，该位置为count数组中数最大的位置的下标（如果count[4]最大，该数应填在生成序列中的第四个），若有多个位置下的值满足，则在其中选择任意一个位置。给定一个序列p，求是否可以按上述规律生成p。**\n\n**思路：这道题的话，从1-n填数，在i位置填数，下一个要么在 i+1 的位置填，要么在[1，i-1]之间填。**\n\n**AC代码：**\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxn = 100010;\nconst int inf = 0x3f3f3f3f;\nusing namespace std;\nint a[maxn];\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int t, n;\n    cin >> t;\n    while (t--)\n    {\n        cin >> n;\n        for (int i = 1; i <= n; i++)\n            cin >> a[i];\n        int ans = 1, flag = 1;\n        for (int i = n; i; i--)\n        {\n            if (ans == a[i])\n                ans++;\n            else if (ans < a[i])\n                ans = a[i];\n            else if (a[i + 1] - a[i] != 1)\n            {\n                flag = 0;\n                break;\n            }\n        }\n        if (flag)\n            cout << \"YES\" << endl;\n        else\n            cout << \"NO\" << endl;\n    }\n    return 0;\n}\n```\n","tags":["CF"],"categories":["CF"]},{"title":"高斯消元题二道","url":"/2020/08/03/高斯消元题二道/","content":"\n### 高斯消元模板1\n\n<!--more-->\n\n```\n/*\n*功能: 列选主元消元法 \n*@Author: Stephencurry6666\n*@Language: C++\n*@File Name: gaosixiaoyuan.cpp\n*/\n/*\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 5;\n\n//输出矩阵\nvoid printM(double a[][maxn], int n)\n{\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 1; j <= n + 1; j++)\n        {\n            printf(\"%10f,\", a[i][j]);\n            printf(\"\\n\");\n        }\n    }\n}\n//选择列主元并进行消元\nvoid SelectColE(double a[][maxn], int n)\n{\n    double temp; //用于记录消元时的因数\n    for (int i = 1; i <= n; i++)\n    {\n        int r = i;\n        for (int j = i + 1; j <= n; j++)\n        {\n            if (fabs(a[j][i]) > fabs(a[r][i]))\n                r = j;\n        }\n        if (r != i)\n            for (int j = i; j <= n + 1; j++)\n                swap(a[i][j], a[r][j]); //与最大主元所在行交换\n        for (int j = i + 1; j <= n; j++)\n        { //消元\n            temp = a[j][i] / a[i][i];\n            for (int k = i; k <= n + 1; k++)\n                a[j][k] -= a[i][k] * temp;\n        }\n        printf(\"第%d列消元后：\\n\", i);\n        printM(a, 3);\n    }\n}\n//高斯消元法(列选主元)\nvoid Gauss(double a[][maxn], int n)\n{\n    SelectColE(a, n); //列选主元并消元成上三角\n    printf(\"上三角的结果：\\n\");\n    printM(a, 3);\n    for (int i = n; i >= 1; i--)\n    { //回代求解\n        for (int j = i + 1; j <= n; j++)\n            a[i][n + 1] -= a[i][j] * a[j][n + 1];\n        a[i][n + 1] /= a[i][i];\n    }\n}\n//测试函数\nint main()\n{\n    double a[4][maxn] = {\n        {0, 0, 0, 0, 0},\n        {0, 2, 1, -1, 8},\n        {0, -3, -1, 2, -11},\n        {0, -2, 1, 2, -3}};\n    Gauss(a, 3);\n    for (int i = 1; i <= 3; i++)\n        printf(\"X%d = %9f\\n\", i, a[i][4]);\n    return 0;\n}\n*/\n```\n\n### 高斯消元模板2\n\n```\n/* 用于求整数解得方程组. */\n/*\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 105;\n\nint equ, var; // 有equ个方程，var个变元。增广阵行数为equ, 分别为0到equ - 1，列数为var + 1，分别为0到var.\nint a[maxn][maxn];\nint x[maxn];       // 解集.\nbool free_x[maxn]; // 判断是否是不确定的变元.\nint free_num;\n\nvoid Debug(void)\n{\n    int i, j;\n    for (i = 0; i < equ; i++)\n    {\n        for (j = 0; j < var + 1; j++)\n        {\n            cout << a[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    cout << endl;\n}\n\ninline int gcd(int a, int b)\n{\n    int t;\n    while (b != 0)\n    {\n        t = b;\n        b = a % b;\n        a = t;\n    }\n    return a;\n}\n\ninline int lcm(int a, int b)\n{\n    return a * b / gcd(a, b);\n}\n\n// 高斯消元法解方程组(Gauss-Jordan elimination).(-2表示有浮点数解，但无整数解，-1表示无解，0表示唯一解，大于0表示无穷解，并返回自由变元的个数)\nint Gauss(void)\n{\n    int i, j, k;\n    int max_r; // 当前这列绝对值最大的行.\n    int col;   // 当前处理的列.\n    int ta, tb;\n    int LCM;\n    int temp;\n    int free_x_num;\n    int free_index;\n    // 转换为阶梯阵.\n    col = 0; // 当前处理的列.\n    for (k = 0; k < equ && col < var; k++, col++)\n    { // 枚举当前处理的行.\n        // 找到该col列元素绝对值最大的那行与第k行交换.(为了在除法时减小误差)\n        max_r = k;\n        for (i = k + 1; i < equ; i++)\n        {\n            if (abs(a[i][col]) > abs(a[max_r][col]))\n                max_r = i;\n        }\n        if (max_r != k)\n        { // 与第k行交换.\n            for (j = k; j < var + 1; j++)\n                swap(a[k][j], a[max_r][j]);\n        }\n        if (a[k][col] == 0)\n        { // 说明该col列第k行以下全是0了，则处理当前行的下一列.\n            k--;\n            continue;\n        }\n        for (i = k + 1; i < equ; i++)\n        { // 枚举要删去的行.\n            if (a[i][col] != 0)\n            {\n                LCM = lcm(abs(a[i][col]), abs(a[k][col]));\n                ta = LCM / abs(a[i][col]), tb = LCM / abs(a[k][col]);\n                if (a[i][col] * a[k][col] < 0)\n                    tb = -tb; // 异号的情况是两个数相加.\n                for (j = col; j < var + 1; j++)\n                {\n                    a[i][j] = a[i][j] * ta - a[k][j] * tb;\n                }\n            }\n        }\n    }\n    Debug();\n    // 1. 无解的情况: 化简的增广阵中存在(0, 0, ..., a)这样的行(a != 0).\n    for (i = k; i < equ; i++)\n    { // 对于无穷解来说，如果要判断哪些是自由变元，那么初等行变换中的交换就会影响，则要记录交换.\n        if (a[i][col] != 0)\n            return -1;\n    }\n    // 2. 无穷解的情况: 在var * (var + 1)的增广阵中出现(0, 0, ..., 0)这样的行，即说明没有形成严格的上三角阵.\n    // 且出现的行数即为自由变元的个数.\n    if (k < var)\n    {\n        // 首先，自由变元有var - k个，即不确定的变元至少有var - k个.\n        for (i = k - 1; i >= 0; i--)\n        {\n            // 第i行一定不会是(0, 0, ..., 0)的情况，因为这样的行是在第k行到第equ行.\n            // 同样，第i行一定不会是(0, 0, ..., a), a != 0的情况，这样的无解的.\n            free_x_num = 0; // 用于判断该行中的不确定的变元的个数，如果超过1个，则无法求解，它们仍然为不确定的变元.\n            for (j = 0; j < var; j++)\n            {\n                if (a[i][j] != 0 && free_x[j])\n                    free_x_num++, free_index = j;\n            }\n            if (free_x_num > 1)\n                continue; // 无法求解出确定的变元.\n            // 说明就只有一个不确定的变元free_index，那么可以求解出该变元，且该变元是确定的.\n            temp = a[i][var];\n            for (j = 0; j < var; j++)\n            {\n                if (a[i][j] != 0 && j != free_index)\n                    temp -= a[i][j] * x[j];\n            }\n            x[free_index] = temp / a[i][free_index]; // 求出该变元.\n            free_x[free_index] = 0;                  // 该变元是确定的.\n        }\n        return var - k; // 自由变元有var - k个.\n    }\n    // 3. 唯一解的情况: 在var * (var + 1)的增广阵中形成严格的上三角阵.\n    // 计算出Xn-1, Xn-2 ... X0.\n    for (i = var - 1; i >= 0; i--)\n    {\n        temp = a[i][var];\n        for (j = i + 1; j < var; j++)\n        {\n            if (a[i][j] != 0)\n                temp -= a[i][j] * x[j];\n        }\n        if (temp % a[i][i] != 0)\n            return -2; // 说明有浮点数解，但无整数解.\n        x[i] = temp / a[i][i];\n    }\n    return 0;\n}\n\nint main(void)\n{\n    freopen(\"Input.txt\", \"r\", stdin);\n    int i, j;\n    while (scanf(\"%d %d\", &equ, &var) != EOF)\n    {\n        memset(a, 0, sizeof(a));\n        memset(x, 0, sizeof(x));\n        memset(free_x, 1, sizeof(free_x)); // 一开始全是不确定的变元.\n        for (i = 0; i < equ; i++)\n        {\n            for (j = 0; j < var + 1; j++)\n            {\n                scanf(\"%d\", &a[i][j]);\n            }\n        }\n        //        Debug();\n        free_num = Gauss();\n        if (free_num == -1)\n            printf(\"无解!\\n\");\n        else if (free_num == -2)\n            printf(\"有浮点数解，无整数解!\\n\");\n        else if (free_num > 0)\n        {\n            printf(\"无穷多解! 自由变元个数为%d\\n\", free_num);\n            for (i = 0; i < var; i++)\n            {\n                if (free_x[i])\n                    printf(\"x%d 是不确定的\\n\", i + 1);\n                else\n                    printf(\"x%d: %d\\n\", i + 1, x[i]);\n            }\n        }\n        else\n        {\n            for (i = 0; i < var; i++)\n            {\n                printf(\"x%d: %d\\n\", i + 1, x[i]);\n            }\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\n```\n\n### 异或方程组的高斯消元\n\n```\n//有equ个方程，var个变元。增广矩阵行数为equ,列数为var+1,分别为0到var\n  int equ,var;\n  int a[MAXN][MAXN]; //增广矩阵\n  int x[MAXN]; //解集\n  int free_x[MAXN];//用来存储自由变元（多解枚举自由变元可以使用）\n  int free_num;//自由变元的个数\n  \n  //返回值为-1表示无解，为0是唯一解，否则返回自由变元个数\n  int Gauss()\n  {\n      int max_r,col,k;\n      free_num = 0;\n      for(k = 0, col = 0 ; k < equ && col < var ; k++, col++)\n      {\n          max_r = k;\n          for(int i = k+1;i < equ;i++)\n          {\n              if(abs(a[i][col]) > abs(a[max_r][col]))\n                  max_r = i;\n          }\n          if(a[max_r][col] == 0)\n          {\n              k--;\n              free_x[free_num++] = col;//这个是自由变元\n              continue;\n          }\n          if(max_r != k)\n          {\n              for(int j = col; j < var+1; j++)\n                  swap(a[k][j],a[max_r][j]);\n          }\n          for(int i = k+1;i < equ;i++)\n          {\n              if(a[i][col] != 0)\n              {\n                 for(int j = col;j < var+1;j++)\n                      a[i][j] ^= a[k][j];\n              }\n          }\n      }\n     for(int i = k;i < equ;i++)//进入此循环的条件：本身矩阵行大于列 或者 因为出现自由变元后使得非自由变元数比行数小\n          if(a[i][col] != 0)//若等号右边是1则无解，因为等号左边已经消为0\n              return -1;//无解\n      if(k < var) return var-k;//自由变元个数\n      //唯一解，回代\n      for(int i = var-1; i >= 0;i--)\n      {\n          x[i] = a[i][var];\n          for(int j = i+1;j < var;j++)\n              x[i] ^= (a[i][j] && x[j]);\n      }\n      return 0;\n  }\n```\n\n\n### POJ-1222\n\n**有一个 5 * 6 的初始矩阵, 1 表示一个亮灯泡, 0 表示一个不亮的灯泡. 对 (i, j) 位置进行一次操作则 (i, j),(i + 1, j), (i - 1, j), (i, j - 1),  (i, j + 1) 位置的灯泡变为原来的相反状态, 输出一种能让所有灯泡都变成不亮状态的操作集合.**\n\n**思路：这道题的话，可以用高斯消元来做。**\n\n**AC代码：**\n\n```\n#include <iostream>\n#include <stdio.h>\n#include <algorithm>\nusing namespace std;\nconst int MAXN = 3e2;\nint equ = 30, var = 30; //有equ个方程,var个变元,增广矩正行数为equ,列数为var+1,从0开始计数\nint a[MAXN][MAXN];      //增广矩正\nint free_x[MAXN];       //用来存储自由变元(多解枚举自由变元可以使用)\nint free_num;           //自由变元个数\nint x[MAXN];            //解集\nint Gauss(void)\n{ //返回-1表示无解,0表示有唯一解,否则返回自由变元个数\n    int max_r, col, k;\n    free_num = 0;\n    for (k = 0, col = 0; k < equ && col < var; k++, col++)\n    {\n        max_r = k;\n        for (int i = k + 1; i < equ; i++)\n        {\n            if (abs(a[i][col] > abs(a[max_r][col])))\n                max_r = i;\n        }\n        if (a[max_r][col] == 0)\n        {\n            k--;\n            free_x[free_num++] = col; //这个是变元\n            continue;\n        }\n        if (max_r != k)\n        {\n            for (int j = col; j < var + 1; j++)\n            {\n                swap(a[k][j], a[max_r][j]);\n            }\n        }\n        for (int i = k + 1; i < equ; i++)\n        {\n            if (a[i][col] != 0)\n            {\n                for (int j = col; j < var + 1; j++)\n                {\n                    a[i][j] ^= a[k][j];\n                }\n            }\n        }\n    }\n    for (int i = k; i < equ; i++)\n    {\n        if (a[i][col] != 0)\n            return -1; //无解\n    }\n    if (k < var)\n        return var - k; //返回自由变元个数\n    for (int i = var - 1; i >= 0; i--)\n    {\n        x[i] = a[i][var];\n        for (int j = i + 1; j < var; j++)\n        {\n            x[i] ^= (a[i][j] && x[j]);\n        }\n    }\n    return 0;\n}\nint main(void)\n{\n    int t, n;\n    cin >> t;\n    for (int cas = 1; cas <= t; cas++)\n    {\n        for (int i = 0; i < 30; i++)\n        {\n            cin >> a[i][30];\n            x[i] = 0; //清空数组\n        }\n        for (int i = 0; i < 30; i++)\n        { //构造增广矩阵\n            int x1 = i / 6;\n            int y1 = i % 6;\n            for (int j = 0; j < 30; j++)\n            {\n                int x2 = j / 6;\n                int y2 = j % 6;\n                if (abs(x1 - x2) + abs(y1 - y2) < 2)\n                    a[j][i] = 1;\n                else\n                    a[j][i] = 0;\n            }\n        }\n        Gauss();\n        cout << \"PUZZLE #\" << cas << endl;\n        for (int i = 0; i < 30; i++)\n        {\n            cout << x[i] << \" \";\n            if ((i + 1) % 6 == 0)\n                cout << endl;\n        }\n    }\n    return 0;\n}\n```\n\n\n### POJ-1830\n\n**题意：中文题，不过多叙述题意。**\n\n**思路：<https://blog.csdn.net/immiao/article/details/17342143>**\n\n**AC代码：**\n\n```\n#include <iostream>\n#include <stdio.h>\n#include <string.h>\nusing namespace std;\nint A[35][35];\nint B[35];\nint n;\nint ans;\nvoid swap(int a, int b)\n{\n    int i;\n    int temp;\n    for (i = 0; i <= n - 1; i++)\n    {\n        temp = A[a][i];\n        A[a][i] = A[b][i];\n        A[b][i] = temp;\n    }\n    temp = B[a];\n    B[a] = B[b];\n    B[b] = temp;\n}\nvoid gauss()\n{\n    int i, j, k;\n    for (i = 0; i <= n - 1; i++)\n    {\n        bool flag = false;\n        if (!A[i][i])\n        {\n            for (j = i + 1; j <= n - 1; j++)\n            {\n                if (A[j][i])\n                {\n                    swap(i, j);\n                    flag = true;\n                    break;\n                }\n            }\n            if (!flag)\n                continue;\n        }\n\n        for (j = i + 1; j <= n - 1; j++)\n        {\n            if (A[j][i])\n            {\n                for (k = i; k <= n - 1; k++)\n                    A[j][k] ^= A[i][k];\n                B[j] ^= B[i];\n            }\n        }\n    }\n    for (i = n - 1; i >= 0; i--)\n    {\n        if (A[i][i] == 0 && B[i] == 1)\n        {\n            ans = -1;\n            break;\n        }\n        else if (A[i][i] == 0)\n            ans = ans << 1;\n        else\n        {\n            for (j = i - 1; j >= 0; j--)\n            {\n                if (A[j][i])\n                {\n                    A[j][i] ^= A[i][i];\n                    B[j] ^= B[i];\n                }\n            }\n        }\n    }\n}\nint main()\n{\n    int T;\n    scanf(\"%d\", &T);\n    while (T--)\n    {\n        ans = 1;\n        scanf(\"%d\", &n);\n        int i;\n\n        int s[35], e[35];\n\n        for (i = 0; i <= n - 1; i++)\n            scanf(\"%d\", &s[i]);\n        for (i = 0; i <= n - 1; i++)\n        {\n            scanf(\"%d\", &e[i]);\n            if (e[i] != s[i])\n                B[i] = 1;\n            else\n                B[i] = 0;\n        }\n\n        memset(A, 0, sizeof(A));\n        for (i = 0; i <= n - 1; i++)\n            A[i][i] = 1;\n        while (1)\n        {\n            int a, b;\n            scanf(\"%d%d\", &a, &b);\n            if (!a && !b)\n                break;\n            A[b - 1][a - 1] = 1;\n        }\n\n        gauss();\n        if (ans != -1)\n            printf(\"%d\\n\", ans);\n        else\n            printf(\"Oh,it's impossible~!!\\n\");\n    }\n    return 0;\n}\n```\n","tags":["高斯消元"],"categories":["高斯消元"]},{"title":"2020HDU多校第四场","url":"/2020/07/31/2020HDU多校第四场/","content":"\n### Kindergarten Physics （HDU-6812） (1011)\n\n**题意：给你两个质点a和b，然后给出a和b的质量和它们之间的距离h，问你经过万有引力的作用之后，在经过t0时间之后，它们之间的距离。**\n\n<!--more-->\n\n**思路：这道题的话，我们需要套用物理公式。$F(万有引力)=(Gxmaxmb)/rxr$,$F=ma$,$S=(1/2)xaxtxt$。**\n\n**AC代码：**\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxx = 100010;\nconst int inf = 0x3f3f3f3f;\nconst int mod = 1000000009;\nconst int G = 6.67430 * (1e-11);\nusing namespace std;\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int t;\n    cin >> t;\n    while (t--)\n    {\n        double a, b, d, t0;\n        cin >> a >> b >> d >> t0;\n        double a1 = G * b / (d * d);\n        double a2 = G * a / (d * d);\n        double s1 = (1 / 2) * a1 * t0 * t0;\n        double s2 = (1 / 2) * a2 * t0 * t0;\n        d = d - s1 - s2;\n        printf(\"%.6lf\\n\", d);\n    }\n    return 0;\n}\n```\n\n\n### Blow up the Enemy （HDU-6803） (1002)\n\n**题意：给定有n种武器，每种武器有2种属性：伤害A和冷却时间D，张三和爸爸各从n种武器种选择一个武器进行对战。张三和爸爸各从n种武器种选择一个武器进行对战。每人初始HP=100，每种武器每次攻击可以使得对手HP值减去Ai，HP≤0的一方出局。初始时武器未冷却，每攻击一次，武器冷却Di时长，Di时间后，可立刻攻击。爸爸每次从n种武器种等概率地随机选择一种武器，若二人的HP同时小于等于0，那么二人各有0.5的概率获胜。请帮助张三选择武器，使得他能够以最大的概率获胜。**\n\n**思路：这道题的话，我们可以先算出每种武器打掉100血的时间，然后选择最小的，然后再分别与每种武器进行比较，计算概率即可。**\n\n**AC代码：**\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxx = 10010;\nconst int inf = 0x3f3f3f3f;\nconst int mod = 1000000009;\nconst int G = 6.67430 * (1e-11);\nusing namespace std;\nstruct node\n{\n    int a;\n    int d;\n    double tim;\n} edge[maxx];\nbool cmp(node x, node y)\n{\n    return x.tim < y.tim;\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int t;\n    cin >> t;\n    while (t--)\n    {\n        int n;\n        cin >> n;\n        for (int i = 0; i < n; i++)\n        {\n            cin >> edge[i].a >> edge[i].d;\n            if (100 % edge[i].a == 0)\n                edge[i].tim = (100 / edge[i].a - 1) * edge[i].d;\n            else\n                edge[i].tim = (100 / edge[i].a) * edge[i].d;\n        }\n        sort(edge, edge + n, cmp);\n        double minn = edge[0].tim;\n        double ans = 1;\n        for (int i = 1; i < n; i++)\n        {\n            if (edge[i].tim == minn)\n                ans++;\n            else\n                break;\n        }\n        double cnt = 1 - (ans / n) * 0.5;\n        printf(\"%.6lf\\n\", cnt);\n    }\n    return 0;\n}\n```\n\n\n### Equal Sentences （HDU-6806） (1005)\n\n**题意：给你一串字符串S，现在有两个要求：1. S中的单词的多集与T中的单词的多集相同。2. 对于一个单词概要，它在S中的第i次出现和在T中的第i次出现的索引差异不超过1。(句子中的第k个单词的索引是k。)只要单词在两个句子中出现至少i次，这对所有的a和i都成立。然后我们可以说S和T几乎相同。但是请注意，“几乎相等”不是一个等价关系，不像它的名字。也就是说，如果句子A和B接近相等，B和C接近相等，那么A和C可能不接近相等。然后问你有多少个句子与S几乎相同。**\n\n**思路：这道题的话，在读完题之后和jp在讨论之后，发现就是如果前后单词是一样的话，那么就算一个句子。所以我想到了上楼梯，和这个有异曲同工之妙。于是我就列了dp方程，那就是n=1的时候，只有1种；n=2的时候分两种情况，相等或者不相等；n>=3的时候，也是分相等和不相等两种情况。当n>=3的时候，要是当前和上一个相等，那就直接$dp[i]=dp[i-1]$；要是不相等，那就是等于前两个相加$dp[i]=dp[i-1]+dp[i-2]$。**\n\n**AC代码：**\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxx = 200010;\nconst int inf = 0x3f3f3f3f;\nconst int mod = 1e9 + 7;\nconst int G = 6.67430 * (1e-11);\nusing namespace std;\nint dp[maxx];\nstring s[maxx];\nint solve(int n)\n{\n    for (int i = 1; i <= n; i++)\n        cin >> s[i];\n    dp[1] = 1;\n    if (s[1] != s[2])\n        dp[2] = 2;\n    else\n        dp[2] = 1;\n    for (int i = 3; i <= n; i++)\n    {\n        if (s[i] != s[i - 1])\n            dp[i] = (dp[i - 1] + dp[i - 2]) % mod;\n        else\n            dp[i] = dp[i - 1] % mod;\n    }\n    return dp[n];\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int t;\n    cin >> t;\n    while (t--)\n    {\n        int n;\n        cin >> n;\n        memset(dp, 0, sizeof(dp));\n        int ans = solve(n);\n        cout << ans << endl;\n    }\n    return 0;\n}\n```\n\n\n### Deliver the Cake （HDU-6805）（1004）\n\n**题意：给出一个nm的无向图，有边权。张三在起点s，目标是t。点分成左点右点和中间点，到左点的时候必须用左手，到右点的时候必须用右手，中间点没有特殊要求。张三每次切换左右手都要花费额外的时间，询问起点到终点的最短路。**\n\n**思路：这道题的话，我们把每个点拆成两个点，L点拆成两个L，R点拆成两个R，M点拆成一个L一个R。然后跑Dijkstra+优先队列即可。**\n\n**AC代码：**\n\n```\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 4e5 + 10;\nconst ll inf = 1e18;\nint n, m, s, t, cost;\nstring ss;\nstruct node\n{\n    int u;\n    int v;\n    int w;\n    int next;\n} edge[maxn * 8];\nint head[maxn * 3];\nint tol = 0;\nvoid addedge(int u, int v, int w)\n{\n    edge[tol].u = u;\n    edge[tol].v = v;\n    edge[tol].w = w;\n    edge[tol].next = head[u];\n    head[u] = tol++;\n\n    edge[tol].u = v;\n    edge[tol].v = u;\n    edge[tol].w = w;\n    edge[tol].next = head[v];\n    head[v] = tol++;\n}\nll d[maxn];\nint visit[maxn];\nchar wjm[maxn];\nstruct qnode\n{\n    int v;\n    ll w;\n    bool operator<(const qnode &r) const\n    {\n        return w > r.w;\n    }\n};\nvoid dij(int s)\n{\n    memset(visit, 0, sizeof(visit));\n    for (int i = 1; i <= 2 * n; i++)\n        d[i] = inf;\n    priority_queue<qnode> q;\n    d[s] = 0;\n    q.push({s, 0});\n    qnode tmp;\n    while (!q.empty())\n    {\n        tmp = q.top();\n        q.pop();\n        int u = tmp.v;\n        if (visit[u])\n            continue;\n        visit[u] = 1;\n        for (int i = head[u]; i != -1; i = edge[i].next)\n        {\n            int v = edge[i].v;\n            int tt;\n            if (wjm[u] == wjm[v])\n                tt = 0;\n            else\n                tt = 1;\n            if (!visit[v] && d[v] > d[u] + edge[i].w + tt * cost)\n            {\n                d[v] = d[u] + edge[i].w + tt * cost;\n                q.push({v, d[v]});\n            }\n        }\n    }\n}\nint main()\n{\n    int T;\n    scanf(\"%d\", &T);\n    while (T--)\n    {\n        scanf(\"%d%d%d%d%d\", &n, &m, &s, &t, &cost);\n        for (int i = 1; i <= n * 2; i++)\n            head[i] = -1;\n        cin >> ss;\n        for (int i = 1; i <= n; i++)\n        {\n            if (ss[i - 1] == 'L')\n            {\n                wjm[i] = 'L';\n                wjm[i + n] = 'L';\n            }\n            else if (ss[i - 1] == 'R')\n            {\n                wjm[i] = 'R';\n                wjm[i + n] = 'R';\n            }\n            else\n            {\n                wjm[i] = 'L';\n                wjm[i + n] = 'R';\n            }\n        }\n        tol = 0;\n        for (int i = 0; i < m; i++)\n        {\n            int u, v, w;\n            scanf(\"%d%d%d\", &u, &v, &w);\n            addedge(u, v, w);\n            addedge(u + n, v, w);\n            addedge(u + n, v + n, w);\n            addedge(u, v + n, w);\n        }\n        ll ans = 1e18;\n        dij(s);\n        ans = min(ans, d[t]);\n        ans = min(ans, d[t + n]);\n        dij(s + n);\n        ans = min(ans, d[t]);\n        ans = min(ans, d[t + n]);\n        printf(\"%lld\\n\", ans);\n    }\n    return 0;\n}\n```\n","tags":["HDU"],"categories":["多校"]},{"title":"2020HDU多校第三场","url":"/2020/07/30/2020HDU多校第三场/","content":"\n### Tokitsukaze and Multiple （HDU-6794）  (1004)\n\n**题意：有一个长度为n的序列，你现在将序列中连续两个元素合并多次，然后问你在经过一些操作之后，能得到的p的倍数元素的最大可能数量。**\n\n<!--more-->\n\n**思路：这道题的话，我们用map函数来做。**\n\n**AC代码：**\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxx = 100010;\nconst int inf = 0x3f3f3f3f;\nconst int mod = 1000000009;\nusing namespace std;\nmap<ll,ll>mapp;\nll a[maxx];\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int t, n, p;\n    cin >> t;\n    while (t--)\n    {\n        cin >> n >> p;\n        for (int i = 1; i <= n; i++)\n        {\n            cin >> a[i];\n            a[i] %= p;\n        }\n        int ans = 0, sum = 0;\n        mapp[0] = 1;\n        for (int i = 1; i <= n; i++)\n        {\n            sum += a[i];\n            sum %= p;\n            if (mapp[sum] != 0)\n            {\n                ans++;\n                mapp.clear();\n                mapp[0] = 1;\n                sum = 0;\n            }\n            else\n                mapp[sum] = 1;\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n```\n\n\n### Little W and Contest （HDU-6795） （1005）\n\n**题意：现在有n个人，然后每三个人可以组成一队，但是三个之间不能互相认识。比如A认识B，B认识C，那么A就可以通过B认识C。问你随着联系的增加，每次能组成几个队伍。**\n\n**这道题的话，我们用并查集来做，将相互认识的人放在同一个并查集中，同一个并查集中的人不能够成为队友。保存总的1能力值人数为num[0]，总的2能力值人数为num[1]。每个并查集中pre[i][0]表示祖先为i点的并查集中的1能力值人数，pre[i][1]表示2能力值人数，队伍组成的情况有两种： 1 2 2 和 2 2 2。注意去重，取余的位置和防止爆int，不要对分子先进行取模，防止造成分子除分母无法刚好除尽的情况，然后对于每次交友之后，形成不同集合之后，对于结果都是有影响的，要去除原本u和v所在的集合与这两个集合之外人组成team的数量，同时也要注意u1*v2等等时可能爆int，要加ll。**\n\n**AC代码：**\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxx = 100010;\nconst int inf = 0x3f3f3f3f;\nconst int mod = 1e9 + 7;\nusing namespace std;\nint a[maxx];\nint pre[maxx];\nint f[maxx][2];\nint num[2];\nint getf(int a)\n{\n    if (a == pre[a])\n        return a;\n    return pre[a] = getf(pre[a]);\n}\nint mer(int a, int b)\n{\n    int fa = getf(a);\n    int fb = getf(b);\n    if (fa == fb)\n        return fa;\n    pre[fb] = fa;\n    f[fa][0] += f[fb][0];\n    f[fa][1] += f[fb][1];\n    return fa;\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int t;\n    cin >> t;\n    while (t--)\n    {\n        memset(f, 0, sizeof(f));\n        num[0] = num[1] = 0;\n        int n;\n        cin >> n;\n        for (int i = 1; i <= n; i++)\n        {\n            pre[i] = i;\n            cin >> a[i];\n            if (a[i] == 1)\n            {\n                num[0]++;\n                f[i][0] = 1;\n            }\n            if (a[i] == 2)\n            {\n                num[1]++;\n                f[i][1] = 1;\n            }\n        }\n        ll ans = 1ll * num[1] * (num[1] - 1) / 2 % mod * num[0] % mod + 1ll * num[1] * (num[1] - 1) * (num[1] - 2) / 6 % mod;\n        cout << ans % mod << endl;\n        for (int i = 1; i <= n - 1; i++)\n        {\n            int u, v;\n            cin >> u >> v;\n            if (i >= n - 2)\n            {\n                cout << \"0\" << endl;\n                continue;\n            }\n            int fa = getf(u);\n            int fb = getf(v);\n            int u1 = f[fa][0], u2 = f[fa][1];\n            int v1 = f[fb][0], v2 = f[fb][1];\n            int cnt = mer(u, v);\n            int x = f[cnt][0];\n            int y = f[cnt][1];\n            ans -= 1ll * u1 * v2 % mod * (num[1] - y) % mod;\n            if (ans < 0)\n                ans += mod;\n            ans -= 1ll * u2 * v1 % mod * (num[1] - y) % mod;\n            if (ans < 0)\n                ans += mod;\n            ans -= 1ll * u2 * v2 % mod * (n - x - y) % mod;\n            if (ans < 0)\n                ans += mod;\n            cout << ans % mod << endl;\n        }\n    }\n    return 0;\n}\n```\n\n\n### Tokitsukaze and Rescue (HDU-6797) (1007)\n\n**题意：给出一张无向完全图，现在要求删除k条边，问删除后的最短路的最大值是多少，k最大是5。**\n\n**思路：这道题的话，我们可以发现题目中说了所有的边权均是随机数，然后实现就好了，然后用Dijkstra算法。然后找最短路上的边，用记录每个点的前驱来实现的，换句话说每次最短路有且仅有一条。**\n\n**AC代码：**\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxx = 110;\nconst int inf = 0x3f3f3f3f;\nconst int mod = 1000000009;\nusing namespace std;\nint g[maxx][maxx], pre[6][maxx], dis[maxx];\nbool vis[maxx];\nint n, ans;\nvoid Dijkstra(int m)\n{\n    memset(dis, inf, sizeof(int) * (n + 5));\n    memset(vis, false, n + 5);\n    dis[1] = 0;\n    for (int i = 1; i < n; i++)\n    {\n        int minn = inf;\n        int u = -1;\n        for (int j = 1; j <= n; j++)\n        {\n            if (!vis[j] && dis[j] < minn)\n            {\n                minn = dis[j];\n                u = j;\n            }\n        }\n        vis[u] = true;\n        for (int v = 1; v <= n; v++)\n        {\n            if (dis[v] > dis[u] + g[u][v])\n            {\n                dis[v] = dis[u] + g[u][v];\n                pre[m][v] = u;\n            }\n        }\n    }\n}\nvoid dfs(int m)\n{\n    Dijkstra(m);\n    if (!m)\n    {\n        ans = max(ans, dis[n]);\n        return;\n    }\n    int pos = n;\n    while (pos != 1)\n    {\n        int u = pos, v = pre[m][pos];\n        int temp = g[u][v];\n        g[u][v] = g[v][u] = inf;\n        dfs(m - 1);\n        g[u][v] = g[v][u] = temp;\n        pos = pre[m][pos];\n    }\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int t;\n    cin >> t;\n    while (t--)\n    {\n        int m;\n        cin >> n >> m;\n        for (int i = 1; i <= n * (n - 1) / 2; i++)\n        {\n            int u, v, w;\n            cin >> u >> v >> w;\n            g[u][v] = g[v][u] = w;\n        }\n        ans = 0;\n        dfs(m);\n        cout << ans << endl;\n    }\n    return 0;\n}\n```\n\n\n### Parentheses Matching （HDU-6799）（1009）\n\n**题意：给你一个含有'('，')'，*'*'的字符串，允许把'*'变为'('或')'或' '，求最小的括号匹配合法序列。**\n\n**思路：这道题的话，想要最小的序列，那就需要尽量减少*‘*’*的使用，所以我们需要在原序列中就尽可能的匹配括号。然后可以发现右括号都集中在左边，左括号都集中在右边，于是要构造最小的序列的话就对于右括号来说，尽可能的选靠左的*‘*’*变左括号，而对于左括号来说，尽可能的选靠右的‘*’变右括号即可。**\n\n**AC代码：**\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxx=100010;\nusing namespace std;\ntypedef pair<char,int>pii;\nstack<pii>q;\nchar s[maxx];\nchar t[maxx];\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int T;\n    cin >> T;\n    while (T--)\n    {\n        cin >> s + 1;\n        int n = strlen(s + 1);\n        for (int i = 1; i <= n; i++)\n        {\n            t[i] = s[i];\n            if (s[i] == '(')\n                q.push(pii(s[i], i));\n            if (s[i] == ')')\n            {\n                if (!q.empty())\n                {\n                    t[q.top().second] = t[i] = 0;\n                    q.pop();\n                }\n            }\n        }\n        while (!q.empty())\n        {\n            q.pop();\n        }\n        bool flag = 1;\n        int l = n + 1, ls = 0, rs = 0;\n        for (int i = 1; i <= n; i++)\n        {\n            if (t[i] == '*')\n                ls++;\n            if (t[i] == ')')\n            {\n                if (!ls)\n                {\n                    flag = 0;\n                    break;\n                }\n                ls--;\n                rs++;\n            }\n            if (t[i] == '(')\n            {\n                l = i;\n                break;\n            }\n        }\n        for (int i = 1; i <= n; i++)\n        {\n            if (t[i] == '*' && rs)\n            {\n                rs--;\n                s[i] = '(';\n            }\n        }\n        ls = 0;\n        rs = 0;\n        for (int i = n; i >= l; i--)\n        {\n            if (t[i] == '*')\n                rs++;\n            if (t[i] == '(')\n            {\n                if (!rs)\n                {\n                    flag = 0;\n                    break;\n                }\n                rs--;\n                ls++;\n            }\n        }\n        for (int i = n; i >= l; i--)\n        {\n            if (t[i] == '*' && ls)\n            {\n                ls--;\n                s[i] = ')';\n            }\n        }\n        if (!flag)\n            cout << \"No solution!\" << endl;\n        else\n        {\n            for (int i = 1; i <= n; i++)\n            {\n                if (s[i] == '(' || s[i] == ')')\n                {\n                    cout << s[i];\n                }\n            }\n            cout << endl;\n        }\n    }\n    return 0;\n}\n```\n","tags":["HDU"],"categories":["多校"]},{"title":"Codeforces 633(Div.2)","url":"/2020/07/28/Codeforces 633(Div.2)/","content":"\n\n### A题\n\n**题意：给你n个菱形方块拼成的多边形，然后问你有多少种方法可以由一个菱形通过旋转，翻转，移动得到。**\n\n<!--more-->\n\n**思路：这道题的话，通过读题不难发现，n个菱形就有n种方法。**\n\n**AC代码：**\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxx = 100010;\nconst int inf = 0x3f3f3f3f;\nconst int mod = 1000000009;\nusing namespace std;\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int t;\n    cin >> t;\n    while (t--)\n    {\n        int n;\n        cin >> n;\n        cout << n << endl;\n    }\n    return 0;\n}\n```\n\n\n### B题\n\n**题意：给你一个数组，要求重新排列后，相邻元素的绝对值递增。**\n\n**思路：这道题的话，我们重新排列之后，将数组倒着一小一大存入即可。**\n\n**AC代码：**\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxx = 100010;\nconst int inf = 0x3f3f3f3f;\nconst int mod = 1000000009;\nusing namespace std;\nint a[maxx], b[maxx];\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int t;\n    cin >> t;\n    while (t--)\n    {\n        int n;\n        cin >> n;\n        for (int i = 1; i <= n; i++)\n            cin >> a[i];\n        sort(a + 1, a + n + 1);\n        int ans = 1;\n        int cnt = n;\n        for (int i = n; i >= 1; i--)\n        {\n            if ((n - i) % 2 == 0)\n                b[i] = a[ans++];\n            if ((n - i) % 2 == 1)\n                b[i] = a[cnt--];\n        }\n        for (int i = 1; i <= n; i++)\n        {\n            cout << b[i] << \" \";\n        }\n        cout << endl;\n    }\n    return 0;\n}\n```\n\n\n### C题\n\n**题意：给一个数组，你可以在第x秒给一些元素加上2的x−1次方 ,问多少秒后数组可以变成一个不递减序列。**\n\n**思路：这道题的话，我们找到数组中一组前后差最大的元素，然后判断需要加几秒即可。**\n\n**AC代码：**\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxx = 100010;\nconst int inf = 0x3f3f3f3f;\nconst int mod = 1000000009;\nusing namespace std;\nint a[maxx];\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int t;\n    cin >> t;\n    while (t--)\n    {\n        int n;\n        cin >> n;\n        for (int i = 1; i <= n; i++)\n            cin >> a[i];\n        int minn = a[n];\n        int flag = 0, ret = 0;\n        for (int i = n - 1; i >= 1; i--)\n        {\n            if (a[i] > minn)\n                flag = 1, ret = max(ret, a[i] - minn);\n            else\n                minn = min(a[i], minn);\n        }\n        if (!flag)\n            cout << 0 << endl;\n        else\n        {\n            int x = 1, cnt = 0;\n            while (ret > 0)\n            {\n                ret -= x;\n                x *= 2;\n                cnt++;\n            }\n            cout << cnt << endl;\n        }\n    }\n    return 0;\n}\n```\n\n\n### D题\n\n**题意：现在给你一颗无根树，然后给无根树每一条边赋值，要求任意两个叶子节点的路径上的边的权值异或和为0，求填写方案中权值种类的最大值和最小值。**\n\n**这道题的话，我们先考虑最小值，最好的情况就是全部都是1，那么最小值就为1，但是如果有两个叶子结点之间的距离为奇数的话，异或的结果就不为1，参考样例2，这时候的最小值就为3。判断叶子节点之间的距离奇偶性一个比较好的方法就可以统计所有的深度，如果又有奇数又有偶数的话，就肯定有两个叶子结点之间距离为偶数再来考虑最大值，我们可以试着将所有边权构造为不能的数，但是这样会出现一种情况就是一个父亲节点连接多个叶子，这样是不可能的，这时候答案就为n−1−x，x为符合要求的父亲节点所连接的叶子节点数。**\n\n**AC代码：**\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxx = 100010;\nconst int inf = 0x3f3f3f3f;\nconst int mod = 1000000009;\nusing namespace std;\nvector<ll> G[maxx];\nvector<ll> ans;\nll deep[maxx], vis[maxx];\nint dfs(ll u, ll pre)\n{\n    deep[u] = deep[pre] + 1;\n    vis[u] = pre;\n    for (auto v : G[u])\n    {\n        if (G[v].size() == 1)\n            ans.push_back(u);\n        if (v == pre)\n            continue;\n        dfs(v, u);\n    }\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int n, u, v;\n    cin >> n;\n    for (int i = 1; i < n; i++)\n    {\n        cin >> u >> v;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    deep[0] = -1;\n    dfs(1, 0);\n    ll f = 0, cnt = 0, tot = 0;\n    for (int i = 1; i <= n; i++)\n    {\n        if (G[i].size() == 1 && deep[i] % 2 == 0)\n            cnt++;\n        if (G[i].size() == 1 && deep[i] % 2)\n            tot++;\n    }\n    if (cnt >= 1 && tot >= 1)\n        f = 1;\n    if (f != 0)\n        cout << \"3 \";\n    else\n        cout << \"1 \";\n    sort(ans.begin(), ans.end());\n    ll ma = n - 1;\n    for (int i = 0; i < ans.size(); i++)\n        if (i)\n        {\n            if (ans[i] == ans[i - 1])\n                --ma;\n        }\n    cout << ma;\n    return 0;\n}\n```\n","tags":["CF"],"categories":["CF"]},{"title":"2020HDU多校第二场","url":"/2020/07/27/2020HDU多校第二场/","content":"\n### Total Eclipse（HDU-6763）（1001）\n\n**题意：现在有n个城市和m条双向通道用于连接城市，然后每个城市都有一个亮度b。然后现在有人想把所以城市的亮度全部降为0。他可以有k次操作，每次可以选择1~n之间任意数量的城市进行降1的亮度，问你最少需要多少次操作才可以将所以城市亮度都降为0。**\n\n<!--more-->\n\n**思路：这道题的话，在昨天比赛的时候我和我的队友也想到了用并查集来做，但是却没能实现。然后我看了看大佬们实现的代码，有了一些想法。我们可以先将我们的亮度从大到小排序，然后我们依次加入x点，并且加入和这个点相连的所有点，如果新加入的y点的亮度大于x点，那么我们就把他们合并。在之后我们计算答案的时候，对于x节点，当需要删除他的时候他已经减去了他的父亲节点的亮度了，所以只需要再减去剩下的$d−dfather$的答案。所以最后求一下和就可以了。**\n\n**AC代码：**\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxx = 200010;\nconst int inf = 0x3f3f3f3f;\nusing namespace std;\nint d[maxx], pre[maxx], fa[maxx], vis[maxx], num[maxx];\nvector<int> g[maxx];\nbool cmp(int a, int b)\n{\n    return d[a] > d[b];\n}\nint getf(int a)\n{\n    if (pre[a] == a)\n        return pre[a];\n    return pre[a] = getf(pre[a]);\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int t, n, m;\n    cin >> t;\n    while (t--)\n    {\n        cin >> n >> m;\n        for (int i = 1; i <= n; i++)\n            g[i].clear();\n        for (int i = 1; i <= n; i++)\n        {\n            cin >> d[i];\n            pre[i] = i;\n            vis[i] = fa[i] = 0;\n            num[i] = i;\n        }\n        sort(num + 1, num + 1 + n, cmp);\n        for (int i = 1; i <= m; i++)\n        {\n            int a, b;\n            cin >> a >> b;\n            g[a].push_back(b);\n            g[b].push_back(a);\n        }\n        for (int i = 1; i <= n; i++)\n        {\n            int x = num[i];\n            vis[x] = 1;\n            for (auto it : g[x])\n            {\n                if (!vis[it])\n                    continue;\n                int fy = getf(it);\n                if (fy == x)\n                    continue;\n                fa[fy] = pre[fy] = x;\n            }\n        }\n        ll res = 0;\n        for (int i = 1; i <= n; i++)\n            res += d[i] - d[fa[i]];\n        cout << res << endl;\n    }\n    return 0;\n}\n```\n\n\n### Lead of Wisdom(HDU-6772) (1010)\n\n**题意：给你k种类型的物品若干种，一个种类只能选一种物品，求题中DMG的最大值。**\n\n**思路：这道题的话，直接暴搜竟然可以，参考了些大佬的思路，感觉自己也明白了。暴搜的话正着dfs会wa，反着dfs即可。**\n\n**AC代码：**\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxx = 1010;\nconst int inf = 0x3f3f3f3f;\nusing namespace std;\nint f[maxx][maxx][5], ans[maxx];\nll res;\nint n, m;\nvoid dfs(int x, int a, int b, int c, int d)\n{\n    if (x < 1)\n    {\n        ll tmp = 1ll * a * b * c * d;\n        res = max(res, tmp);\n        return;\n    }\n    if (!ans[x])\n    {\n        dfs(x - 1, a, b, c, d);\n        return;\n    }\n    for (int i = 1; i <= ans[x]; i++)\n        dfs(x - 1, f[x][i][1] + a, f[x][i][2] + b, f[x][i][3] + c, f[x][i][4] + d);\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int t;\n    cin >> t;\n    while (t--)\n    {\n        res = 0;\n        cin >> n >> m;\n        for (int i = 1; i <= m; i++)\n            ans[i] = 0;\n        for (int i = 1; i <= n; i++)\n        {\n            int cnt;\n            cin >> cnt;\n            ans[cnt]++;\n            for (int j = 1; j <= 4; j++)\n                cin >> f[cnt][ans[cnt]][j];\n        }\n        dfs(1, 100, 100, 100, 100);\n        cout << res << endl;\n    }\n    return 0;\n}\n```\n\n\n### The Oculus(HDU-6768) (1006)\n\n**题意：给你两个数，每个都是用斐波那契数列（01表示）来表示的，规定$F1=1,F2=2$，再给你他们相乘后的结果C用斐波那契数列来表示，现在我将C中的斐波那契数列的某一位1删掉，问你删掉的是哪一位。**\n\n**思路：这道题的话，双哈希过去。因为我们只是把一个1翻成了0，所以枚举C数组遇见0就把他翻转过来看是不是hash值相等，如果相等则答案就是这一位。**\n\n**AC代码：**\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxn = 2000010;\nconst int inf = 0x3f3f3f3f;\nconst int mod = 1e9 + 9;\nconst int mod1 = 1e9 + 7;\nusing namespace std;\nll f[maxn], f1[maxn];\nll na, nb, nc, sa, sb, sc, sa1, sb1, sc1;\nll a[maxn], b[maxn], c[maxn];\nvoid solve()\n{\n    scanf(\"%lld\", &na);\n    for (int i = 1; i <= na; i++)\n        scanf(\"%lld\", &a[i]);\n    scanf(\"%lld\", &nb);\n    for (int i = 1; i <= nb; i++)\n        scanf(\"%lld\", &b[i]);\n    scanf(\"%lld\", &nc);\n    for (int i = 1; i <= nc; i++)\n        scanf(\"%lld\", &c[i]);\n    sa = sb = sc = 0;\n    sa1 = sb1 = sc1 = 0;\n    for (int i = 1; i <= na; i++)\n        sa = (sa + f[i] * a[i]) % mod;\n    for (int i = 1; i <= nb; i++)\n        sb = (sb + f[i] * b[i]) % mod;\n    for (int i = 1; i <= nc; i++)\n        sc = (sc + f[i] * c[i]) % mod;\n    for (int i = 1; i <= na; i++)\n        sa1 = (sa1 + f1[i] * a[i]) % mod1;\n    for (int i = 1; i <= nb; i++)\n        sb1 = (sb1 + f1[i] * b[i]) % mod1;\n    for (int i = 1; i <= nc; i++)\n        sc1 = (sc1 + f1[i] * c[i]) % mod1;\n    for (int i = 1; i <= nc; i++)\n        if (c[i] == 0)\n        {\n            int tmp = (sc + f[i]) % mod, tmp1 = (sc1 + f1[i]) % mod1;\n            if (tmp == (sa * sb) % mod && tmp1 == (sa1 * sb1) % mod1)\n            {\n                printf(\"%lld\\n\", i);\n                break;\n            }\n        }\n}\nint main()\n{\n    f[1] = 1, f[2] = 2;\n    for (int i = 3; i < maxn; i++)\n        f[i] = (f[i - 1] + f[i - 2]) % mod;\n    f1[1] = 1, f1[2] = 2;\n    for (int i = 3; i < maxn; i++)\n        f1[i] = (f1[i - 1] + f1[i - 2]) % mod1;\n    int t;\n    cin >> t;\n    while (t--)\n        solve();\n    return 0;\n}\n\n```\n","tags":["HDU"],"categories":["多校"]},{"title":"Codeforces 635(Div.2)","url":"/2020/07/27/Codeforces 635(Div.2)/","content":"\n### A题\n\n**题意：给你$a,b,c,d$四个数，然后规定$a<=b<=c<=d$。然后给你$x,y,z$，规定，$a<=x<=b$,$b<=y<=c$,$c<=z<=d$,$x,y,z$可以构成面积为正的三角形，问你$x,y,z$。**\n\n<!--more-->\n\n**思路：这道题的话，根据题意，我们直接输出$b,c,c$即可。**\n\n**AC代码：**\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxn = 100010;\nconst int inf = 0x3f3f3f3f;\nusing namespace std;\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    ll t,a,b,c,d;\n    cin>>t;\n    while(t--)\n    {\n        cin>>a>>b>>c>>d;\n        cout<<b<<\" \"<<c<<\" \"<<c<<endl;\n    }\n    return 0;\n}\n```\n\n\n### B题\n\n**题意：kana现在在玩一个游戏，她想猎杀一条龙，龙的初始生命值是x，当$x<=0$的时候，说明猎杀成功。kana有两个技能，第一个技能可以使$x=x/2+10$，第二个技能可以使$x=x-10$。然后第一个技能可以使用n次，第二个技能可以使用m次，问你能不能成功猎杀龙。**\n\n**思路：这道题的话，通过读题我们可以发现当$x<20$之后，用第一次技能会使x变大，所以我们就先将x通过第一个技能尽可能的降至大于20且最小的血量，再用第二个技能判断其是否会小于等于0。**\n\n**AC代码：**\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxn = 100010;\nconst int inf = 0x3f3f3f3f;\nusing namespace std;\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int t;\n    cin >> t;\n    while (t--)\n    {\n        int x, n, m;\n        cin >> x >> n >> m;\n        while (n && x>20)\n        {\n            n--;\n            x = x / 2 + 10;\n        }\n        if (x <= m * 10)\n            cout << \"YES\" << endl;\n        else\n            cout << \"NO\" << endl;\n    }\n    return 0;\n}\n```\n\n\n### C题\n\n**题意：给你一颗树，这棵树有两种顶点，一个是旅游节点，一个是工业节点，你如何设置工业节点让每一个工业节点到根节点路上得旅游节点的总和最大。**\n\n**思路：这道题的话，我们可以求出每一个节点的深度，这个就是每一个节点能够得到的最大的权值，然后就是计算每一个节点下面有多少个工业节点，因为如果这个作为工业节点的话，那么后面的工业得节点的权值都会减1，所以我们就可以得到每一个节点的计算公式$val=deep−ans$，然后进行排序取k个最大的相加，得到的和就是答案了。**\n\n**AC代码：**\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxn = 200010;\nconst int inf = 0x3f3f3f3f;\nusing namespace std;\nvector<ll> G[maxn];\nvector<ll> sum;\nint n, k;\nbool cmp(int a, int b)\n{\n    return a > b;\n}\nint dfs(int u, int pre, int deep)\n{\n    int ans = 1;\n    for (int i = 0; i < G[u].size(); i++)\n    {\n        int v = G[u][i];\n        if (v == pre)\n            continue;\n        ans += dfs(v, u, deep + 1);\n    }\n    sum.push_back(deep - ans);\n    return ans;\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n >> k;\n    for (int i = 0; i < n - 1; i++)\n    {\n        int u, v;\n        cin >> u >> v;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    dfs(1, 0, 1);\n    sort(sum.begin(), sum.end(), cmp);\n    ll cnt = 0;\n    for (int i = 0; i < k; i++)\n        cnt += 1ll * sum[i];\n    cout << cnt << endl;\n    return 0;\n}\n```\n","tags":["CF"],"categories":["CF"]},{"title":"Codeforces 634(Div.3)","url":"/2020/07/25/Codeforces 634(Div.3)/","content":"\n### A题\n\n**题意：你现在有n块糖果，然后你要把n块糖果分给Alice和Betty。Alice分得a块糖果，Betty分得b块糖果。然后约束条件是$a>b$且$a+b=n$，问你有多少种可以表示$n=a+b$的分解方法。**\n\n<!--more-->\n\n**思路：这道题的话，通过看题不难看出当$n<=2$的时候是不能分解的；当$n>2$的时候就是共有$(n-1)/2$种分解方法。**\n\n**AC代码：**\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxx = 100010;\nconst int inf = 0x3f3f3f3f;\nusing namespace std;\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int t;\n    cin >> t;\n    while (t--)\n    {\n        int n;\n        cin >> n;\n        if (n <= 2)\n            cout << \"0\" << endl;\n        else\n            cout << (n - 1) / 2 << endl;\n    }\n    return 0;\n}\n```\n\n\n### B题\n\n**题意：给你三个整数n,a,b表示在n长度的字符串中，每a个连续的字串中，含有b个不同的字母。然后问你满足要求的字符串。**\n\n**思路：这道题的话，我们构造一下即可。首选我们在a-b的位置构造不同的字母，然后b~a的位置再构造相同的字母，最后我们再重复前面的即可。**\n\n**AC代码：**\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxx = 100010;\nconst int inf = 0x3f3f3f3f;\nusing namespace std;\nchar s[maxx];\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int t;\n    cin >> t;\n    while (t--)\n    {\n        int n, a, b;\n        cin >> n >> a >> b;\n        char c = 'a';\n        memset(s, 0, sizeof(s));\n        for (int i = 0; i < a; i++)\n        {\n            if (i < b)\n                s[i] = c + i;\n            else\n                s[i] = 'a';\n            cout << s[i];\n        }\n        for (int i = a; i < n; i++)\n            cout << s[i % a];\n        cout << endl;\n    }\n    return 0;\n}\n```\n\n\n### C题\n\n**题意：给你一个序列a，然后你可以将里面的元素进行分组，第一组的元素全部都要不同的，第二组全部都要相同的最后两组的数量要一样，问最大的数量是多少。**\n\n**思路：这道题的话，先用ans记录不同的技能一共有多少人，然后用map记录每个技能的人数有多少人。之后从1~n遍历，如果不同的人数大于相同的，则计算不同的人数；如果不同的人数小于相同的，则计算相同的人数；如果二者相等，求不同的人数减一，因为不同的人数当中包含了相同的，求每一个循环的最大值。**\n\n**AC代码：**\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxx = 200010;\nconst int inf = 0x3f3f3f3f;\nusing namespace std;\nint a[maxx];\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int t, n;\n    cin >> t;\n    while (t--)\n    {\n        cin >> n;\n        map<int, int> h;\n        set<int> s;\n        for (int i = 1; i <= n; i++)\n        {\n            cin >> a[i];\n            h[a[i]]++;\n            s.insert(a[i]);\n        }\n        int cnt = s.size();\n        int m = 0;\n        for (int i = 1; i <= n; i++)\n        {\n            if (cnt > h[a[i]])\n                m = max(m, h[a[i]]);\n            else if (cnt == h[a[i]])\n                m = max(m, h[a[i]] - 1);\n            else\n                m = max(m, cnt);\n        }\n        cout << m << endl;\n    }\n    return 0;\n}\n```\n\n\n### D题\n\n**题意：给你一个9x9的数独，现在要你改数独，要求每一个3x3的块都包含至少两个相同的数字。**\n\n**思路：这道题的话，我们只需要随便找一个数字改成另一个数字即可。**\n\n**AC代码：**\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxx = 10;\nconst int inf = 0x3f3f3f3f;\nusing namespace std;\nchar a[maxx][maxx];\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int t;\n    cin >> t;\n    while (t--)\n    {\n        for (int i = 1; i <= 9; i++)\n        {\n            for (int j = 1; j <= 9; j++)\n            {\n                cin >> a[i][j];\n                if (a[i][j] == '2')\n                    a[i][j] = '1';\n            }\n        }\n        for (int i = 1; i <= 9; i++)\n        {\n            for (int j = 1; j <= 9; j++)\n            {\n                cout << a[i][j];\n            }\n            cout << endl;\n        }\n    }\n    return 0;\n}\n```\n","tags":["CF"],"categories":["CF"]},{"title":"Codeforces 632(Div.2)","url":"/2020/07/25/Codeforces 632(Div.2)/","content":"\n### A题\n\n**题意：B是有白格子相邻的黑格子数，W是有黑格子相邻的白格子数，合法涂色方案为B=W+1。**\n\n<!--more-->\n\n**思路：这道题的话，给定了矩阵，那么只需要一个角落的格子为白色，其余都为黑色即可。**\n\n**AC代码：**\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxx = 100010;\nconst int inf = 0x3f3f3f3f;\nusing namespace std;\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int t, n, m;\n    cin >> t;\n    while (t--)\n    {\n        cin >> n >> m;\n        for (int i = 0; i < n; i++)\n        {\n            for (int j = 0; j < m; j++)\n            {\n                if (i == 0 && j == 0)\n                    cout << \"W\";\n                else\n                    cout << \"B\";\n            }\n            cout << endl;\n        }\n    }\n    return 0;\n}\n```\n\n\n### B题\n\n**题意：给定$a、b$序列，如果$i>j$，若则可以进行操作$a_{j}=a_{i}+a_{j}$，问能不能使a序列变成b序列。**\n\n**这道题的话，因为我们是通过操作使得a序列变成b序列，所以我们从后面开始看，如果$b[i]>a[i]$的话，要让$a[i]$变大的话，前面一定要有1；如果$b[i]<a[i]$的话，要让$a[i]$变小的话，前面一定要有-1，否则不合法。然后我们记住最左面的1和-1的位置判断即可。**\n\n**AC代码：**\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxx = 100010;\nconst int inf = 0x3f3f3f3f;\nusing namespace std;\nint a[maxx], b[maxx];\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int t;\n    cin >> t;\n    while (t--)\n    {\n        int n;\n        cin >> n;\n        int ans = inf, cnt = inf;\n        for (int i = 0; i < n; i++)\n        {\n            cin >> a[i];\n            if (a[i] == 1 && ans == inf)\n                ans = i;\n            if (a[i] == -1 && cnt == inf)\n                cnt = i;\n        }\n        int flag = 1;\n        for (int i = 0; i < n; i++)\n        {\n            cin >> b[i];\n            if (b[i] > a[i] && ans >= i)\n                flag = 0;\n            if (b[i] < a[i] && cnt >= i)\n                flag = 0;\n        }\n        if (flag)\n            cout << \"YES\" << endl;\n        else\n            cout << \"NO\" << endl;\n    }\n    return 0;\n}\n```\n\n\n### C题\n\n**题意：如果一个序列的所有非空子序列的和都不为零，则称该序列是一个好序列。现给定一个序列，求有多少个非空子序列是好序列。**\n\n**思路：这道题的话，首先区间$[i,j]$和为$0$,可以得到:$sum[i]=sum[j]$，然后如果一个区间$[i,j]$和为$0$那么从$j+1$开始才存在好区间，最后用$cnt$记录上一个可以包含的左端,那么每次加上$i-cnt$,遍历完就是答案。**\n\n**AC代码：**\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxx = 100010;\nconst int inf = 0x3f3f3f3f;\nusing namespace std;\nmap<ll, ll> mapp;\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    ll n;\n    cin >> n;\n    mapp[0] = 1;\n    ll m, ans = 0, sum = 0, cnt = 0;\n    for (ll i = 1; i <= n; i++)\n    {\n        cin >> m;\n        sum += m;\n        cnt = max(cnt, mapp[sum]);\n        ans += (i - cnt);\n        mapp[sum] = i + 1;\n    }\n    cout << ans << endl;\n    return 0;\n}\n```\n","tags":["CF"],"categories":["CF"]},{"title":"Codeforces 631(Div.2)","url":"/2020/07/24/Codeforces 631(Div.2)/","content":"\n### A题\n\n**题意：给你一个a序列代表每次的排名，在n个比赛之后还有x场比赛，然后你去寻找一个最大的v代表这n+x比赛后比赛的连续的最大的排名是多少。**\n\n<!--more-->\n\n**思路：这道题的话，我们可以用cnt去记录此时的最高排名有没有出现过，如果没有的话，那就将x−−，最后当x=0并且cnt此时最后排名没有出现过的话，那么前一个就是答案了。**\n\n**AC代码：**\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxx = 100010;\nconst int inf = 0x3f3f3f3f;\nconst int mod = 1000000009;\nusing namespace std;\nint a[110];\nint cnt[1010];\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int t, n, x;\n    cin >> t;\n    while (t--)\n    {\n        cin >> n >> x;\n        memset(cnt, 0, sizeof(cnt));\n        for (int i = 0; i < n; i++)\n        {\n            cin >> a[i];\n            cnt[a[i]]++;\n        }\n        int k = 0;\n        for (int i = 1; x; i++)\n        {\n            if (cnt[i] == 0)\n                x--, k = i, cnt[i]++;\n        }\n        for (int i = k;; i++)\n        {\n            if (cnt[i] == 0)\n            {\n                k = i - 1;\n                break;\n            }\n        }\n        printf(\"%d\\n\", k);\n    }\n    return 0;\n}\n```\n\n\n### B题\n\n**题意：给出一组数，要求分成两部分，一部分假设有m个数，保证这部分的数字从1-m均出现而且仅出现一次。输出所有可能。**\n\n**思路：这道题的话，显然分出的两段是合法的，当且仅当段的最大值等于段的长度时段内没有重复元素，于是先扫一遍得到正序倒序第一个重复元素的位置，再正反各扫一遍得到前缀后缀最大值即可。**\n\n**AC代码：**\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxx = 200010;\nconst int inf = 0x3f3f3f3f;\nusing namespace std;\nint a[maxx], p[maxx], q[maxx];\nint t, n, l, r;\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> t;\n    while (t--)\n    {\n        cin >> n;\n        for (int i = 1; i <= n; i++)\n            cin >> a[i];\n        set<int> s;\n        for (int i = 1; i <= n; i++)\n        {\n            if (s.find(a[i]) == s.end())\n            {\n                s.insert(a[i]);\n            }\n            else\n            {\n                l = i - 1;\n                break;\n            }\n        }\n        s.clear();\n        for (int i = n; i >= 1; --i)\n        {\n            if (s.find(a[i]) == s.end())\n            {\n                s.insert(a[i]);\n            }\n            else\n            {\n                r = i + 1;\n                break;\n            }\n        }\n        for (int i = 1; i <= n; i++)\n            p[i] = max(p[i - 1], a[i]);\n        for (int i = n; i >= 1; --i)\n            q[i] = max(q[i + 1], a[i]);\n        vector<int> ans;\n        for (int i = 1; i < n; i++)\n        {\n            if (i <= l && i + 1 >= r && p[i] == i && q[i + 1] == n - i)\n            {\n                ans.push_back(i);\n            }\n        }\n        cout << ans.size() << endl;\n        for (int i : ans)\n            cout << i << \" \" << n - i << endl;\n        for (int i = 1; i <= n; i++)\n            p[i] = q[i] = 0;\n    }\n    return 0;\n}\n```\n\n\n### C题\n\n**题意：给你n和m，表示你有m个操作要让n涂满颜色而且每种颜色都要存在，每个m操作都给你一个ai表示涂色的范围，现在问要求你求出pi（pi表示从pi~pi+ai全部都涂成i颜色）。**\n\n**这道题的话，根据题意我们先想出不能实现的情况。分为两种，第一种就是把所有的ai加在一起都小于n的话，就不能实现；第二种就是n−ai+1<i的话那么也是不可以的，因为这样会把之前的ith覆盖。然后我们才可以求序列，可以先求出后缀和，然后求出max(i,n−sumi+1)因为sumi是后缀和，表示的是后面的是否可以让此时的i满足剩余的ai涂满色到结尾。**\n\n**AC代码：**\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxx = 100010;\nconst int inf = 0x3f3f3f3f;\nusing namespace std;\nll a[maxx], sum[maxx];\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int n, m;\n    cin >> n >> m;\n    for (int i = 1; i <= m; i++)\n        cin >> a[i];\n    for (int i = 1; i <= m; i++)\n    {\n        if (n - a[i] + 1 < i)\n        {\n            cout << \"-1\" << endl;\n            return 0;\n        }\n    }\n    memset(sum, 0, sizeof(0));\n    for (int i = m; i >= 1; i--)\n        sum[i] = sum[i + 1] + a[i];\n    if (sum[1] < n)\n    {\n        cout << \"-1\" << endl;\n        return 0;\n    }\n    for (int i = 1; i <= m; i++)\n    {\n        int ans = max(1ll * i, n - sum[i] + 1);\n        cout << ans << \" \";\n    }\n    return 0;\n}\n```\n","tags":["CF"],"categories":["CF"]},{"title":"Distinct Sub-palindromes（HDU-6754）","url":"/2020/07/24/Distinct Sub-palindromes（HDU-6754）（2020HDU多校第一场）/","content":"\n**Problem Description**\nS is a string of length n. S consists of lowercase English alphabets.\n\nYour task is to count the number of different S with the minimum number of distinct sub-palindromes. Sub-palindrome is a palindromic substring.\n\n<!--more-->\n\nTwo sub-palindromes u and v are distinct if their lengths are different or for some i (0≤i≤length), ui≠vi. For example, string “aaaa” contains only 4 distinct sub-palindromes which are “a”, “aa”, “aaa” and “aaaa”.\n \n\n**Input**\nThe first line contains an integer T (1≤T≤105), denoting the number of test cases.\n\nThe only line of each test case contains an integer n (1≤n≤109).\n \n\n**Output**\nFor each test case, output a single line containing the number of different strings with minimum number of distinct sub-palindromes.\n\nSince the answer can be huge, output it modulo 998244353.\n \n\n**Sample Input**\n2\n1\n2\n \n\n**Sample Output**\n26\n676\n\n**题意：**\n**给你长度为n的字符串，要求子回文串尽可能的少。**\n\n**思路：**\n**这道题的话，给的题面感觉不好理解，读了好多遍题才读懂，看来阅读要下点功夫了。。。然后跟队友讨论发现就是能组成最少不同子回文串的最少不同字符串数量是n个26相乘。但是后来又发现当n>=4的时候，最少的子回文串就是3个，因为我们只需要3个不同的字母无限填充即可，所以当n>=4的时候就是26*25*24。**\n\n**AC代码：**\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxx=100010;\nconst int inf=0x3f3f3f3f;\nconst int mod=1000000009;\nusing namespace std;\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int t;\n    cin>>t;\n    while(t--)\n    {\n        int n;\n        cin>>n;\n        if(n==1)\n        cout<<26<<endl;\n        else if(n==2)\n        cout<<26*26<<endl;\n        else if(n==3)\n        cout<<26*26*26<<endl;\n        else\n        cout<<26*25*24<<endl;\n    }\n    return 0;\n}\n```\n","tags":["字符串"],"categories":["2020HDU多校"]},{"title":"计算机网络实验项目二","url":"/2020/06/02/计算机网络实验2/","content":"\n## 实验名称：实验项目2 主机系统网络参数配置与测试\n\n<!--more-->\n\n## 实验目的\n\n**掌握IP地址的基本结构(网络部分与主机部分的区分) 掌握子网掩码的含义 掌握IP包的组成格式 理解IP数据包在网络中的转发方式。**\n\n## 实验步骤与调试过程(请用简单的文字描述)\n\n```\n（1）查看、配置主机和相关网络设备的参数，包括IP地址、物理地址、DNS服务器地址、网关地址等参数。\n（2）测试网络的连通性。\n（3）IP地址的基本结构及IP数据包在网络中的转发方式。\n```\n\n## 实验结果(上传实验结果截图或者简单文字描述)\n\n**（1）表 2-1 设备/接口参数表。**\n\n![tupian1](https://img-blog.csdnimg.cn/20200602202604195.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg0NjEzOQ==,size_16,color_FFFFFF,t_70)\n\n![tupian2](http://61.163.231.201:8000/Lab//ueditor/jsp/upload/image/20200602/1591069765208094518.png)\n\n![tupian3](http://61.163.231.201:8000/Lab//ueditor/jsp/upload/image/20200602/1591069781271040961.png)\n\n**（2）按表 2-2 测试各主机或接口的连通性（从工具栏中选择“AddSimplePDU”工具， 然后依次点击“源主机”、“目的主机”，表示“源主机 ping 目的主机”（也可以打开 PC 机的命令行界 面，输入 “ping 目标 ip 地址”））。**\n\n表 2-2 各主机或接口的连通性测试表\n\n![tupian4](https://img-blog.csdnimg.cn/2020060220281349.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg0NjEzOQ==,size_16,color_FFFFFF,t_70)\n\n**（3）点击 切换到模拟器/simulation模式下，重新测试上一步（2）中表2-2中不能连通的项目。**\n\n![tupian5](http://61.163.231.201:8000/Lab//ueditor/jsp/upload/image/20200602/1591069911036014794.png)\n\n![tupian6](http://61.163.231.201:8000/Lab//ueditor/jsp/upload/image/20200602/1591069920708063120.png)\n\n表2-3 步骤（2）中表2-2测试中不能连通的项目测试表\n\n![tupian7](https://img-blog.csdnimg.cn/20200602202959409.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg0NjEzOQ==,size_16,color_FFFFFF,t_70)\n\n**（4）在步骤（1）的基础上为各 PC 配置默认网关，如表 2-4 所示。完成表 2-5 的测试内容。**\n\n![tupian8](https://img-blog.csdnimg.cn/20200602203115788.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg0NjEzOQ==,size_16,color_FFFFFF,t_70)\n\n点击 切换到模拟器/simulation模式下，按表2-5、2-6要求进行测试，观察网络层和数据链路层\n协议数据单元（PDU）在源主机PC0和路由器（如果需要通过路由器转发）上的封装情况，完成下表表2-5,2-6 的内容。 \n\n表 2-5 数据在源主机PC0上的封装情况\n\n![tupian9](https://img-blog.csdnimg.cn/20200602203210715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg0NjEzOQ==,size_16,color_FFFFFF,t_70)\n\n表 2-6 数据包在路由器上的封装情况\n\n![tupian10](https://img-blog.csdnimg.cn/20200602203302346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg0NjEzOQ==,size_16,color_FFFFFF,t_70)\n\n**PS:**\n\n问题：通过以上实验，请分析默认网关的作用是什么？\n\n网关是一种充当转换重任的计算机系统或设备，在使用不同的通信协议，数据格式或语言,甚至体系结构完全不同的两种系统时，网关是一个翻译器。与网桥只是简单地传送信息不同，网关对收到的信息要重新打包，以适应目的系统的需求。同时，网关也可以提供过滤和安全功能。这就是为什么我们在有路由器上网的时候，必须要把计算机中的默认网关地址设置成路由器LAN接口的地址的原因，因为路由器的LAN接口就是你所在网络的网关，你的电脑要上网，数据包必须要经过网关转发出去。简单来说，网关是设备与路由器之间的桥梁，正确的网关配置才能保证用户可以正常上网。\n\n**（5）在步骤（4）的基础上只改变 PC1 和 PC3 的子网掩码，如表 2-6 所示。完成表 2-7 连通性测试。**\n\n![tupian11](https://img-blog.csdnimg.cn/20200602203425655.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg0NjEzOQ==,size_16,color_FFFFFF,t_70)\n\n## 疑难小结(总结个人在实验中遇到的问题或者心得体会)\n\n```\n1.刚开始配置路由器IP地址的时候看成了配置交换器IP地址，然后查阅了一些资料把交换器IP地址给配送了，后来才发现不对。\n2.在切换到模拟器进行连通性测试的时候，连接错了主机接口，然后不知道怎么取消，又重新连接了一遍拓扑图。\n```\n\n## 实验详细操作步骤或程序清单\n\n```\n1.连接拓扑图。\n\n2.按表 2-2 测试各主机或接口的连通性（从工具栏中选择“AddSimplePDU”工具， 然后依次点击“源主机”、“目的主机”，表示“源主机 ping 目的主机”（也可以打开 PC 机的命令行界 面，输入 “ping 目标 ip 地址”））。\n\n3.点击 切换到模拟器/simulation模式下，重新测试上一步（2）中表2-2中不能连通的项目。\n\n4.在步骤（1）的基础上为各 PC 配置默认网关，如表 2-4 所示。完成表 2-5 的测试内容。 \n\n5.在步骤（4）的基础上只改变 PC1 和 PC3 的子网掩码，如表 2-6 所示。完成表 2-7 连通性测试。\n```\n","tags":["计算机网络上机实验"],"categories":["计算机网络"]},{"title":"计算机网络实验项目一","url":"/2020/06/02/计算机网络实验一/","content":"\n## 实验名称：实验项目1 交换式局域网的构建与交换机的工作原理\n\n<!--more-->\n\n## 实验目的\n\n**掌握在Packet Tracer软件中搭建实验平台，配置基本的网络参数，测试网络的连通性。 理解交换机的交换原理对不同类型数据帧的处理方式。**\n\n## 实验步骤与调试过程(请用简单的文字描述)\n\n```\n（1）利用Packet Tracer仿真软件搭建一个局域网，主要由交换机和若干台计算机组成。\n（2）配置基本的网络参数，测试网络的连通性。\n（3）查看交换机的MAC地址映射表并记录相关数据。\n```\n\n## 实验结果(上传实验结果截图或者简单文字描述)\n\n**1.先利用Packet Tracer仿真软件搭建一个局域网，主要由一个交换机和四台计算机组成。**\n\n![tupian1](http://61.163.231.201:8000/Lab//ueditor/jsp/upload/image/20200601/1591004844833082829.png)\n\n**2.按照所给IP地址以及掩码表给每一台PC配上IP地址以及掩码。**\n\n![tupian2](http://61.163.231.201:8000/Lab//ueditor/jsp/upload/image/20200601/1591005082068066465.png)\n\n**3.发送报文（PC0->PC1）。**\n\n![tupian3](http://61.163.231.201:8000/Lab//ueditor/jsp/upload/image/20200601/1591005158146044811.png)\n\n**4.观察MAC表变化。**\n\n![tupian4](http://61.163.231.201:8000/Lab//ueditor/jsp/upload/image/20200601/1591005223005003171.png)\n\n![tupian5](http://61.163.231.201:8000/Lab//ueditor/jsp/upload/image/20200601/1591005240802072987.png)\n\n![tupian6](http://61.163.231.201:8000/Lab//ueditor/jsp/upload/image/20200601/1591005257771047365.png)\n\n![tupian7](http://61.163.231.201:8000/Lab//ueditor/jsp/upload/image/20200601/1591005266974083309.png)\n\n**5.切换到模拟器/simulation模式下，然后打开PC机的命令行界面，输入 ping 目标ip地址（PC2->PC3）。**\n\n![tupian8](http://61.163.231.201:8000/Lab//ueditor/jsp/upload/image/20200601/1591005322630062107.png)\n\n![tupian9](http://61.163.231.201:8000/Lab//ueditor/jsp/upload/image/20200601/1591005342786085722.png)\n\n**6.记录在表。**\n\n![tupian10](https://img-blog.csdnimg.cn/20200602201747501.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg0NjEzOQ==,size_16,color_FFFFFF,t_70)\n\n**7.通过实验可以验证交换机的工作原理。**\n\n交换机并不会把收到每个数据信息都以广播的方式发给客户端，是由于交换机可以根据MAC地址智能的转发数据帧。交换机存储的MAC地址表将MAC地址和交换机的接口编号对应在一起，每当交换机收到客户端发送来的数据帧时，它就会根据MAC地址表的信息判断该如何转发。\n\n## 疑难小结(总结个人在实验中遇到的问题或者心得体会)\n\n```\n1.刚开始下载好Packet Tracer仿真软件时，不知道怎么去使用它，看了老师发的使用说明才知道大概的使用方法。\n2.在建立拓扑结构图时，连好PC端和交换机之间的连线时，并不是两头都闪绿，靠近交换机那一头闪红，以为连接错了，结果发现原来需要一段时间去连接。\n3.由于刚刚接触这个软件来做计算机网路的实验，还有很多地方感觉到吃力。\n```\n\n## 实验详细操作步骤或程序清单\n\n```\n1.先利用Packet Tracer仿真软件搭建一个局域网，主要由一个交换机和四台计算机组成。\n\n2.按照所给IP地址以及掩码表给每一台PC配上IP地址以及掩码。\n\n3.发送报文（PC0->PC1）。\n\n4.观察MAC表变化。\n\n5.切换到模拟器/simulation模式下，然后打开PC机的命令行界面，输入 ping 目标ip地址（PC2->PC3）。\n\n6.记录在表。\n\n7.通过实验可以验证交换机的工作原理。\n```\n","tags":["计算机网络上机实验"],"categories":["计算机网络"]},{"title":"数据库原理及应用上机实验三","url":"/2020/06/02/数据库原理及应用上机实验三/","content":"\n## 实验名称：实验三 数据高级查询\n\n<!--more-->\n\n## 实验目的\n\n**掌握复杂数据查询操作。**\n\n## 实验步骤与调试过程(请用简单的文字描述)\n\n```sql\n对各表中的数据进行不同条件的连接查询和嵌套查询；\n（1）查询每个学生及其选课情况；\n（2）查询每门课的间接先修课\n（3）将STUDENT,SC进行右连接\n（4）查询既选修了2号课程又选修了3号课程的学生姓名、学号；\n（5）查询和刘晨同一年龄的学生\n（6）选修了课程名为“数据库”的学生姓名和年龄\n（7）查询其他系比IS系任一学生年龄小的学生名单\n（8）查询其他系中比IS系所有学生年龄都小的学生名单\n（9）查询选修了全部课程的学生姓名\n（10）查询计算机系学生及其性别是男的学生\n（11）查询选修课程1的学生集合和选修2号课程学生集合的差集\n（12）查询李丽同学不学的课程的课程号\n（13）查询选修了3号课程的学生平均年龄\n（14）求每门课程学生的平均成绩\n（15）统计每门课程的学生选修人数（超过3人的才统计）。要求输出课程号和选修人数，结果按人数降序排列，若人数相同，按课程号升序排列\n（16）查询学号比刘晨大，而年龄比他小的学生姓名。\n（17）求年龄大于所有女同学年龄的男同学姓名和年龄\n```\n\n## 实验结果(上传实验结果截图或者简单文字描述)\n\n```sql\n1.经过实验可以知道求总数时可以用count（）函数。\n2.在进行分组操作时，用group by 时要用having来限制条件。\n3.order by是排序要求 desc是降序 ，asc是升序。\n4.any（）函数是任意的意思，all（）是所有。\n```\n\n## 疑难小结(总结个人在实验中遇到的问题或者心得体会)\n\n```sql\n1.在进行求总数操作时，由于一开始我不知道有count函数，很是迷茫，后来查阅了资料之后，才得知。\n2.在进行将STUDENT,SC进行右连接的操作时，由于少打了一个关键字，总是报错，后来检查了几遍之后才找到问题。\n3.我对SQL语言还有很多地方不是很熟练，需要勤加练习。\n```\n\n## 实验详细操作步骤或程序清单\n\n```sql\n\n（1） 查询每个学生及其选课情况\n\nselect student.sno,sname,ssex,sage,sdept,cno,grade\nfrom student,sc\nwhere student.sno=sc.sno\n\n（2） 查询每门课的间接先修课\n\nselect first.cno,second.cpno\nfrom course first,course second\nwhere first.cpno=second.cno\n\n（3） 将STUDENT,SC进行右连接\n\nselect student.sno,sname,ssex,sage,sdept,cno,grade\nfrom student right outer join sc on student.sno=sc.sno\n（4） 查询既选修了2号课程又选修了3号课程的学生姓名、学号\n\nselect student.sno,sname\nfrom student inner join sc on student.sno=sc.sno\nwhere cno='3' and sc.sno in\n(select sno\nfrom sc\nwhere cno='2')\n\n（5）查询和刘晨同一年龄的学生\n\nselect student.sno,sname\nfrom student\nwhere sname!='刘晨' and sage=\n(select sage \nfrom student\nwhere sname='刘晨')\n\n（6）选修了课程名为“数据库”的学生姓名和年龄\n\nselect sname,sage\nfrom student\nwhere sno in\n(select sno\nfrom sc\nwhere cno in\n(select cno\nfrom course \nwhere cname='数据库'))\n\n（7）查询其他系比IS系任一学生年龄小的学生名单\n\nselect student.sno,sname\nfrom student\nwhere sdept<>'IS' and\nsage<any\n(select sage \nfrom student\nwhere sdept='IS')\n\n（8）查询其他系中比IS系所有学生年龄都小的学生名单\n\nselect student.sno,sname\nfrom student\nwhere sdept<>'IS' and \nsage<all\n(select sage \nfrom student \nwhere sdept='IS')\n\n（9）查询选修了全部课程的学生姓名\n\nselect sname\nfrom student\nwhere Sno in\n(select Sno from SC\ngroup by Sno\nhaving count(*) = (select count(*) from course ))\n\n（10）查询计算机系学生及其性别是男的学生\n\nselect student.sno,sname\nfrom student\nwhere sdept='IS' and ssex='男'\n\n（11）查询选修课程1的学生集合和选修2号课程学生集合的差集\n\nselect sno\nfrom sc \nwhere cno='1' except \nselect sno\nfrom sc\nwhere cno='2'\n\n（12）查询李丽同学不学的课程的课程号\n\nselect cno\nfrom course\nwhere cno not in\n(select cno\nfrom sc\nwhere sno in\n(select sno\nfrom student\nwhere sname='李丽'))\n\n（13）查询选修了3号课程的学生平均年龄\n\nselect AVG(sage) as avgsage\nfrom student inner join sc on student.sno=sc.sno\nwhere cno='3'\n\n（14）求每门课程学生的平均成绩\n\nselect cno,AVG(grade) as avggrade\nfrom sc\ngroup by cno\n\n（15）统计每门课程的学生选修人数（超过3人的才统计）。要求输出课程号和选修人数，结果按人数降序排列，若人数相同，按课程号升序排列\n\nselect course.cno '课程号', count(sc.sno) '人数'\nfrom course,sc \nwhere course.cno=sc.cno \ngroup by course.cno having count(sc.sno)>3 order by COUNT(sc.sno) desc,course.cno asc\n\n（16）查询学号比刘晨大，而年龄比他小的学生姓名\n\nselect sname\nfrom student\nwhere sno>\n(select sno from student where sname='刘晨')and\nsage<(select sage from student where sname='刘晨')\n\n（17）求年龄大于所有女同学年龄的男同学姓名和年龄\n\nselect sname,sage\nfrom student\nwhere ssex='男'and sage>\n(select MAX(sage) from student where ssex='女')\n```\n","tags":["SQL上机实验"],"categories":["SQL"]},{"title":"数据库原理及应用上机实验四","url":"/2020/06/02/数据库原理及应用上机实验四/","content":"\n## 实验名称：实验四 数据更新和视图\n\n<!--more-->\n\n## 实验目的\n\n1.熟练掌握SQL的常用数据更新操作。\n\n2.熟练应用INSERT,UPDATE,DELETE语句。\n\n3.掌握更新操作的各种格式。\n\n4.掌握视图的创建、更新、删除和查询\n\n## 实验步骤与调试过程(请用简单的文字描述)\n\n```sql\n（1）插入如下学生记录（学号：95030，姓名：李莉，年龄：18）；\n（2）插入如下选课记录（95030，1）；\n（3）计算机系学生年龄改成20；\n（4）数学系所有学生成绩改成0；\n（5）把低于总平均成绩的女同学成绩提高5分；\n（6）修改2号课程的成绩，若成绩小于75分提高5％，成绩大于75时提高4％（两个语句实现，注意顺序）；\n（7）删除95030学生信息；\n（8）删除SC表中无成绩的记录；\n（9）删除张娜的选课记录；\n（10）删除数学系所有学生选课记录；\n（11）删除不及格的学生选课记录；\n（12）查询每一门课程成绩都大于等于80分的学生学号、姓名和性别，把值送往另一个已经存在的基本表STU(SNO,SNAME,SSEX)中；\n（13）把所有学生学号和课程号连接追加到新表中；\n（14）所有学生年龄增1；\n（15）统计3门以上课程不及格的学生把相应的学生姓名、系别追加到另外一个表中。\n（16）将学生学号、总成绩、平均成绩定义成一个视图，以便于查询。\n（17）将Student表中所有女生记录定义为一个视图F_STU，并限制对视图的更新操作不能超过视图条件限制。\n（18）将上一题建立的F_STU视图，更改为给所有男生记录定义的视图，属性包括学号、性别、年龄、所选课程号。\n（19）在上一题的视图中找出选修了3号课程的学生。\n（20）删除视图F_STU。\n```\n\n## 实验结果(上传实验结果截图或者简单文字描述)\n\n```sql\n1. 删除主键表数据如果有外键约束就会报错。\n\n2. 插入数据用insert into 表直接+表。\n\n3. 更新用update。\n\n4. 删除直接用delete 可以直接删除一行数据。\n\n5.操作视图的时候要用到create view。\n```\n\n## 疑难小结(总结个人在实验中遇到的问题或者心得体会)\n\n```sql\n1.修改数据时，如果省略where自子句，则表示要修改表中的所有元组，一开始不知道这个地方，错了好几次。\n2.带子查询的修改语句，因为有update有where语句，而where子句后面可以跟子查询，所以子查询也可以嵌套在update语句中，用以构造执行修改操作的条件。\n3.进行视图操作的时候，一开始不是很熟悉过程，然后看了老师发的课件。课件里面有讲解，然后才做的实验。\n```\n\n## 实验详细操作过程或程序清单\n\n```sql\n（1）插入如下学生记录（学号：95030，姓名：李莉，年龄：18）\n\ninsert into student(sno,sname,sage)\nvalues ('95030','李莉',18)\n\n（2）插入如下选课记录（95030，1）\n\ninsert into sc(sno,cno)\nvalues('95030',1)\n\n（3）计算机系学生年龄改成20\n\nupdate student\nset sage=20\nwhere sdept='CS'\n\n（4）把数学系所有学生成绩改成0\n\nupdate sc\nset grade=0\nwhere 'MA'=\n(select sdept\nfrom student\nwhere student.sno=sc.sno)\n\n（5）把低于总平均成绩的女同学成绩提高5分\n\nupdate sc\nset grade+=5\nwhere grade<\n(select avg(grade)\nfrom sc inner join student\non student.sno=sc.sno\nwhere ssex='女')\n\n（6）修改2号课程的成绩，若成绩小于75分提高5％，成绩大于75时提高4％（两个语句实现，注意顺序）\nupdate sc\nset grade=grade*(1+0.05)\nwhere cno='002' and grade<75;\n\nupdate sc\nset grade=grade*(1+0.04)\nwhere cno='002' and grade>75;\n\n（7）删除95030学生信息\n\ndelete\nfrom student\nwhere sno='95030'\n\n（8）删除SC表中无成绩的记录\n\ndelete\nfrom sc\nwhere grade is null;\n\n（9）删除张娜的选课记录\n\ndelete\nfrom sc\nwhere sno=(select sno from student\nwhere sname='张娜')\n\n（10）删除数学系所有学生选课记录\n\ndelete\nfrom sc\nwhere sno in (select sno from student where sdept='MA')\n\n（11）删除不及格的学生选课记录\n\ndelete\nfrom sc\nwhere grade<60\n\n（12）查询每一门课程成绩都大于等于80分的学生学号、姓名和性别，把值送往另一个已经存在的基本表STU(SNO,SNAME,SSEX)中\n\ncreate table STU\n(sno char(8),\nsname char(8),\nssex char(2)\n)\n\ninsert into STU(sno,sname,ssex)\nselect distinct student.sno,sname,ssex\nfrom student,sc\nwhere student.sno not in\n(select sno from sc where grade<80) and student.sno=sc.sno\n\n（13）把所有学生学号和课程号连接追加到新表中\n\ncreate table stu1\n(\nsno char(8),\ncno char(3)\n);\ninsert into stu1(sno,cno)\nselect sno,cno\nfrom sc;\n\n（14）所有学生年龄增1\n\nupdate student\nset sage=sage+1;\n\n（15）统计3门以上课程不及格的学生把相应的学生姓名、系别追加到另外一个表中\n\ncreate table stu2\n(\nsname char(8),\nsdept char(20)\n);\ninsert into stu2(sname,sdept)\nselect sname,sdept\nfrom student\nwhere sno in\n(\nselect distinct sno\nfrom sc\nwhere grade<60\ngroup by sno\nhaving count(grade)>=3\n);\n\n（16）将学生学号、总成绩、平均成绩定义成一个视图，以便于查询。\n\ncreate view grade_sum_avg\nas\n select sno,sum(grade) as totalgrade,avg(grade) as avg_grade\n from  sc\n group by sno;\n\n（17）将Student表中所有女生记录定义为一个视图F_STU，并限制对视图的更新操作不能超过视图条件限制。\n\ncreate view F_STU(sno,name,dept,sex,age)\n    as\n        select *\n        from student\n        where ssex='女';\n        with check option;\n\n（18）将上一题建立的F_STU视图，更改为给所有男生记录定义的视图，属性包括学号、性别、年龄、所选课程号。\n\nalter view F_STU(sno,ssex,sage,cno)\n   as\n     select student.sno,ssex,sage,cno from student,sc\n     where student.sno=sc.sno and ssex='男'\n\n（19）在上一题的视图中找出选修了3号课程的学生。\n\nselect    F_STU.sno,sname,cno\nfrom      F_STU,sc\nwhere     F_STU.sno=sc.sno and\n          sc.cno='3';\n\n（20）删除视图F_STU\n\ndrop view F_STU;\n```\n","tags":["SQL上机实验"],"categories":["SQL"]},{"title":"JavaSE-Day(7)学习笔记","url":"/2020/05/26/JavaSE-Day(7)学习笔记/","content":"\n## 面向对象\n\n<!--more-->\n\n### 成员变量和局部变量的区别\n\n```javascript\n/*\n\t成员变量和局部变量的区别?\n\t\tA:在类中的位置不同\n\t\t\t成员变量：在类中方法外\n\t\t\t局部变量：在方法定义中或者方法声明上\n\t\tB:在内存中的位置不同\n\t\t\t成员变量：在堆内存\n\t\t\t局部变量：在栈内存\n\t\tC:生命周期不同\n\t\t\t成员变量：随着对象的创建而存在，随着对象的消失而消失\n\t\t\t局部变量：随着方法的调用而存在，随着方法的调用完毕而消失\n\t\tD:初始化值不同\n\t\t\t成员变量：有默认初始化值\n\t\t\t局部变量：没有默认初始化值，必须定义，赋值，然后才能使用。\n\t\t\t\n\t\t注意事项：\n\t\t\t局部变量名称可以和成员变量名称一样，在方法中使用的时候，采用的是就近原则。\n*/\nclass Varialbe {\n\t//成员变量\n\t//int num = 10;\n\tint num; //0\n\t\n\tpublic void show() {\n\t\t//int num2 = 20; //局部变量\n\t\t//可能尚未初始化变量num2\n\t\t//int num2; //没有默认值\n\t\tint num2 = 20;\n\t\tSystem.out.println(num2);\n\t\t\n\t\t//int num = 100;\n\t\tSystem.out.println(num);\n\t}\n}\n\n\nclass VariableDemo {\n\tpublic static void main(String[] args) {\n\t\tVarialbe v = new Varialbe();\n\t\t\n\t\tSystem.out.println(v.num); //访问成员变量\n\t\t\n\t\tv.show();\t\n\t\t\t\n\t}\n}\n```\n\n### 方法的形式参数是类名的时候如何调用\n\n```javascript\n/*\n\t形式参数的问题：\n\t\t基本类型：形式参数的改变不影响实际参数\n\t\t引用类型：形式参数的改变直接影响实际参数\n*/\n//形式参数是基本类型\nclass Demo {\n\tpublic int sum(int a,int b) {\n\t\treturn a + b;\n\t}\n}\n\n//形式参数是引用类型\nclass Student {\n\tpublic void show() {\n\t\tSystem.out.println(\"我爱学习\");\n\t}\n}\n\nclass StudentDemo {\n\t//如果你看到了一个方法的形式参数是一个类类型(引用类型)，这里其实需要的是该类的对象。\n\tpublic void method(Student s) { //调用的时候，把main方法中的s的地址传递到了这里 Student s = new Student();\n\t\ts.show();\n\t}\n}\n\nclass ArgsTest {\n\tpublic static void main(String[] args) {\n\t\t//形式参数是基本类型的调用\n\t\tDemo d = new Demo();\n\t\tint result = d.sum(10,20);\n\t\tSystem.out.println(\"result:\"+result);\n\t\tSystem.out.println(\"--------------\");\n\t\t\n\t\t//形式参数是引用类型的调用\n\t\t//需求：我要调用StudentDemo类中的method()方法\n\t\tStudentDemo sd = new StudentDemo();\n\t\t//创建学生对象\n\t\tStudent s = new Student();\n\t\tsd.method(s); //把s的地址给到了这里\n\t}\n}\n```\n\n### 匿名对象的概述和应用\n\n```javascript\n/*\n\t匿名对象：就是没有名字的对象。\n\t\n\t匿名对象的应用场景：\n\t\tA:调用方法，仅仅只调用一次的时候。\n\t\t\t注意：调用多次的时候，不适合。\n\t\t\t那么，这种匿名调用有什么好处吗?\n\t\t\t\t有，匿名对象调用完毕就是垃圾。可以被垃圾回收器回收。\n\t\tB:匿名对象可以作为实际参数传递\n*/\nclass Student {\n\tpublic void show() {\n\t\tSystem.out.println(\"我爱学习\");\n\t}\n}\n\nclass StudentDemo {\n\tpublic void method(Student s) {\n\t\ts.show();\n\t}\n}\n\nclass NoNameDemo {\n\tpublic static void main(String[] args) {\n\t\t//带名字的调用\n\t\tStudent s = new Student();\n\t\ts.show();\n\t\ts.show();\n\t\tSystem.out.println(\"--------------\");\n\t\t\n\t\t//匿名对象\n\t\t//new Student();\n\t\t//匿名对象调用方法\n\t\tnew Student().show();\n\t\tnew Student().show(); //这里其实是重新创建了一个新的对象\n\t\tSystem.out.println(\"--------------\");\n\t\t\n\t\t\n\t\t//匿名对象作为实际参数传递\n\t\tStudentDemo sd = new StudentDemo();\n\t\t//Student ss = new Student();\n\t\t//sd.method(ss); //这里的s是一个实际参数\n\t\t//匿名对象\n\t\tsd.method(new Student());\n\t\t\n\t\t//在来一个\n\t\tnew StudentDemo().method(new Student());\n \t}\n}\n```\n\n### 封装和private\n\n```javascript\n封装(理解)\n    (1)隐藏实现细节，提供公共的访问方式\n    (2)好处：\n        A:隐藏实现细节，提供公共的访问方式\n        B:提高代码的复用性\n        C:提高代码的安全性\n    (3)设计原则\n        把不想让外界知道的实现细节给隐藏起来，提供公共的访问方式\n    (4)private是封装的一种体现。\n        封装：类，方法，private修饰成员变量\n\nprivate关键字(掌握)\n    (1)私有的意义，可以修饰成员变量和成员方法\n    (2)特点：\n        被private修饰的后的成员只能在本类中被访问\n    (3)private的应用：\n        以后再写一个类的时候：\n            把所有的成员变量给private了\n            提供对应的getXxx()/setXxx()方法\n```\n\n### private的引出\n\n```javascript\n/*\n\t定义一个学生类：\n\t\t成员变量：name，age\n\t\t成员方法：show()方法\n\t\t\n\t我们在使用这个案例的过程中，发现了一个问题：\n\t\t通过对象去给成员变量赋值，可以赋值一些非法的数据。\n\t\t这是不合理的。\n\t\t应该是这个样子的：在赋值之前，先对数据进行判断。\n\t\t判断到底在哪里做比较合适呢?\n\t\tStudentDemo类是一个测试类，测试类一般只创建对象，调用方法。\t\n\t\t所以，这个判断应该定义在Student类中。\n\t\t而我们在成员变量的位置可不可以进行数据判断呢?\n\t\t是不可以的，因为做数据校验，必须要依靠一些逻辑语句。\n\t\t逻辑语句是应该定义在方法中的，所以，我们最终决定在Student类中提供一个方法\n\t\t来对数据进行校验。\n\t\n\t按照我们前面的分析，我们给出了一个方法进行校验。\n\t但是呢，它偏偏不调用方法来赋值，还是直接赋值了，\n\t这样我们的方法就没有起到作用。\n\t我就应该要求你必须使用我的方法，而不能直接调用成员变量赋值。\n\t怎么去强制要求不能直接使用成员变量呢?\n\t\t针对这种情况，Java就提供了一个关键字 private\n\t\t\n\tprivate:私有的。可以修饰成员变量和成员方法。\n\t\t注意：被private修饰的成员只能在本类中访问。\n\t\t\n\t其实我讲到现在讲解的是一个封装的思想。\n\t封装：是指隐藏对象的属性和实现细节，仅对外提供公共访问方式。\n*/\nclass Student {\n\t//姓名\n\tString name;\n\t//年龄\n\tprivate int age;\n\t\n\t//写一个方法对数据进行校验\n\t/*\n\t\t返回值类型：void\n\t\t参数列表：int a\n\t*/\n\tpublic void setAge(int a) {\n\t\tif(a < 0 || a > 120) {\n\t\t\tSystem.out.println(\"你给的年龄有问题\");\n\t\t}else {\n\t\t\tage = a;\n\t\t}\n\t}\n\t\n\t\n\t//show()方法,显示所有成员变量值\n\tpublic void show() {\n\t\tSystem.out.println(\"姓名：\"+name);\n\t\tSystem.out.println(\"年龄：\"+age);\n\t}\n}\n\nclass StudentDemo {\n\tpublic static void main(String[] args) {\n\t\t//创建学生对象\n\t\tStudent s = new Student();\n\t\ts.show();\n\t\tSystem.out.println(\"--------------\");\n\t\t\n\t\t//给成员变量赋值\n\t\ts.name = \"林青霞\";\n\t\t//s.age = 27;\n\t\ts.setAge(27);\n\t\ts.show();\n\t\tSystem.out.println(\"--------------\");\n\t\t\n\t\t//给age赋值\n\t\t//s.age = -27; //这个数据是不合理的\n\t\t//通过方法给值\n\t\ts.setAge(-27);\n\t\ts.show();\n\t\tSystem.out.println(\"--------------\");\n\t}\n}\n```\n\n### private关键字的概述和特点\n\n```javascript\n/*\n\tprivate:\n\t\t是一个权限修饰符\n\t\t可以修饰成员变量和成员方法\n\t\t被其修饰的成员只能在本类中被访问\n*/\nclass Demo {\n\t//int num = 10;\n\t//用private修饰\n\tprivate int num = 10;\n\t\n\tpublic void show() {\n\t\tSystem.out.println(num);\n\t}\n\t\n\tprivate void method() {\n\t\tSystem.out.println(\"method\");\n\t}\n\t\n\tpublic void function() {\n\t\tmethod();\n\t}\n}\n\nclass PrivateDemo {\n\tpublic static void main(String[] args) {\n\t\tDemo d = new Demo();\n\t\t//不能方法私有的成员变量\n\t\t//System.out.println(d.num);\n\t\td.show();\n\t\t//不能访问私有的成员方法\n\t\t//d.method();\n\t\td.function();\n\t}\n}\n```\n\n### private的应用标准案例\n\n```javascript\n/*\n\t封装和private的应用：\n\t\tA:把成员变量用private修饰\n\t\tB:提高对应的getXxx()和setXxx()方法\n*/\n//定义学生类\nclass Student {\n\t//姓名\n\tprivate String name;\n\t//年龄\n\tprivate int age;\n\t\n\t//姓名获取值\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\t\n\t//姓名设置值\n\tpublic void setName(String n) {\n\t\tname = n;\n\t}\n\t\n\t//年龄获取值\n\tpublic int getAge() {\n\t\treturn age;\n\t}\n\t\n\t//年龄赋值\n\tpublic void setAge(int a) {\n\t\tage = a;\n\t}\n}\n\n//测试类\nclass StudentTest {\n\tpublic static void main(String[] args) {\n\t\t//创建学生对象\n\t\tStudent s = new Student();\n\t\t\n\t\t//使用成员变量\n\t\t//错误：被私有修饰了，外界不能直接访问了\n\t\t//System.out.println(s.name+\"---\"+s.age);\n\t\tSystem.out.println(s.getName()+\"---\"+s.getAge());\n\t\t\n\t\t//给成员变量赋值\n\t\t//s.name = \"林青霞\";\n\t\t//s.age = 27;\n\t\t//通过方法给赋值\n\t\ts.setName(\"林青霞\");\n\t\ts.setAge(27);\n\t\tSystem.out.println(s.getName()+\"---\"+s.getAge());\n\t}\n}\n```\n\n### this关键字的概述和应用\n\n```javascript\n/*\n\t我们曾经曰：起名字要做到见名知意。\n\t\n\tthis:是当前类的对象引用。简单的记，它就代表当前类的一个对象。\n\t\n\t\t注意：谁调用这个方法，在该方法内部的this就代表谁。\n\t\t\n\tthis的场景：\n\t\t解决局部变量隐藏成员变量\n*/\n//定义学生类\nclass Student {\n\t//姓名\n\tprivate String name;\n\t//年龄\n\tprivate int age;\n\t\n\t//姓名获取值\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\t\n\t//姓名设置值\n\tpublic void setName(String name) { //name = \"林青霞\";\n\t\t//name = name; //变量的使用规则：就近原则\n\t\t//这里是类名，目前还没有说过类似的用法，所以这个是有问题的\n\t\t//这里的调用只能通过对象名\n\t\t//这个对象如果存在，它应该代表的是Student的一个对象。\n\t\t//那么，谁能够代表当前类的对象呢? java就提供了一个关键字 this\n\t\t//Student.name = name;\n\t\tthis.name = name;\n\t}\n\t\n\t//年龄获取值\n\tpublic int getAge() {\n\t\treturn age;\n\t}\n\t\n\t//年龄赋值\n\tpublic void setAge(int age) {\n\t\tthis.age = age;\n\t}\n}\n\n//测试类\nclass StudentTest {\n\tpublic static void main(String[] args) {\n\t\t//创建学生对象\n\t\tStudent s = new Student();\n\t\t\n\t\t//给成员变量赋值\n\t\ts.setName(\"林青霞\");\n\t\ts.setAge(27);\n\t\t//获取数据\n\t\tSystem.out.println(s.getName()+\"---\"+s.getAge());\n\t}\n}\n```\n\n```javascript\n/*\n\t标准的代码改进版\n\t\n\tthis:哪个对象调用那个方法，this就代表那个对象\n*/\nclass Student {\n\tprivate String name;\n\tprivate int age;\n\t\n\tpublic String getName() {\n\t\treturn name; //这里其实是隐含了this\n\t}\n\t\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\t\n\tpublic int getAge() {\n\t\treturn age;\n\t}\n\t\n\tpublic void setAge(int age) {\n\t\tthis.age = age;\n\t}\n}\n\nclass StudentTest2 {\n\tpublic static void main(String[] args) {\n\t\t//创建一个对象\n\t\tStudent s1 = new Student();\n\t\ts1.setName(\"林青霞\");\n\t\ts1.setAge(27);\n\t\tSystem.out.println(s1.getName()+\"---\"+s1.getAge());\n\t\t\n\t\t//创建第二个对象\n\t\tStudent s2 = new Student();\n\t\ts2.setName(\"刘意\");\n\t\ts2.setAge(30);\n\t\tSystem.out.println(s2.getName()+\"---\"+s2.getAge());\n\t}\n}\n```\n\n### this关键字的内存图解\n\n![tupian1](https://images2015.cnblogs.com/blog/1118847/201705/1118847-20170504162105445-1789978008.png)\n\n### 标准手机类代码及其测试\n\n```javascript\n/*\n\t作业：请把手机类写成一个标准类，然后创建对象测试功能。\n\t\n\t手机类：\n\t\t成员变量：\n\t\t\t品牌：String brand;\n\t\t\t价格：int price;\n\t\t\t颜色：String color;\n\t\t成员方法：\n\t\t\t针对每一个成员变量给出对应的getXxx()/setXxx()方法。\n\t\t最后定义测试：\n\t\t\t创建一个对象，先通过getXxx()方法输出成员变量的值。这一次的结果是：null---0---null\n\t\t\t然后通过setXxx()方法给成员变量赋值。再次输出结果。这一次的结果是：三星---2999---土豪金\n*/\nclass Phone {\n\t//品牌\n\tprivate String brand;\n\t//价格\n\tprivate int price;\n\t//颜色\n\tprivate String color;\n\t\n\t//getXxx()和setXxx()方法\n\tpublic String getBrand() {\n\t\treturn brand;\n\t}\n\t\n\tpublic void setBrand(String brand) {\n\t\tthis.brand = brand;\n\t}\n\t\n\tpublic int getPrice() {\n\t\treturn price;\n\t}\n\t\n\tpublic void setPrice(int price) {\n\t\tthis.price = price;\n\t}\n\t\n\tpublic String getColor() {\n\t\treturn color;\n\t}\n\t\n\tpublic void setColor(String color) {\n\t\tthis.color = color;\n\t}\n}\n\nclass PhoneTest {\n\tpublic static void main(String[] args) {\n\t\t//创建手机对象\n\t\tPhone p = new Phone();\n\t\t\n\t\t//直接输出默认值\n\t\tSystem.out.println(p.getBrand()+\"---\"+p.getPrice()+\"---\"+p.getColor());\n\t\t\n\t\t//给成员变量赋值\n\t\tp.setBrand(\"三星\");\n\t\tp.setPrice(2999);\n\t\tp.setColor(\"土豪金\");\n\t\t//再次输出\n\t\tSystem.out.println(p.getBrand()+\"---\"+p.getPrice()+\"---\"+p.getColor());\n\t}\n}\n```\n\n### 构造方法概述和格式\n\n```javascript\n/*\n\t构造方法：\n\t\t给对象的数据进行初始化\n\n\t格式：\n\t\tA:方法名与类名相同\n\t\tB:没有返回值类型，连void都没有\n\t\tC:没有具体的返回值\n*/\nclass Student {\n\tprivate String name; //null\n\tprivate int age; //0\n\t\n\tpublic Student() {\n\t\tSystem.out.println(\"这是构造方法\");\n\t}\n}\n\nclass ConstructDemo {\n\tpublic static void main(String[] args) {\n\t\t//创建对象\n\t\tStudent s = new Student();\n\t\tSystem.out.println(s); //Student@e5bbd6\n\t}\n}\n```\n\n### 构造方法的重载及注意事项\n\n```javascript\n/*\n\t我们一直在使用构造方法，但是，我们确没有定义构造方法，用的是哪里来的呢?\n\t\n\t构造方法的注意事项:\n\t\tA:如果我们没有给出构造方法，系统将自动提供一个无参构造方法。\n\t\tB:如果我们给出了构造方法，系统将不再提供默认的无参构造方法。\n\t\t\t注意：这个时候，如果我们还想使用无参构造方法，就必须自己给出。建议永远自己给出无参构造方法\n\t\t\n\t给成员变量赋值有两种方式：\n\t\tA:setXxx()\n\t\tB:构造方法\n*/\n\nclass Student {\n\tprivate String name;\n\tprivate int age;\n\n\tpublic Student() {\n\t\t//System.out.println(\"我给了，你还给不\");\n\t\tSystem.out.println(\"这是无参构造方法\");\n\t}\n\t\n\t//构造方法的重载格式\n\tpublic Student(String name) {\n\t\tSystem.out.println(\"这是带一个String类型的构造方法\");\n\t\tthis.name = name;\n\t}\n\t\n\tpublic Student(int age) {\n\t\tSystem.out.println(\"这是带一个int类型的构造方法\");\n\t\tthis.age = age;\n\t}\n\t\n\tpublic Student(String name,int age) {\n\t\tSystem.out.println(\"这是一个带多个参数的构造方法\");\n\t\tthis.name = name;\n\t\tthis.age = age;\n\t}\n\t\n\tpublic void show() {\n\t\tSystem.out.println(name+\"---\"+age);\n\t}\n}\n\nclass ConstructDemo2 {\n\tpublic static void main(String[] args) {\n\t\t//创建对象\n\t\tStudent s = new Student();\n\t\ts.show();\n\t\tSystem.out.println(\"-------------\");\n\t\t\n\t\t//创建对象2\n\t\tStudent s2 = new Student(\"林青霞\");\n\t\ts2.show();\n\t\tSystem.out.println(\"-------------\");\n\t\t\n\t\t//创建对象3\n\t\tStudent s3 = new Student(27);\n\t\ts3.show();\n\t\tSystem.out.println(\"-------------\");\n\t\t\n\t\t//创建对象4\n\t\tStudent s4 = new Student(\"林青霞\",27);\n\t\ts4.show();\n\t}\n}\n```\n\n### 成员方法的分类及使用\n\n```javascript\n/*\n    类的组成：成员变量，成员方法\n    今天我们又加入了一个新的成员：构造方法。\n    以后再提类的组成：\n        1、成员变量\n        2、构造方法\n        3、成员方法\n            根据返回值：\n                void类型\n                非void类型\n            形式参数：\n                空参方法\n                非空参方法\n*/\nclass Student {\n    public String getString() {\n        return \"helloworld\";\n    }\n\n    public void show() {\n        System.out.println(\"show\");\n    }\n    \n    public void method(String name) {\n        System.out.println(name);\n    }\n    \n    public String function(String s1,String s2) {\n        return s1+s2;\n    }\n}\n\nclass StudentDemo {\n    public static void main(String[] args) {\n        //创建对象\n        Student s = new Student();\n        \n        //调用无参无返回值方法\n        s.show();\n        \n        //调用无参有返回值方法\n        String result = s.getString();\n        System.out.println(result);\n        \n        //调用带参无返回值的方法\n        s.method(\"林青霞\");\n        \n        //调用带参带返回值的方法\n        String result2 = s.function(\"hello\",\"world\");\n        System.out.println(result2);\n    }\n}\n```\n\n### 一个标准学生类的代码及测试\n\n```javascript\n/*\n\t一个标准代码的最终版。\n\t\n\t学生类：\n\t\t成员变量：\n\t\t\tname，age\n\t\t构造方法：\n\t\t\t无参，带两个参\n\t\t成员方法：\n\t\t\tgetXxx()/setXxx()\n\t\t\tshow()：输出该类的所有成员变量值\n\t\t\t\n\t给成员变量赋值：\n\t\tA:setXxx()方法\n\t\tB:构造方法\n\t\t\n\t输出成员变量值的方式：\n\t\tA:通过getXxx()分别获取然后拼接\n\t\tB:通过调用show()方法搞定\n*/\nclass Student {\n\t//姓名\n\tprivate String name;\n\t//年龄\n\tprivate int age;\n\t\n\t//构造方法\n\tpublic Student() {\n\t}\n\t\n\tpublic Student(String name,int age) {\n\t\tthis.name = name;\n\t\tthis.age = age;\n\t}\n\t\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\t\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\t\n\tpublic int getAge() {\n\t\treturn age;\n\t}\n\t\n\tpublic void setAge(int age) {\n\t\tthis.age = age;\n\t}\n\t\n\t//输出所有的成员变量值\n\tpublic void show() {\n\t\tSystem.out.println(name+\"---\"+age);\n\t}\n}\n\n//测试类\nclass StudentTest {\n\tpublic static void main(String[] args) {\n\t\t//方式1给成员变量赋值\n\t\t//无参构造+setXxx()\n\t\tStudent s1 = new Student();\n\t\ts1.setName(\"林青霞\");\n\t\ts1.setAge(27);\n\t\t//输出值\n\t\tSystem.out.println(s1.getName()+\"---\"+s1.getAge());\n\t\ts1.show();\n\t\tSystem.out.println(\"----------------------------\");\n\t\t\n\t\t//方式2给成员变量赋值\n\t\tStudent s2 = new Student(\"刘意\",30);\n\t\tSystem.out.println(s2.getName()+\"---\"+s2.getAge());\n\t\ts2.show();\n\t}\n}\n```\n\n### 一个标准手机类的代码及测试\n\n```javascript\n/*\n\t标准的手机类练习\n\t\n\t手机类：\n\t\t成员变量：brand,price,color\n\t\t构造方法：无参构造\n\t\t成员方法：getXxx()/setXxx()\n*/\n//定义手机类\nclass Phone {\n\t//品牌\n\tprivate String brand;\n\t//价格\n\tprivate int price;\n\t//颜色\n\tprivate String color;\n\t\n\t//无参构造方法\n\tpublic Phone() {}\n\t\n\t//getXxx()和setXxx()方法\n\tpublic String getBrand() {\n\t\treturn brand;\n\t}\n\t\n\tpublic void setBrand(String brand) {\n\t\tthis.brand = brand;\n\t}\n\t\n\tpublic int getPrice() {\n\t\treturn price;\n\t}\n\t\n\tpublic void setPrice(int price) {\n\t\tthis.price = price;\n\t}\n\t\n\tpublic String getColor() {\n\t\treturn color;\n\t}\n\t\n\tpublic void setColor(String color) {\n\t\tthis.color = color;\n\t} \n}\n\n//手机测试类\nclass PhoneTest {\n\tpublic static void main(String[] args) {\n\t\t//创建对象\n\t\tPhone p = new Phone();\n\t\t\n\t\t//给成员变量赋值\n\t\tp.setBrand(\"诺基亚\");\n\t\tp.setPrice(199);\n\t\tp.setColor(\"土豪金\");\n\t\t\n\t\t//获取值\n\t\tSystem.out.println(p.getBrand()+\"---\"+p.getPrice()+\"---\"+p.getColor());\n\t}\n}\n```\n\n### 创建对象做了哪些事情\n\n```javascript\n(1)把Student.class文件加载到内存\n    (2)在栈内存为s开辟空间\n    (3)在堆内存为学生对象申请空间\n    (4)给学生的成员变量进行默认初始化。null,0\n    (5)给学生的成员变量进行显示初始化。林青霞,27\n    (6)通过构造方法给成员变量进行初始化。刘意,30\n    (7)对象构造完毕，把地址赋值给s变量\n```\n\n![tupian111](https://images2015.cnblogs.com/blog/1118847/201705/1118847-20170504201143023-1077701906.png)\n\n### 什么时候定义成员变量\n\n```javascript\n/*\n\t定义一个类Demo,其中定义一个求两个数据和的方法，\n\t定义一个测试了Test，进行测试。\n\t\n\t变量什么时候定义为成员变量：\n\t\t如果这个变量是用来描述这个类的信息的，那么，该变量就应该定义为成员变量。\n\t\t\n\t变量到底定义在哪里好呢?\n\t\t变量的范围是越小越好。因为能及时的被回收。\n*/\n\n//方式1\n/*\nclass Demo {\n\tpublic int sum() {\n\t\tint a = 10;\n\t\tint b = 20;\n\t\tint c = a + b;\n\t\treturn c;\n\t}\n}\n*/\n//方式1满足了我们的要求，但是不好。\n//因为参与操作的数据现在是固定的。\n\n//方式2\n/*\nclass Demo {\n\tpublic int sum(int a,int b) {\n\t\treturn a + b;\n\t}\n}\n*/\n\n//方式2可以满足我们的要求，但是呢我们学习过来面向对象的思想。\n//我就再想，a，b可不可以定义为成员变量呢?\n//如果可以，我们再改进一版\nclass Demo {\n\tint a;\n\tint b;\n\t\n\tpublic int sum() {\n\t\treturn a + b;\n\t}\n}\n//虽然这种方式可以，并且好像是符合了面向对象的思想。\n//但是不好。\n//因为我们曾经说过：类是一组相关的属性和行为的集合。\n//并且类是通过事物转换过来的\n//而类中的成员变量就是事物的属性\n//属性是用来描述事物的\n//同理：成员变量其实是用来描述类的。\n\n//测试类\nclass Test {\n\tpublic static void main(String[] args) {\n\t\t//创建对象\n\t\t//方式1测试\n\t\t/*\n\t\tDemo d = new Demo();\n\t\tSystem.out.println(d.sum());\n\t\t*/\n\t\t\n\t\t//方式2测试\n\t\t/*\n\t\tDemo d = new Demo();\n\t\tint a = 10;\n\t\tint b = 20;\n\t\tSystem.out.println(d.sum(a,b));\n\t\t*/\n\t\t\n\t\t//方式3测试\n\t\tDemo d = new Demo();\n\t\td.a = 10;\n\t\td.b = 20;\n\t\tSystem.out.println(d.sum());\n\t}\n}\n```\n\n### 长方形案例练习\n\n```javascript\n/*\n\t定义一个长方形类,定义 求周长和面积的方法，\n\t然后定义一个测试了Test2，进行测试。\n\n\t长方形的类：\n\t\t成员变量：\n\t\t\t长，宽\n\t\t成员方法：\n\t\t\t求周长：(长+宽)*2;\n\t\t\t求面积：长*宽\n\t\t\t\n\t注意：\n\t\timport必须出现在所有的class前面。\n*/\n\nimport java.util.Scanner;\n\nclass ChangFangXing {\n\t//长方形的长\n\tprivate int length;\n\t//长方形的宽\n\tprivate int width;\n\t\n\tpublic ChangFangXing(){}\n\t\n\t//仅仅提供setXxx()即可\n\tpublic void setLength(int length) {\n\t\tthis.length = length;\n\t}\n\t\n\tpublic void setWidth(int width) {\n\t\tthis.width = width;\n\t}\n\t\n\t//求周长\n\tpublic int getZhouChang() {\n\t\treturn (length + width) * 2;\n\t}\n\t\n\t//求面积\n\tpublic int getArea() {\n\t\treturn length * width;\n\t}\n}\n\nclass Test2 {\n\tpublic static void main(String[] args) {\n\t\t//创建键盘录入对象\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tSystem.out.println(\"请输入长方形的长：\");\n\t\tint length = sc.nextInt();\n\t\tSystem.out.println(\"请输入长方形的宽：\");\n\t\tint width = sc.nextInt();\n\t\t\n\t\t//创建对象\n\t\tChangFangXing cfx = new ChangFangXing();\n\t\t//先给成员变量赋值\n\t\tcfx.setLength(length);\n\t\tcfx.setWidth(width);\n\t\t\n\t\tSystem.out.println(\"周长是：\"+cfx.getZhouChang());\n\t\tSystem.out.println(\"面积是：\"+cfx.getArea());\n\t}\n}\n```\n\n### 员工类案例练习\n\n```javascript\n/*\n\t需求：\n\t\t定义一个员工类,自己分析出几个成员，\n\t\t然后给出成员变量，构造方法，getXxx()/setXxx()方法，\n\t\t以及一个显示所有成员信息的方法。并测试。\n\n\t分析：\n\t\t员工\n\t\t\t成员变量：\n\t\t\t\t员工编号，姓名，年龄\n\t\t\t构造方法：\n\t\t\t\t无参构造方法\n\t\t\t成员方法：\n\t\t\t\tgetXxx()/setXxx()\n\t\t\t\tshow();\n*/\nclass Employee {\n\t//员工编号\n\tprivate String employeeId;\n\t//姓名\n\tprivate String name;\n\t//年龄\n\tprivate int age;\n\t\n\t//构造方法\n\tpublic Employee() {}\n\t\n\t//getXxx()/setXxx()\n\tpublic String getEmployeeId() {\n\t\treturn employeeId;\n\t}\n\t\n\tpublic void setEmployeeId(String employeeId) {\n\t\tthis.employeeId = employeeId;\n\t}\n\t\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\t\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\t\n\tpublic int getAge() {\n\t\treturn age;\n\t}\n\t\n\tpublic void setAge(int age) {\n\t\tthis.age = age;\n\t}\n\t\n\t//显示所有成员信息的方法\n\tpublic void show() {\n\t\tSystem.out.println(\"员工编号是：\"+employeeId+\"的这个人是：\"+name+\"的年龄是：\"+age);\n\t}\n}\n\nclass EmployeeTest {\n\tpublic static void main(String[] args) {\n\t\t//创建对象\n\t\tEmployee e = new Employee();\n\t\t\n\t\t//给成员变量赋值\n\t\te.setEmployeeId(\"czbk9527\");\n\t\te.setName(\"唐伯虎\");\n\t\te.setAge(18);\n\t\t\n\t\t//获取数据\n\t\t//System.out.println(e.getEmployeeId()+\"---\"+e.getName()+\"---\"+e.getAge());\n\t\n\t\t//我们在Employee类中定义了一个show方法。所以，我们改进一下，使用show方法\n\t\te.show();\n\t}\n}\n```\n\n### 自己实现加减乘除并测试\n\n```javascript\n/*\n\t定义一个类MyMath,提供基本的加减乘除功能，然后进行测试。\n*/\nimport java.util.Scanner;\n\nclass MyMath {\n\t//加法功能\n\tpublic int add(int a,int b) {\n\t\treturn a + b;\n\t}\n\t\n\t//减法功能\n\tpublic int sub(int a,int b) {\n\t\treturn a - b;\n\t}\n\t\n\t//乘法功能\n\tpublic int mul(int a,int b){\n\t\treturn a * b;\n\t}\n\t\n\t//除法功能\n\tpublic int div(int a,int b) {\n\t\treturn a / b;\n\t}\n}\n\n//测试类\nclass MyMathTest {\n\tpublic static void main(String[] args) {\n\t\t//创建键盘录入对象\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tSystem.out.println(\"请输入第一个操作数：\");\n\t\tint firstNumber = sc.nextInt();\n\t\tSystem.out.println(\"请输入第二个操作数：\");\n\t\tint secondNumber = sc.nextInt();\n\t\t\n\t\t//创建MyMath对象，并使用\n\t\tMyMath mm = new MyMath();\n\t\t\n\t\tSystem.out.println(\"加法结果：\"+mm.add(firstNumber,secondNumber));\n\t\tSystem.out.println(\"减法结果：\"+mm.sub(firstNumber,secondNumber));\n\t\tSystem.out.println(\"乘法结果：\"+mm.mul(firstNumber,secondNumber));\n\t\tSystem.out.println(\"除法结果：\"+mm.div(firstNumber,secondNumber));\n\t}\n}\n```\n\n### static关键字的引入\n\n```javascript\nstatic关键字(理解)\n    (1)静态的意思。可以修饰成员变量和成员方法。\n    (2)静态的特点：\n        A:随着类的加载而加载\n        B:优先与对象存在\n        C:被类的所有对象共享\n            这其实也是我们判断该不该使用静态的依据。\n            举例：饮水机和水杯的问题思考\n        D:可以通过类名调用\n            既可以通过对象名调用，也可以通过类名调用，建议通过类名调用。\n    (3)静态的内存图\n        静态的内容在方法区的静态区\n    (4)静态的注意事项；\n        A:在静态方法中没有this对象\n        B:静态只能访问静态(代码测试过)\n    (5)静态变量和成员变量的区别\n        A:所属不同\n            静态变量：属于类，类变量\n            成员变量：属于对象，对象变量，实例变量\n        B:内存位置不同\n            静态变量：方法区的静态区\n            成员变量：堆内存\n        C:生命周期不同\n            静态变量：静态变量是随着类的加载而加载，随着类的消失而消失\n            成员变量：成员变量是随着对象的创建而存在，随着对象的消失而消失\n        D:调用不同\n            静态变量：可以通过对象名调用，也可以通过类名调用\n            成员变量：只能通过对象名调用\n    (6)main方法是静态的\n        public:权限最大\n        static:不用创建对象调用\n        void:返回值给jvm没有意义\n        main:就是一个常见的名称。\n        String[] args:可以接收数据，提供程序的灵活性\n            格式：java MainDemo hello world java\n                  java MainDemo 10 20 30\n\n```\n\n```javascript\n/*\n\t定义一个人类\n\t\n\t姓名和年龄都是变化的，这个我能接收，因为每个人的姓名和年龄是不同的。\n\t但是，我们现在选取的几个人都是中国人，他们的国籍是一样的。\n\t一样的国籍，我每次创建对象，在堆内存都要开辟这样的空间，\n\t我就觉得有点浪费了。怎么办呢? \n\t\t针对多个对象有共同的这样的成员变量值的时候，\n\t\tJava就提高了一个关键字来修饰：static。\n*/\nclass Person {\n\t//姓名\n\tString name;\n\t//年龄\n\tint age;\n\t//国籍\n\t//String country;\n\tstatic String country;\n\t\n\tpublic Person(){}\n\t\n\tpublic Person(String name,int age) {\n\t\tthis.name = name;\n\t\tthis.age = age;\n\t}\n\t\n\tpublic Person(String name,int age,String country) {\n\t\tthis.name = name;\n\t\tthis.age = age;\n\t\tthis.country = country;\n\t}\n\t\n\tpublic void show() {\n\t\tSystem.out.println(\"姓名：\"+name+\",年龄：\"+age+\",国籍：\"+country);\n\t}\n}\n\nclass PersonDemo {\n\tpublic static void main(String[] args) {\n\t\t//创建对象1\n\t\tPerson p1 = new Person(\"邓丽君\",16,\"中国\");\n\t\tp1.show();\n\t\t\n\t\t//创建对象2\n\t\t//Person p2 = new Person(\"杨幂\",22,\"中国\");\n\t\t//p2.show();\n\t\tPerson p2 = new Person(\"杨幂\",22);\n\t\tp2.show();\n\t\t\n\t\t//创建对象3\n\t\t//Person p3 = new Person(\"凤姐\",20,\"中国\");\n\t\t//p3.show();\n\t\tPerson p3 = new Person(\"凤姐\",20);\n\t\tp3.show();\n\t\t\n\t\tp3.country = \"美国\";\n\t\tp3.show();\n\t\t\n\t\tp1.show();\n\t\tp2.show();\n\t}\n}\n```\n\n### static关键字的特点\n\n```javascript\n/*\n\tstatic的特点：(它可以修饰成员变量，还可以修饰成员方法)\n\t\tA:随着类的加载而加载\n\t\t\t回想main方法。\n\t\tB:优先于对象存在\n\t\tC:被类的所有对象共享\n\t\t\t举例：咱们班级的学生应该共用同一个班级编号。\n\t\t\t其实这个特点也是在告诉我们什么时候使用静态?\n\t\t\t\t如果某个成员变量是被所有对象共享的，那么它就应该定义为静态的。\n\t\t\t举例：\n\t\t\t\t饮水机(用静态修饰)\n\t\t\t\t水杯(不能用静态修饰)\n\t\tD:可以通过类名调用\n\t\t\t其实它本身也可以通过对象名调用。\n\t\t\t推荐使用类名调用。\n\t\t\t\n\t\t\t静态修饰的内容一般我们称其为：与类相关的，类成员\n*/\nclass Student {\n\t//非静态变量\n\tint num = 10;\n\t\n\t//静态变量\n\tstatic int num2 = 20;\n}\n\nclass StudentDemo {\n\tpublic static void main(String[] args) {\n\t\tStudent s = new Student();\n\t\tSystem.out.println(s.num);\n\t\t\n\t\tSystem.out.println(Student.num2);\n\t\tSystem.out.println(s.num2);\n\t}\n}\n```\n\n### static关键字的内存图解\n\n![tupian2222](https://images2015.cnblogs.com/blog/1118847/201705/1118847-20170504220820429-1391271611.png)\n\n### static关键字的注意事项\n\n```javascript\n/*\n\tstatic关键字注意事项\n\t\tA:在静态方法中是没有this关键字的\n\t\t\t如何理解呢?\n\t\t\t\t静态是随着类的加载而加载，this是随着对象的创建而存在。\n\t\t\t\t静态比对象先存在。\n\t\tB:静态方法只能访问静态的成员变量和静态的成员方法\n\t\t\t\t静态方法：\n\t\t\t\t\t成员变量：只能访问静态变量\n\t\t\t\t\t成员方法：只能访问静态成员方法\n\t\t\t\t非静态方法：\n\t\t\t\t\t成员变量：可以是静态的，也可以是非静态的\n\t\t\t\t\t成员方法：可是是静态的成员方法，也可以是非静态的成员方法。\n\t\t\t简单记：\n\t\t\t\t静态只能访问静态。\n*/\nclass Teacher {\n\tpublic int num = 10;\n\tpublic static int num2 = 20;\n\t\n\tpublic void show() {\n\t\tSystem.out.println(num); //隐含的告诉你访问的是成员变量\n\t\tSystem.out.println(this.num); //明确的告诉你访问的是成员变量\n\t\tSystem.out.println(num2);\n\t\t\n\t\t//function();\n\t\t//function2();\n\t}\n\t\n\tpublic static void method() {\n\t\t//无法从静态上下文中引用非静态 变量 num\n\t\t//System.out.println(num);\n\t\tSystem.out.println(num2);\n\t\t\n\t\t//无法从静态上下文中引用非静态 方法 function()\n\t\t//function();\n\t\tfunction2();\n\t}\n\t\n\tpublic void function() {\n\t\n\t}\n\t\n\tpublic static void function2() {\n\t\n\t}\n}\n\nclass TeacherDemo {\n\tpublic static void main(String[] args) {\n\t\t//创建对象\n\t\tTeacher t = new Teacher();\n\t\tt.show();\n\t\tSystem.out.println(\"------------\");\n\t\tt.method();\n\t}\n}\n```\n\n### main方法的格式详解\n\n```javascript\n/*\n\tmain方法的格式讲解：\n\t\tpublic static void main(String[] args) {...}\n\t\t\n\t\tpublic:公共的，访问权限是最大的。由于main方法是被jvm调用，所以权限要够大。\n\t\tstatic:静态的，不需要创建对象，通过类名就可以。方便jvm的调用。\n\t\tvoid:因为我们曾经说过，方法的返回值是返回给调用者，而main方法是被jvm调用。你返回内容给jvm没有意义。\n\t\tmain:是一个常见的方法入口。我见过的语言都是以main作为入口。\n\t\tString[] args:这是一个字符串数组。值去哪里了?\n\t\t\t这个东西到底有什么用啊?怎么给值啊?\n\t\t\t\t这个东西早期是为了接收键盘录入的数据的。\n\t\t\t\t格式是：\n\t\t\t\t\tjava MainDemo hello world java\n*/\nclass MainDemo {\n\tpublic static void main(String[] args) {\n\t\t//System.out.println(args); //[Ljava.lang.String;@175078b\n\t\t//System.out.println(args.length); //0\n\t\t//System.out.println(args[0]); //ArrayIndexOutOfBoundsException\n\t\t\n\t\t//接收数据后\n\t\tSystem.out.println(args); \n\t\tSystem.out.println(args.length); \n\t\t//System.out.println(args[0]); \n\t\tfor(int x=0; x<args.length; x++) {\n\t\t\tSystem.out.println(args[x]);\n\t\t}\n\t}\n}\n```\n\n","tags":["Java系统学习"],"categories":["Java系统学习-JavaSE篇"]},{"title":"JavaSE-Day(6)学习笔记","url":"/2020/05/25/JavaSE-Day(6)学习笔记/","content":"\n## Java语言基础\n\n<!--more-->\n\n### 二维数组概述和格式1的讲解\n\n```javascript\n/*\n\t二维数组：就是元素为一维数组的一个数组。\n\t\n\t格式1：\n\t\t数据类型[][] 数组名 = new 数据类型[m][n];\n\t\t\n\t\tm:表示这个二维数组有多少个一维数组。\n\t\tn:表示每一个一维数组的元素有多少个。\n\t\t\n\t注意：\n\t\tA:以下格式也可以表示二维数组\n\t\t\ta:数据类型 数组名[][] = new 数据类型[m][n];\n\t\t\tb:数据类型[] 数组名[] = new 数据类型[m][n];\n\t\tB:注意下面定义的区别\n\t\t\tint x;\n\t\t\tint y;\n\t\t\tint x,y;\n\t\t\t\n\t\t\tint[] x;\n\t\t\tint[] y[];\n\t\t\t\n\t\t\tint[] x,y[];\n*/\nclass Array2Demo {\n\tpublic static void main(String[] args) {\n\t\t //定义一个二维数组\n\t\t int[][] arr = new int[3][2];\n\t\t //定义了一个二维数组arr\n\t\t //这个二维数组有3个一维数组的元素\n\t\t //每一个一维数组有2个元素\n\t\t //输出二维数组名称\n\t\t System.out.println(arr); //地址值\t[[I@175078b\n\t\t //输出二维数组的第一个元素一维数组的名称\n\t\t System.out.println(arr[0]); //地址值\t[I@42552c\n\t\t System.out.println(arr[1]); //地址值\t[I@e5bbd6\n\t\t System.out.println(arr[2]); //地址值\t[I@8ee016\n\t\t //输出二维数组的元素\n\t\t System.out.println(arr[0][0]); //0\n\t\t System.out.println(arr[0][1]); //0\n\t}\n}\n```\n\n### 二维数组格式1的内存图解\n\n![tupian1](https://images2015.cnblogs.com/blog/1118847/201705/1118847-20170504094130648-1700902522.png)\n\n### 二维数组格式2的讲解\n\n```javascript\n/*\n\t格式2：\n\t\t数据类型[][] 数组名 = new 数据类型[m][];\n\t\t\n\t\tm:表示这个二维数组有多少个一维数组。\n\t\t列数没有给出，可以动态的给。这一次是一个变化的列数。\n*/\nclass Array2Demo2 {\n\tpublic static void main(String[] args) {\n\t\t//定义数组\n\t\tint[][] arr = new int[3][];\n\t\t\n\t\tSystem.out.println(arr);\t//[[I@175078b\n\t\tSystem.out.println(arr[0]); //null\n\t\tSystem.out.println(arr[1]); //null\n\t\tSystem.out.println(arr[2]); //null\n\t\t\n\t\t//动态的为每一个一维数组分配空间\n\t\tarr[0] = new int[2];\n\t\tarr[1] = new int[3];\n\t\tarr[2] = new int[1];\n\t\t\n\t\tSystem.out.println(arr[0]); //[I@42552c\n\t\tSystem.out.println(arr[1]); //[I@e5bbd6\n\t\tSystem.out.println(arr[2]); //[I@8ee016\n\t\t\n\t\tSystem.out.println(arr[0][0]); //0\n\t\tSystem.out.println(arr[0][1]); //0\n\t\t//ArrayIndexOutOfBoundsException\n\t\t//System.out.println(arr[0][2]); //错误\n\t\t\n\t\tarr[1][0] = 100;\n\t\tarr[1][2] = 200;\n\t}\n}\n```\n\n### 二维数组格式2的内存图解\n\n![tupian2](https://images2015.cnblogs.com/blog/1118847/201705/1118847-20170504095839695-689195995.png)\n\n### 二维数组格式3的讲解\n\n```javascript\n/*\n\t格式3：\n\t\t基本格式：\n\t\t\t数据类型[][] 数组名 = new 数据类型[][]{{元素1,元素2...},{元素1,元素2...},{元素1,元素2...}};\n\t\t简化版格式：\n\t\t\t数据类型[][] 数组名 = {{元素1,元素2...},{元素1,元素2...},{元素1,元素2...}};\n\t\t\t\n\t\t举例：\n\t\t\tint[][] arr = {{1,2,3},{4,5,6},{7,8,9}};\n\t\t\tint[][] arr = {{1,2,3},{4,5},{6}};\n*/\nclass Array2Demo3 {\n\tpublic static void main(String[] args) {\n\t\t//定义数组\n\t\tint[][] arr = {{1,2,3},{4,5},{6}};\n\t\t\n\t\tSystem.out.println(arr);\n\t\tSystem.out.println(arr[0]);\n\t\tSystem.out.println(arr[1]);\n\t\tSystem.out.println(arr[2]);\n\t\t\n\t\tSystem.out.println(arr[0][0]); //1\n\t\tSystem.out.println(arr[1][0]); //4\n\t\tSystem.out.println(arr[2][0]); //6\n\t\t\n\t\tSystem.out.println(arr[0][1]); //2\n\t\tSystem.out.println(arr[1][1]); //5\n\t\t//越界\n\t\tSystem.out.println(arr[2][1]); //错误\n\t}\n}\n```\n\n### 二维数组格式3的内存图解\n\n![tupian4](https://images2015.cnblogs.com/blog/1118847/201705/1118847-20170504100615382-311370368.png)\n\n### 二维数组练习1遍历\n\n```javascript\n/*\n\t需求：二维数组遍历\n\t\n\t外循环控制的是二维数组的长度，其实就是一维数组的个数。\n\t内循环控制的是一维数组的长度。\n*/\nclass Array2Test {\n\tpublic static void main(String[] args) {\n\t\t//定义一个二维数组\n\t\tint[][] arr = {{1,2,3},{4,5,6},{7,8,9}};\n\t\t\n\t\t//请问谁代表{1,2,3}\n\t\t//arr[0]就是第一个数组\n\t\t//arr[0] = {1,2,3};\n\t\tfor(int x=0; x<arr[0].length; x++) {\n\t\t\tSystem.out.println(arr[0][x]);\n\t\t}\n\t\tSystem.out.println(\"--------------\");\n\t\t\n\t\tfor(int x=0; x<arr[1].length; x++) {\n\t\t\tSystem.out.println(arr[1][x]);\n\t\t}\n\t\tSystem.out.println(\"--------------\");\n\t\t\n\t\tfor(int x=0; x<arr[2].length; x++) {\n\t\t\tSystem.out.println(arr[2][x]);\n\t\t}\n\t\tSystem.out.println(\"--------------\");\n\t\t\n\t\t//用循环改进\n\t\tfor(int x=0; x<3; x++) {\n\t\t\tfor(int y=0; y<arr[x].length; y++) {\n\t\t\t\tSystem.out.print(arr[x][y]+\" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println(\"--------------\");\n\t\t\n\t\t//这个时候，注意了，3是我们根据上面的代码得出来的\n\t\t//但是，它不能针对任何的数组都可以这样\n\t\t//所以，我们应该想办法改进\n\t\t//其实，外面的这个循环的长度就是二维数组的长度\n\t\t\n\t\tfor(int x=0; x<arr.length; x++) {\n\t\t\tfor(int y=0; y<arr[x].length; y++) {\n\t\t\t\tSystem.out.print(arr[x][y]+\" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println(\"--------------\");\n\t\t\n\t\t//用方法改进\n\t\t//调用方法\n\t\tprintArray2(arr);\n\t\tSystem.out.println(\"--------------\");\n\t\t\n\t\t//我们再来一个列数是变化的\n\t\tint[][] arr2 = {{1,2,3},{4,5},{6}};\n\t\tprintArray2(arr2);\n\t}\n\t\n\t/*\n\t\t需求：遍历二维数组\n\t\t两个明确：\n\t\t\t返回值类型：void\n\t\t\t参数列表：int[][] arr\n\t*/\n\tpublic static void printArray2(int[][] arr) {\n\t\tfor(int x=0; x<arr.length; x++) {\n\t\t\tfor(int y=0; y<arr[x].length; y++) {\n\t\t\t\tSystem.out.print(arr[x][y]+\" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}\n```\n\n### 二维数组练习2求和\n\n```javascript\n/*\n\t公司年销售额求和\n\t某公司按照季度和月份统计的数据如下：单位(万元)\n\t第一季度：22,66,44\n\t第二季度：77,33,88\n\t第三季度：25,45,65\n\t第四季度：11,66,99\n\t\n\t分析：\n\t\tA:把题目的数据用二维数组来表示\n\t\t\tint[][] arr = {{22,66,44},{77,33,88},{25,45,65},{11,66,99}};\n\t\tB:如何求和呢?\n\t\t\t求和其实就是获取到每一个元素，然后累加即可。\n\t\tC:定义一个求和变量sum，初始化值是0。\n\t\tD:通过遍历就可以得到每一个二维数组的元素。\n\t\tE:把元素累加即可。\n\t\tF:最后输出sum，就是结果。\n*/\nclass Array2Test2 {\n\tpublic static void main(String[] args) {\n\t\t//把题目的数据用二维数组来表示\n\t\tint[][] arr = {{22,66,44},{77,33,88},{25,45,65},{11,66,99}};\n\t\t\n\t\t//定义一个求和变量sum，初始化值是0。\n\t\tint sum = 0;\n\t\t\n\t\t//通过遍历就可以得到每一个二维数组的元素。\n\t\tfor(int x=0; x<arr.length; x++) {\n\t\t\tfor(int y=0; y<arr[x].length; y++) {\n\t\t\t\t//把元素累加即可。\n\t\t\t\tsum += arr[x][y];\n\t\t\t}\n\t\t}\n\t\t\n\t\t//最后输出sum，就是结果。\n\t\tSystem.out.println(\"一年的销售额为：\"+sum+\"万元\");\n\t}\n}\n```\n\n### 二维数组练习3杨辉三角\n\n```javascript\n/*\n\n\t需求：打印杨辉三角形(行数可以键盘录入)\n\t\n\t1\n\t1 1\t\n\t1 2 1\n\t1 3 3 1\n\t1 4 6 4 1 \n\t1 5 10 10 5 1\n\n\t分析：看这种图像的规律\n\t\tA:任何一行的第一列和最后一列都是1\n\t\tB:从第三行开始，每一个数据是它上一行的前一列和它上一行的本列之和。\n\t\n\t步骤：\n\t\tA:首先定义一个二维数组。行数如果是n，我们把列数也先定义为n。\n\t\t  这个n的数据来自于键盘录入。\n\t\tB:给这个二维数组任何一行的第一列和最后一列赋值为1\n\t\tC:按照规律给其他元素赋值\n\t\t\t从第三行开始，每一个数据是它上一行的前一列和它上一行的本列之和。\n\t\tD:遍历这个二维数组。\n*/\nimport java.util.Scanner;\n\nclass Array2Test3 {\n\tpublic static void main(String[] args) {\n\t\t//创建键盘录入对象\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\t//这个n的数据来自于键盘录入。\n\t\tSystem.out.println(\"请输入一个数据：\");\n\t\tint n = sc.nextInt();\n\t\t\n\t\t//定义二维数组\n\t\tint[][] arr = new int[n][n];\n\t\t\n\t\t//给这个二维数组任何一行的第一列和最后一列赋值为1\n\t\tfor(int x=0; x<arr.length; x++) {\n\t\t\tarr[x][0] = 1; //任何一行第1列\n\t\t\tarr[x][x] = 1; //任何一行的最后1列\n\t\t}\n\t\t\n\t\t//按照规律给其他元素赋值\n\t\t//从第三行开始，每一个数据是它上一行的前一列和它上一行的本列之和。\n\t\tfor(int x=2; x<arr.length; x++) {\n\t\t\t//这里如果y<=x是有个小问题的，就是最后一列的问题\n\t\t\t//所以这里要减去1\n\t\t\t//并且y也应该从1开始，因为第一列也是有值了\n\t\t\tfor(int y=1; y<=x-1; y++) {\n\t\t\t\t//每一个数据是它上一行的前一列和它上一行的本列之和。\n\t\t\t\tarr[x][y] = arr[x-1][y-1] + arr[x-1][y];\n\t\t\t}\n\t\t}\n\t\t\n\t\t//遍历这个二维数组。\n\t\t/*\n\t\tfor(int x=0; x<arr.length; x++) {\n\t\t\tfor(int y=0; y<arr[x].length; y++) {\n\t\t\t\tSystem.out.print(arr[x][y]+\"\\t\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\t*/\n\t\t//这个时候，要注意了，内循环的变化必须和曾经讲过的九九乘法表类似\n\t\tfor(int x=0; x<arr.length; x++) {\n\t\t\tfor(int y=0; y<=x; y++) {\n\t\t\t\tSystem.out.print(arr[x][y]+\"\\t\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}\n```\n\n### 思考题1Java中的参数传递问题及图解\n\n```javascript\n/*\n\t思考题1：看程序写结果，然后分析为什么是这个样子的。并画图讲解。最后总结Java中参数传递规律。\n\t\n\tJava中的参数传递问题：\n\t\t基本类型：形式参数的改变对实际参数没有影响。\n\t\t引用类型：形式参数的改变直接影响实际参数。\n*/\nclass ArgsDemo {\n\tpublic static void main(String[] args) {\n\t\tint a = 10;\n\t\tint b = 20;\n\t\tSystem.out.println(\"a:\"+a+\",b:\"+b); //a:10,b:20\n\t\tchange(a,b);\n\t\tSystem.out.println(\"a:\"+a+\",b:\"+b); //???\ta:10,b:20\n\n\t\tint[] arr = {1,2,3,4,5}; \n\t\tchange(arr);\n\t\tSystem.out.println(arr[1]); //???\t4\n\t}\n\n\tpublic static void change(int a,int b) { //a=10,b=20\n\t\tSystem.out.println(\"a:\"+a+\",b:\"+b); //a:10,b:20\n\t\ta = b;\t//a=20\n\t\tb = a + b; //b=40\n\t\tSystem.out.println(\"a:\"+a+\",b:\"+b); //a:20,b:40\n\t}\n\n\tpublic static void change(int[] arr) { //arr={1,2,3,4,5};\n\t\tfor(int x=0; x<arr.length; x++) {\n\t\t\tif(arr[x]%2==0) {\n\t\t\t\tarr[x]*=2;\n\t\t\t}\n\t\t}\n\t\t//arr={1,4,3,8,5};\n\t}\n}\n```\n\n![tupian4](https://images2015.cnblogs.com/blog/1118847/201705/1118847-20170504104328929-220526806.png)\n\n### 思考题2加密问题的分析和代码实现\n\n```javascript\n/*\n\t某个公司采用公用电话传递数据信息，数据是小于8位的整数，为了确保安全，\n\t在传递过程中需要加密，加密规则如下：\n\t\t首先将数据倒序，然后将每位数字都加上5，再用和除以10的余数代替该数字，\n\t\t最后将第一位和最后一位数字交换。 请任意给定一个小于8位的整数，\n\t\t然后，把加密后的结果在控制台打印出来。 \n\t\t\n\t题目要求：\n\t\tA:数据是小于8位的整数\n\t\t\t定义一个int类型的数据\n\t\t\tint number = 123456;\n\t\tB:加密规则\n\t\t\ta:首先将数据倒序\n\t\t\t\t结果 654321\n\t\t\tb:然后将每位数字都加上5，再用和除以10的余数代替该数字\n\t\t\t\t结果 109876\n\t\t\tc:最后将第一位和最后一位数字交换\n\t\t\t\t结果 609871\n\t\tC:把加密后的结果输出在控制台\n\t\t\n\t\t通过简单的分析，我们知道如果我们有办法把这个数据变成数组就好了。\n\t\t不是直接写成这个样子的：\n\t\t\tint[] arr = {1,2,3,4,5,6};\n\t\t\t\n\t\t如何把数据转成数组呢?\n\t\t\tA:定义一个数据\n\t\t\t\tint number = 123456;\n\t\t\tB:定义一个数组,这个时候问题就来了，数组的长度是多少呢?\n\t\t\t\tint[] arr = new int[8]; //不可能超过8\n\t\t\t\t在赋值的时候，我用一个变量记录索引的变化。\n\t\t\t\t定义一个索引值是0\n\t\t\t\tint index = 0;\n\t\t\tC:获取每一个数据\n\t\t\t\tint ge = number%10\n\t\t\t\tint shi = number/10%10\n\t\t\t\tint bai = number/10/10%10\n\t\t\t\t\n\t\t\t\tarr[index] = ge;\n\t\t\t\tindex++;\n\t\t\t\tarr[index] = shi;\n\t\t\t\tindex++;\n\t\t\t\tarr[index] = bai;\n\t\t\t\t...\n*/\nclass JiaMiDemo {\n\tpublic static void main(String[] args) {\n\t\t//定义一个数据\n\t\tint number = 123456;\n\t\t\n\t\t//定义一个数组\n\t\tint[] arr = new int[8];\n\t\t\n\t\t//把数据中每一位上的数据获取到后存储到数组中\n\t\t/*\n\t\tint index = 0;\n\t\tarr[index] = number%10; //arr[0]=6;\n\t\tindex++;\n\t\tarr[index] = number/10%10; //arr[1]=5;\n\t\tindex++;\n\t\tarr[index] = mumber/10/10%10; //arr[2]=4;\n\t\t*/\n\t\t\n\t\t//通过观察这个代码，我们发现应该是可以通过循环改进的\n\t\tint index = 0;\n\t\t\n\t\twhile(number > 0) { //number=123456,number=12345,number=1234,number=123,number=12,number=1,number=0\n\t\t\tarr[index] = number%10; //arr[0]=6,arr[1]=5,arr[2]=4,arr[3]=3,arr[4]=2,arr[5]=1\n\t\t\tindex++;//index=1,index=2,index=3,index=4,index=5,index=6\n\t\t\tnumber/=10;//number=12345,number=1234,number=123,number=12,number=1,number=0\n\t\t}\n\t\t\n\t\t//然后将每位数字都加上5，再用和除以10的余数代替该数字\n\t\tfor(int x=0; x<index; x++) {\n\t\t\tarr[x] += 5;\n\t\t\tarr[x] %= 10;\n\t\t}\n\t\t\n\t\t//最后将第一位和最后一位数字交换\n\t\tint temp = arr[0];\n\t\tarr[0] = arr[index-1];\n\t\tarr[index-1] = temp;\n\t\t\n\t\t//输出数据\n\t\tfor(int x=0; x<index; x++) {\n\t\t\tSystem.out.print(arr[x]);\n\t\t}\n\t\tSystem.out.println();\n\t}\n}\n```\n\n### 思考2加密问题的代码改进\n\n```javascript\npackage stephencurry;\nimport java.util.*;\nimport java.math.*;\nimport java.io.*;\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n        Scanner sc = new Scanner(System.in);\n      //这个n的数据来自于键盘录入。\n         int num=123456;\n         int []a=new int[10];\n         int cnt=0;\n         while(num>0) {\n        \t a[cnt]=num%10;\n        \t cnt++;\n        \t num/=10;\n         }\n         for(int i=0;i<cnt;i++) {\n        \t a[i]+=5;\n        \t a[i]%=10;\n         }\n         int temp=a[cnt-1];\n         a[cnt-1]=a[0];\n         a[0]=temp;\n         for(int i=0; i<cnt; i++) {\n \t\t\tSystem.out.print(a[i]);\n \t\t}\n \t\tSystem.out.println();\n\t}\n}\n\n```\n\n## 面向对象\n\n### 面向对象的基本思想引入\n\n```javascript\n1:面向对象思想\n    面向对象是基于面向过程的编程思想。\n    \n    面向过程：强调的是每一个功能的步骤\n    面向对象：强调的是对象，然后由对象去调用功能\n    \n2:面向对象的思想特点\n    A:是一种更符合我们思想习惯的思想\n    B:可以将复杂的事情简单化\n    C:将我们从执行者变成了指挥者\n        \n    举例：\n        买电脑：\n            面向过程：我的了解电脑--了解我自己的需求--找对应的参数信息--去中关村买电脑--讨价还价--买回电脑\n            面向对象：我知道我要买电脑 -- 班长去给我买 -- 班长就买回来了\n        洗衣服：\n            面向过程：把衣服脱下--找一个盆--放点洗衣粉--加点水--把衣服扔进去--搓一搓--清洗衣服--拧干--晾起来\n            面向对象：把衣服脱下--打开全自动洗衣机--扔进去--一键即可--晾起来\n        吃饭：\n            面向过程：去超市买菜--摘菜--洗菜--切菜--炒菜--盛起来--吃\n            面向对象：上饭店吃饭，你--服务员(点菜)--厨师(做菜)--服务员(端菜)--吃\n            \n            家常事物，买洗衣机和去饭店太不划算了，所以，找个对象。\n            但是，你不跟我好好学习，你将来4000，你对象8000。\n            \n3:把大象装进冰箱\n    面向过程：\n        动作有哪些呢?\n            A:打开冰箱门\n            B:装进大象\n            C:关闭冰箱门\n            \n        代码体现；\n            class Demo {\n                public static void main(String[] args) {\n                    /*\n                    System.out.println(\"打开冰箱门\");\n                    //打开冰箱门的东西，我现在仅仅是为了演示，就写了一个输出语句\n                    //其实，它可能需要做很多操作。\n                    //这个时候代码就比较多一些了\n                    //假设我要多次打开冰箱门，\n                    //代码一多，每次都写一遍，麻烦不\n                    //我们就应该用方法改进\n                    \n                    System.out.println(\"装进大象\");\n                    System.out.println(\"关闭冰箱门\");\n                    */\n                    \n                    //写了方法以后，调用就改变了\n                    open();\n                    in();\n                    close();\n                }\n                \n                public static void open() {\n                    System.out.println(\"打开冰箱门\");\n                }\n                \n                public static void in() {\n                    System.out.println(\"装进大象\");\n                }\n                \n                public static void close() {\n                    System.out.println(\"关闭冰箱门\");\n                }\n            }\n    \n    面向对象：\n        我们怎么才能更符合面向对象思想呢?\n            A:有哪些类呢?\n            B:每个类有哪些东西呢?\n            C:类与类直接的关系是什么呢?\n            \n        把大象装进冰箱的分析? (如何分析有哪些类呢?UML。名词提取法。)\n            A:有哪些类呢?\n                大象\n                冰箱\n                Demo\n            B:每个类有哪些东西呢?\n                大象：\n                    进去\n                冰箱：\n                    开门\n                    关门\n                Demo:\n                    main方法\n            C:类与类直接的关系是什么呢?\n                Demo中使用大象和冰箱类的功能。\n                \n        代码体现：\n            class 大象 {\n                public static void in() {\n                    System.out.println(\"装进大象\");\n                }\n            }\n            \n            class 冰箱 {\n                public static void open() {\n                    System.out.println(\"打开冰箱门\");\n                }\n                \n                public static void close() {\n                    System.out.println(\"关闭冰箱门\");\n                }\n            }\n            \n            class Demo {\n                public static void main(String[] args) {\n                    冰箱调用开门\n                    大象调用进去\n                    冰箱调用关门\n                }\n            }\n            \n4:开发，设计，特征\n面向对象开发\n    就是不断的创建对象，使用对象，指挥对象做事情。\n    \n面向对象设计\n    其实就是在管理和维护对象之间的关系。\n\n面向对象特征\n    封装(encapsulation)\n    继承(inheritance)\n    多态(polymorphism)\n```\n\n### 类与对象的概述\n\n```javascript\n现实世界中是如何描述一个事物的呢?\n\t举例：学生\n\t\t\t姓名,年龄,性别...\n\t\t\t学习,吃饭,睡觉\n\t\t\t\n\t属性：该事物的描述信息\n\t行为：该事物能够做什么\n\t\n我们学习编程语言，是为了模拟现实世界的事物的。\n而我们学习的编程语言Java中最基本的单位是：类。\n所以，我们就应该把事物通过类来体现出来：\n由此，我们就得到了现实世界事物和类的对应关系：\n\n事物：\t\t\t\t\t\t类：\t\n\t属性\t\t\t\t\t\t成员变量\n\t行为\t\t\t\t\t\t成员方法\n\t\n\t\n类：是一组相关的属性和行为的集合。是一个抽象的概念。\n对象：是该类事物的具体表现形式。具体存在的个体。\n\n举例：\n\t学生：类\n\t班长：对象\n```\n\n### 类的定义：学生类\n\n```javascript\n/*\n\t事物：\n\t\t属性\t事物的信息描述\n\t\t行为\t事物的功能\n\t\n\t类：\n\t\t成员变量\t事物的属性\n\t\t成员方法\t事物的行为\n\t\t\n\t定义一个类，其实就是定义该类的成员变量和成员方法。\n\t\n\t案例：我们来完成一个学生类的定义。\n\t\n\t学生事物：\n\t\t属性：姓名，年龄，地址...\n\t\t行为：学习，吃饭，睡觉...\n\t\t\n\t把事物要转换为对应的类：\n\t\n\t学生类：\n\t\t成员变量：姓名，年龄，地址...\n\t\t成员方法：学习，吃饭，睡觉...\n\t\t\n\t成员变量：和以前变量的定义是一样的格式，但是位置不同，在类中方法外。\n\t成员方法：和以前的方法定义是一样的格式，但是今天把static先去掉。\n\t\n\t首先我们应该定义一个类，然后完成类的成员。\n*/\n//这是我的学生类\nclass Student {\n\t//定义变量\n\t//姓名\n\tString name;\n\t//年龄\n\tint age;\n\t//地址\n\tString address;\n\t\n\t//定义方法\n\t//学习的方法\n\tpublic void study() {\n\t\tSystem.out.println(\"学生爱学习\");\n\t}\n\t\n\t//吃饭的方法\n\tpublic void eat() {\n\t\tSystem.out.println(\"学习饿了,要吃饭\");\n\t}\n\t\n\t//睡觉的方法\n\tpublic void sleep() {\n\t\tSystem.out.println(\"学习累了,要睡觉\");\n\t}\n}\n\n```\n\n### 学生类的使用\n\n```javascript\n/*\n\t在一个java文件中写两个类：一个基本的类，一个测试类。\n\t注意：文件名称和测试类名称一致。\n\t\n\t如何使用呢?\n\t\t创建对象使用。\n\t\t\n\t如何创建对象呢?\n\t\t格式：类名 对象名 = new 类名();\n\t\t\n\t如何使用成员变量呢?\n\t\t对象名.变量名\n\t如何使用成员方法呢?\n\t\t对象名.方法名(...)\n*/\n//这是学生类\nclass Student {\n\t//姓名\n\tString name; //null\n\t//年龄\n\tint age; //0\n\t//地址\n\tString address; //null\n\t\n\t//学习\n\tpublic void study() {\n\t\tSystem.out.println(\"学生爱学习\");\n\t}\n\t\n\t//吃饭\n\tpublic void eat() {\n\t\tSystem.out.println(\"学习饿了，要吃饭\");\n\t}\n\t\n\t//睡觉\n\tpublic void sleep() {\n\t\tSystem.out.println(\"学习累了，要睡觉\");\n\t}\n}\n\n//这是学生测试类\nclass StudentDemo {\n\tpublic static void main(String[] args) {\n\t\t//类名 对象名 = new 类名();\n\t\tStudent s = new Student();\n\t\t\n\t\t//输出成员变量值\n\t\t//System.out.println(s.name);\n\t\t//System.out.println(s.age);\n\t\t//System.out.println(s.address);\n\t\t//改进写法\n\t\tSystem.out.println(s.name+\"---\"+s.age+\"---\"+s.address);\n\t\t\n\t\t\n\t\t//给成员变量赋值\n\t\ts.name = \"林青霞\";\n\t\ts.age = 27;\n\t\ts.address = \"北京\";\n\t\t//赋值后的输出\n\t\tSystem.out.println(s.name+\"---\"+s.age+\"---\"+s.address);\n\t\t\n\t\t//调用方法\n\t\ts.study();\n\t\ts.eat();\n\t\ts.sleep();\n\t}\n}\n```\n\n### 类的定义：手机类\n\n```javascript\n/*\n\t手机事物：\n\t\t属性：品牌，价格，颜色...\n\t\t行为：打电话，发短信，玩游戏...\n\t\t\n\t手机类：\n\t\t成员变量：品牌，价格，颜色\n\t\t成员方法：打电话，发短信，玩游戏\n*/\nclass Phone {\n\t//品牌\n\tString brand;\n\t//价格\n\tint price;\n\t//颜色\n\tString color;\n\t\n\t//打电话的方法\n\tpublic void call(String name) {\n\t\tSystem.out.println(\"给\"+name+\"打电话\");\n\t}\n\t\n\t//发短信的方法\n\tpublic void sendMessage() {\n\t\tSystem.out.println(\"群发短信\");\n\t}\n\t\n\t//玩游戏的方法\n\tpublic void playGame() {\n\t\tSystem.out.println(\"玩游戏\");\n\t}\n}\n```\n\n### 手机类的使用\n\n```javascript\n/*\n\t手机类的测试\n*/\nclass Phone {\n\t//品牌\n\tString brand;\n\t//价格\n\tint price;\n\t//颜色\n\tString color;\n\t\n\t//打电话的方法\n\tpublic void call(String name) {\n\t\tSystem.out.println(\"给\"+name+\"打电话\");\n\t}\n\t\n\t//发短信的方法\n\tpublic void sendMessage() {\n\t\tSystem.out.println(\"群发短信\");\n\t}\n\t\n\t//玩游戏的方法\n\tpublic void playGame() {\n\t\tSystem.out.println(\"玩游戏\");\n\t}\n}\n\nclass PhoneDemo {\n\tpublic static void main(String[] args) {\n\t\t//创建手机对象\n\t\t//类名 对象名 = new 类名();\n\t\tPhone p = new Phone();\n\t\t\n\t\t//直接输出成员变量值\n\t\tSystem.out.println(p.brand+\"---\"+p.price+\"---\"+p.color);\n\t\t\n\t\t//给成员变量赋值\n\t\tp.brand = \"诺基亚\";\n\t\tp.price = 100;\n\t\tp.color = \"灰色\";\n\t\t//再次输出\n\t\tSystem.out.println(p.brand+\"---\"+p.price+\"---\"+p.color);\n\t\t\n\t\t//调用方法\n\t\tp.call(\"林青霞\");\n\t\tp.sendMessage();\n\t\tp.playGame();\n\t}\n}\n```\n\n### 一个对象的内存图\n\n![tupian11](https://images2015.cnblogs.com/blog/1118847/201705/1118847-20170504134754117-224251542.png)\n\n### 两个对象的内存图\n\n![tupian22](https://images2015.cnblogs.com/blog/1118847/201705/1118847-20170504135757414-55356193.png)\n\n### 三个对象的内存图\n\n![tupian33](https://images2015.cnblogs.com/blog/1118847/201705/1118847-20170504140614757-1493738338.png)\n\n\n\n","tags":["Java系统学习"],"categories":["Java系统学习-JavaSE篇"]},{"title":"数据库原理及应用上机实验二","url":"/2020/05/25/数据库原理及应用上机实验二/","content":"\n## 实验名称：实验二 数据基本查询\n\n<!--more-->\n\n## 实验目的\n\n**1.掌握SQL查询语句的一般格式。**\n\n**2.掌握简单数据查询操作。**\n\n**3.熟练掌握各种查询条件的表示。**\n\n**4.掌握排序和分组操作在SQL语句中的实现。**\n\n**5.掌握集函数的使用。**\n\n## 实验步骤与调试过程(请用简单的文字描述)\n\n```\n1.按实验一步骤先建好数据库，建好表，并输入实验一所给的数据。\n2.对各表中的数据进行不同条件的查询；\n包括的运算：投影、选择、比较运算符、逻辑运算符、字符匹配运算符、匹配列表范围、算术运算符、内部函数、排序、分组、分组函数使用\n（1）查询全体学生的学号和姓名\n（2）查询全体学生的详细记录\n（3）查询软件学院的学生姓名、年龄、系别\n（4）查询所有选修过课程的学生学号（不重复）\n（5）查询考试不及格的学生学号（不重复）\n（6）查询不是软件学院、计算机系的学生性别、年龄、系别\n（7）查询年龄18－20岁的学生学号、姓名、系别、年龄；\n（8）查询姓刘的学生情况\n（9）查询姓刘或姓李的学生情况\n（10）查询姓刘且名字为两个字的学生情况\n（11）查询1983年以后出生的学生姓名。\n（12）创建表 studentgrad(sno,mathgrade,englishigrade,chinesegrade)\n计算学生各科总成绩并赋予别名\n（13）利用内部函数 year()查找软件学院学生的出生年份\n（14）利用字符转换函数实现字符联接。\n       Select sname + ‘年龄为’+cast(sage as char(2))+’岁’\n       From student\n（15）查询全体学生情况，查询结果按所在系升序排列，对同一系中的学生按年龄降序排列。\n（16）查询学生总人数。\n（17）查询选修了课程的学生人数。\n（18）查询选修了7号课程的学生总人数和平均成绩\n（19）查询选修6号课程学生的最好成绩\n（20）查询每个系的系名及学生人数。\n（21）查找每门课的选修人数及平均成绩\n（22）查找没有先修课的课程情况\n```\n\n## 实验结果(上传实验结果截图或者简单文字描述)\n\n```\n1.如果要对一列值设置别名，需要select+ 列名+as+新名字。\n\n2.使用group  by可以把一列或者多列分组，具有相同值的会被分在同一个分组。\n\n3.使用year（）函数可以很简洁算出你想要的那个日期的元组数有多少。\n\n4.使用order by 可以对指定列排序，升序可以直接省略。\n```\n\n## 疑难小结(总结个人在实验中遇到的问题或者心得体会)\n\n```\n1.在查询全体学生的学号和姓名时，因为记错了语句，一直出错，调试了好久。\n2.在进行步骤的时候，不知道怎么才能在列之间插入字符，很是迷茫，所以去百度了方法之后，才会。\n3.还有就是在进行实验的过程中，经常遇到一些小问题，总结来说的话，就是不够细心和认真，下次再做实验的时候会改正。\n```\n\n## 实验详细操作步骤或程序清单\n\n```\n1、查询全体学生的学号和姓名\nselect sno,sname \nfrom student;\n\n2、查询全体学生的详细记录\nselect * \nfrom student;\n\n3、查询软件学院的学生姓名、年龄、系别\nselect sname,sage,sdept\nfrom student\nwhere sdept='MA';\n\n4、查询所有选修过课程的学生学号（不重复）\nselect distinct sno \nfrom sc;\nwhere cno<>'null';\n\n5、查询考试不及格的学生学号（不重复）\nselect distinct sno\nfrom sc\nwhere grade<60;\n\n6、查询不是软件学院、计算机系的学生性别、年龄、系别\n\nselect ssex,sage,sdept\nfrom student \nwhere sdept not in('CS','MA');\n\n7、查询年龄18－20岁的学生学号、姓名、系别、年龄\n\nselect sno,sname,sdept,sage \nfrom student\nwhere sage between 18 and 20;\n\n8、查询姓刘的学生情况\nselect * \nfrom student\nwhere sname like '刘%';\n\n9、查询姓刘或姓李的学生情况\nselect *\nfrom student\nwhere sname like '刘%' or sname like '李%';\n\n10、查询姓刘且名字为两个字的学生情况\nselect * \nfrom student\nwhere sname like '刘_';\n\n11、查询1983年以后出生的学生姓名\nselect sname \nfrom student \nwhere sage < 2019-1983\n\n12、创建表 studentgrad(sno,mathgrade,englishigrade,chinesegrade)计算学生各科总成绩并赋予别名\ncreate table studentgrade(\n    Sno char(8) ,\n    mathgrade int,\n    englishigrade int,\n    chinesegrade int\n)\nselect sum(mathgrade+chinesegrade+englishigrade) '学生总成绩' \nfrom studentgrade;\n\n13、利用内部函数 year()查找软件学院学生的出生年份\nselect (year(getdate())-student.sage+1) \nfrom student \nwhere sdept='MA';\n\n14、利用字符转换函数实现字符联接。select sname+‘年龄为’+cast(sage as char(2))+’岁’ from student\nselect sname+'年龄为'+cast(sage as char(2))+'岁'\nfrom student;\n\n15、查询全体学生情况，查询结果按所在系升序排列，对同一系中的学生按年龄降序排列\nselect *\nfrom student \norder by sdept,sage desc;\n\n16、查询学生总人数\nselect count(*) \nfrom student;\n\n17、查询选修了课程的学生人数\nselect count(distinct sno) \nfrom sc;\n\n18、查询选修了7号课程的学生总人数和平均成绩\nselect count(*),avg(grade)as avggrade \nfrom student,sc \nwhere student.sno=sc.sno and sc.cno='7';\n\n19、查询选修6号课程学生的最好成绩\nselect max(grade) as maxgrade \nfrom sc\nwhere cno='6';\n\n20、查询每个系的系名及学生人数\nselect sdept,count(*) \nfrom student\ngroup by sdept;\n\n21、查找每门课的选修人数及平均成绩\nselect cno,count(*),avg(grade) as avggrade \nfrom sc\ngroup by cno;\n\n22、查找没有先修课的课程情况\nselect * \nfrom course \nwhere cpno is null;\n```\n","tags":["SQL上机实验"],"categories":["SQL"]},{"title":"数据库原理及应用上机实验一","url":"/2020/05/25/数据库原理及应用上机实验一/","content":"\n## 实验名称：实验一 数据定义\n\n<!--more-->\n\n## 实验目的\n\n**1.熟练掌握SQL语言进行基本表结构的创建。**\n\n**2.熟练应用SQL语言进行表结构的修改。**\n\n**3.掌握SQL语言进行基本表的删除。**\n\n**4.掌握SQL语言进行索引的建立和删除。**\n\n**5.选择具体的数据库管理系统进行实现。**\n\n## 实验步骤与调试过程(请用简单的文字描述)\n\n```\n1.用create新建数据库。\n2.用create建立表格。\n3.输入数据验证约束条件。\n4.\n（1） STUDENT表中增加一个字段入学时间scome\n（2） 删除STUDENT表中sdept字段\n（3） 删除创建的SC表中cno字段和COURSE表cno字段之间的外键约束\n（4） 重建（3）中删除的约束\n5.重新定义一个简单表，然后用SQL语言DROP语句删除该表结构。\n6.用SQL语言CREATE INDEX语句定义表STUDENT的SNAME字段的降序唯一索引。\n7.用SQL语言DROP语句删除索引。\n```\n\n## 实验结果(上传实验结果截图或者简单文字描述)\n\n```\n1.知道了如何利用SQL server新建数据库，新建表，插入数据进表，修改表，建立索引，删除索引名等。\n2.删除一个外键约束时必须先知道这个约束的名称。\n3.删除索引时必须指明索引名与表名。\n4.在列的数据类型后直接输入default，后加要设置的默认值 即可设置该列的默认值 。\n```\n\n## 疑难小结(总结个人在实验中遇到的问题或者心得体会)\n\n```\n1.一开始只知道直接利用鼠标右键进行新建数据库，不知道怎么利用SQL语言建立数据库，然后自行学了一下才会。\n2.当我在删除一个表中外码的外键约束时，不知道约束名称，找了半天才在键值中找到，然后使用DROP CONSTRAINT+约束名对其进行了删除。\n3.删除索引需要drop index后加上表名跟索引名，原来我直接写的是   DROP INDEX 表名 +索引名 ，总是弄不对，然后百度了一下才弄明白。\n```\n\n## 实验详细操作步骤或程序清单\n\n```\n1.新建一个student数据库\n\nuse master --打开master数据库，一般的创建语句都在master中执行\ngo\nif exists (select * from sysdatabases where name='students')/*检查有没有这个数据库*/\n  drop database students\ngo\nCREATE DATABASE students /*创建数据库students*/\nON PRIMARY\n(\n    name=\"students_data\",/*主数据文件的逻辑名*/\n    filename=\"D:\\SQL-student-test\\students_data.mdf\",  /*主数据文件储存位置*/\n    size=3mb,   /*主数据文件的初始大小*/\n    maxsize=100mb, /*主数据文件的最大大小，不写就是没有限制*/\n    filegrowth=1mb /*增量为1MB*/\n)\nlog on\n(    /*日志文件*/\n    name=\"students_log\", \n    filename=\"D:\\SQL-student-test\\students_log.ldf\",/*日志文件储存位置*/\n    size=1mb,   /*日志文件的初始大小*/\n    filegrowth=10%/*增长率为10%*/\n)\n\n2.新建表\n\ncreate table student  --创建表student\n(\n   sno char(8) \n   sname char(4) NOT NULL,\n   ssex char(2) DEFAULT '男' CHECK(ssex in ('男','女')),\n   sage int,\n   sdept char(10),\n   \n   primary key(sno)\n)\ncreate table course   --创建表course\n(\ncno char(2) \ncanme char(30),\ncredit int,\ncpno char(3),\n\nprimary key(cno) \n)\ncreate table sc  --创建表sc \n(\nsno char(8),\ncno char(2),\ngrade int check(grade>=0 and grade<=100),\nprimary key(sno,cno),\nforeign key (sno) references student(sno),\nforeign key (cno) references course(cno),\n)\n\n3.第四步骤代码\n\n（1）alter table student add scome;\n（2）alter table student drop column sdept;\n（3）alter table sc drop constraint+约束名\n（4）alter table sc add foreign key (cno) references course(cno)+约束名，\n\n4.第六，七步骤代码\n\ncreate unique index love on student(sname desc) ;\ndrop index love on student;\n\n```\n","tags":["SQL上机实验"],"categories":["SQL"]},{"title":"JavaSE-Day(5)学习笔记","url":"/2020/05/19/JavaSE-Day(5)学习笔记/","content":"\n### 方法概述和格式说明\n\n<!--more-->\n\n**方法：完成特定功能的代码块。**\n\n注意：在很多语言里面有函数的定义，而在Java中函数被称为方法。\n\n**方法格式：**\n\n      修饰符 返回值类型 方法名(参数类型 参数名1,参数类型 参数名2...) {\n\t\t\t方法体语句;\n\t\t\treturn 返回值; \n\t\t}\n\n**详细解释：**\n\n- 修饰符：目前就用 public static。后面我们再详细的讲解其他的修饰符。\n\n- 返回值类型：就是功能结果的数据类型。\n\n- 方法名：符合命名规则即可。方便我们的调用。\n\n- 参数：\n  - 实际参数：就是实际参与运算的。\n  - 形式参数；就是方法定义上的，用于接收实际参数的。\n\n- 参数类型：就是参数的数据类型。\n\n- 参数名：就是变量名。\n\n- 方法体语句：就是完成功能的代码。\n\n- return：结束方法的。\n\n- 返回值：就是功能的结果，由return带给调用者。\n\n**要想写好一个方法，就必须明确两个东西：**\n\n- A:返回值类型\n\t结果的数据类型\n\n- B:参数列表\n\t你要传递几个参数，以及每个参数的数据类型\n\n### 方法的定义求和案例\n\n**需求：求两个数据之和的案例**\n\n- 方法的执行特点：不调用，不执行。\n\n- 如何调用呢?(有明确返回值的调用)\n\n  - A:单独调用,一般来说没有意义，所以不推荐。\n\n  - B:输出调用,但是不够好。因为我们可能需要针对结果进行进一步的操作。\n\n  - C:赋值调用,推荐方案。\n\n### 方法的调用有明确返回值的方法的调用\n\n```\nclass FunctionDemo {\n\tpublic static void main(String[] args) {\n\t\tint x = 10;\n\t\tint y = 20;\n\t\t\n\t\t//方式1：单独调用\n\t\t//sum(x,y);\n\t\n\t\t//方式2：输出调用\n\t\t//System.out.println(sum(x,y));\n\t\t//System.out.println(30);\n\t\n\t\t//方式3：赋值调用\n\t\tint result = sum(x,y);\n\t\t//result在这里可以进行操作\n\t\tSystem.out.println(result);\n\t}\n\t\n\t/*\n\t\t需求：求两个数据之和的案例\n\t\t\n\t\t两个明确：\n\t\t\t返回值类型：int\n\t\t\t参数列表：2个，都是int类型。\n\t*/\n\tpublic static int sum(int a,int b) {\n\t\t\t//如何实现呢?\n\t\t\t//int c = a + b;\n\t\t\t//return c;\n\t\t\t\n\t\t\t//c就是a+b,所以，我可以直接返回a+b\n\t\t\treturn a + b;\n\t}\n\t\n}\n```\n\n### 方法的调用图解\n\n![tupian1](https://img-blog.csdnimg.cn/20200404172429459.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzczNjMz,size_16,color_FFFFFF,t_70)\n\n### 方法的练习1获取两个数中的最大值\n\n```\n/*\n\t键盘录入两个数据，返回两个数中的较大值\n*/\nimport java.util.Scanner;\n\nclass FunctionTest {\n\tpublic static void main(String[] args) {\n\t\t//创建键盘录入对象\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tSystem.out.println(\"请输入第一个数据:\");\n\t\tint a = sc.nextInt();\n\t\t\n\t\tSystem.out.println(\"请输入第二个数据:\");\n\t\tint b = sc.nextInt();\n\t\t\n\t\tint result = getMax(a,b);\n\t\tSystem.out.println(\"较大值是：\"+result);\n\t}\n\t\n\t/*\n\t\t需求：两个数中的较大值\n\t\t两个明确：\n\t\t\t返回值类型：int\n\t\t\t参数列表：int a,int b\t\t\t\n\t*/\n\tpublic static int getMax(int a,int b) {\n\t\t//if语句\n\t\t/*\n\t\tif(a > b) {\n\t\t\t//System.out.println(a);\n\t\t\treturn a;\n\t\t}else {\n\t\t\t//System.out.println(b);\n\t\t\treturn b;\n\t\t}\n\t\t*/\n\t\t\n\t\t//用三元改进\n\t\t//int c = ((a > b)? a: b);\n\t\t//return c;\n\t\t\n\t\t//由于c就是后面的式子\n\t\treturn ((a>b)? a : b);\n\t}\n}\n```\n\n### 方法的练习2比较两个数是否相等\n\n```\n/*\n\t键盘录入两个数据，比较两个数是否相等\n\t\n\t分析：\n\t\t比较两个数是否相等结果是一个boolean类型。\n*/\nimport java.util.Scanner;\n\nclass FunctionTest2 {\n\tpublic static void main(String[] args) {\n\t\t//创建键盘录入对象\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tSystem.out.println(\"请输入第一个数据:\");\n\t\tint a = sc.nextInt();\n\t\t\n\t\tSystem.out.println(\"请输入第二个数据:\");\n\t\tint b = sc.nextInt();\n\t\t\n\t\tboolean flag = compare(a,b);\n\t\tSystem.out.println(flag);\n\t}\n\t\n\t/*\n\t\t需求：比较两个数是否相等\n\t\t两个明确：\n\t\t\t返回值类型：boolean\n\t\t\t参数列表：int a,int b\n\t*/\n\tpublic static boolean compare(int a,int b) {\n\t\t//if语句的格式2实现\n\t\t/*\n\t\tif(a == b) {\n\t\t\treturn true;\n\t\t}else {\n\t\t\treturn false;\n\t\t}\n\t\t*/\n\t\t\n\t\t//三元改进\n\t\t//boolean flag = ((a==b)? true: false);\n\t\t//return flag;\n\t\t\n\t\t//继续改进\n\t\t//return ((a==b)? true: false);\n\t\t\n\t\t//最终版\n\t\treturn a == b;\n\t}\n}\n```\n\n### 方法的练习3获取三个数中的最大值\n\n```\n/*\n\t键盘录入三个数据，返回三个数中的最大值\n*/\nimport java.util.Scanner;\n\nclass FunctionTest3 {\n\tpublic static void main(String[] args) {\n\t\t//创建键盘录入对象\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tSystem.out.println(\"请输入第一个数据:\");\n\t\tint a = sc.nextInt();\n\t\t\n\t\tSystem.out.println(\"请输入第二个数据:\");\n\t\tint b = sc.nextInt();\n\t\t\n\t\tSystem.out.println(\"请输入第三个数据:\");\n\t\tint c = sc.nextInt();\n\t\t\n\t\tint max = getMax(a,b,c);\n\t\tSystem.out.println(\"三个数据中的最大值是：\"+max);\n\t}\n\t\n\t/*\n\t\t需求；返回三个数中的最大值\n\t\t\n\t\t两个明确：\n\t\t\t返回值类型：int\n\t\t\t参数列表：int a,int b,int c\n\t*/\n\tpublic static int getMax(int a,int b,int c) {\n\t\t//if嵌套\n\t\t/*\n\t\tif(a > b) {\n\t\t\tif(a > c) {\n\t\t\t\treturn a;\n\t\t\t}else {\n\t\t\t\treturn c;\n\t\t\t}\n\t\t}else {\n\t\t\tif(b > c) {\n\t\t\t\treturn b;\n\t\t\t}else {\n\t\t\t\treturn c;\n\t\t\t}\n\t\t}\n\t\t*/\n\t\t\n\t\t//用三元改\n\t\t/*\n\t\tif(a > b) {\n\t\t\treturn (a>c? a: c);\n\t\t}else {\n\t\t\treturn (b>c? b: c);\n\t\t}\n\t\t*/\n\t\t\n\t\t//继续改进\n\t\t//return (a>b)? (a>c? a: c): (b>c? b: c);\n\t\t//不建议，写代码一定要注意阅读性强\n\t\tint temp = ((a>b)? a: b);\n\t\tint max = ((temp>c)? temp: c);\n\t\treturn max;\n\t}\n}\n```\n\n### 方法的注意事项\n\n```\n/*\n\t方法的注意事项：\n\t\tA:方法不调用不执行\n\t\tB:方法与方法是平级关系，不能嵌套定义\n\t\tC:方法定义的时候参数之间用逗号隔开\n\t\tD:方法调用的时候不用在传递数据类型\n\t\tE:如果方法有明确的返回值，一定要有return带回一个值\n*/\nclass FunctionDemo2 {\n\tpublic static void main(String[] args) {\n\t\t/*\n\t\t错误的\n\t\tpublic static int sum(int a,int b){\n\t\t\treturn a + b;\n\t\t}\n\t\t*/\n\t\t\n\t\t//sum(10,20);\n\t\t\n\t\t//int x = 10;\n\t\t//int y = 20;\n\t\t//错误\n\t\t//sum(int x,int y);\n\t}\n\t\n\tpublic static int sum(int a,int b){\n\t\treturn a + b;\n\t}\n}\n```\n\n### 方法的调用void类型方法的定义和调用\n\n```\n/*\n\t需求：在控制台输出如下的形状\n\t\t*****\n\t\t*****\n\t\t*****\n\t\t*****\n\t\t\n\tvoid类型返回值的方法调用：\n\t\t单独调用\n\t\t输出调用(错误)\n\t\t赋值调用(错误)\n*/\nclass FunctionDemo3 {\n\tpublic static void main(String[] args) {\n\t\t//for循环嵌套输出图形\n\t\tfor(int x=0; x<4; x++) {\n\t\t\tfor(int y=0; y<5; y++) {\n\t\t\t\tSystem.out.print(\"*\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println(\"--------------\");\n\t\t\n\t\t//需求：我要在控制台输出一个6行7列的星形图形\n\t\tfor(int x=0; x<6; x++) {\n\t\t\tfor(int y=0; y<7; y++) {\n\t\t\t\tSystem.out.print(\"*\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println(\"--------------\");\n\t\t\n\t\t//如果需要继续改变，我们就应该考虑使用方法改进。\n\t\t//单独调用\n\t\tpringXing(3,4);\n\t\tSystem.out.println(\"--------------\");\n\t\tpringXing(6,7);\n\t\tSystem.out.println(\"--------------\");\n\t\tpringXing(8,9);\n\t\t\n\t\t//输出调用\n\t\t//此处不允许使用 '空' 类型\n\t\t//System.out.println(pringXing(3,4));\n\t\t\n\t\t//赋值调用\n\t\t//非法的表达式开始\n\t\t//void v = pringXing(3,4);\n\t}\n\t\n\t/*\n\t\t写一个什么样子的方法呢?写一个m行n列的代码\n\t\t\n\t\t两个明确：\n\t\t\t返回值类型：这个时候没有明确的返回值，不写东西还不行，所以，这里记住是void\n\t\t\t参数列表：int m,int n\n\t*/\n\tpublic static void pringXing(int m,int n) {\n\t\tfor(int x=0; x<m; x++) {\n\t\t\tfor(int y=0; y<n; y++) {\n\t\t\t\tSystem.out.print(\"*\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}\n```\n\n### 方法的练习4根据行数和列数输出星形\n\n```\n/*\n\t键盘录入行数和列数，输出对应的星形\n*/\nimport java.util.Scanner;\n\nclass FunctionTest4 {\n\tpublic static void main(String[] args) {\n\t\t//创建键盘录入对象\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tSystem.out.println(\"请输入行数：\");\n\t\tint m = sc.nextInt();\n\t\t\n\t\tSystem.out.println(\"请输入列数：\");\n\t\tint n = sc.nextInt();\n\t\t\n\t\t//void类型的方法调用\n\t\tpringXing(m,n);\n\t}\n\t\n\t/*\n\t\t输出星形\n\t\t\n\t\t两个明确：\n\t\t\t返回值类型：void\n\t\t\t参数列表：int m,int n\n\t*/\n\tpublic static void pringXing(int m,int n) {\n\t\tfor(int x=0; x<m; x++) {\n\t\t\tfor(int y=0; y<n; y++) {\n\t\t\t\tSystem.out.print(\"*\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}\n```\n\n### 方法的练习5根据键盘录入输入相对应的乘法表\n\n```\n/*\n\t键盘录入一个数据n(1<=n<=9)，输出对应的nn乘法表\n*/\nimport java.util.Scanner;\n\nclass FunctionTest5 {\n\tpublic static void main(String[] args) {\n\t\t//创建对象\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tSystem.out.println(\"请输入n的值：(1~9)\");\n\t\tint n = sc.nextInt();\n\t\t\n\t\t//调用\n\t\tprintNN(n);\n\t}\n\t\n\t/*\n\t\t需求：输出对应的nn乘法表\n\t\t两个明确：\n\t\t\t返回值类型：void\n\t\t\t参数列表：int n\n\t*/\n\tpublic static void printNN(int n) {\n\t\tfor(int x=1; x<=n; x++) {\n\t\t\tfor(int y=1; y<=x; y++) {\n\t\t\t\tSystem.out.print(y+\"*\"+x+\"=\"+y*x+\"\\t\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}\n```\n\n### 方法重载概述和基本使用\n\n```\n/*\n\t需求：我要求数的和\n\t\n\t我们的需求不断的发生改变，我们就对应的提供了多个求和的方法。\n\t但是呢，他们的名字是不一样的。\n\t而我们又要求方法命名做到：见名知意。\n\t但是，很明显，现在没有做到。\n\t那么，肿么办呢?\n\t针对这种情况：方法的功能相同，参数列表不同的情况，为了见名知意，Java允许它们起一样的名字。\n\t\n\t其实，这种情况有一个专业名词：方法重载。\n\t\n\t方法重载：\n\t\t在同一个类中，方法名相同，参数列表不同。与返回值类型无关。\n\t\t\n\t\t参数列表不同：\n\t\t\tA:参数个数不同\n\t\t\tB:参数类型不同\n*/\nclass FunctionDemo4 {\n\tpublic static void main(String[] args) {\n\t\t//jvm会根据不同的参数去调用不同的功能\n\t\tSystem.out.println(sum(10,20));\n\t\tSystem.out.println(sum(10,20,30));\n\t\tSystem.out.println(sum(10,20,30,40));\n\t\t\n\t\tSystem.out.println(sum(10.5f,20f));\n\t}\n\t\n\t//需求1:求两个数的和\n\tpublic static int sum(int a,int b) {\n\t\tSystem.out.println(\"int\");\n\t\treturn a + b;\n\t}\n\t\n\t//需求2:求三数的和\n\t/*\n\tpublic static int sum1(int a,int b,int c) {\n\t\treturn a + b + c;\n\t}\n\t*/\n\t\n\tpublic static int sum(int a,int b,int c) {\n\t\treturn a + b + c;\n\t}\n\t\n\t//需求3:求四个数的和\n\t/*\n\tpublic static int sum2(int a,int b,int c,int d) {\n\t\treturn a + b + c + d;\n\t}\n\t*/\n\tpublic static int sum(int a,int b,int c,int d) {\n\t\treturn a + b + c + d;\n\t}\n\t\n\tpublic static float sum(float a,float b) {\n\t\tSystem.out.println(\"float\");\n\t\treturn a + b;\n\t}\n}\n```\n\n### 方法重载练习比较数据是否相等\n\n```\n/*\n\t比较两个数据是否相等。参数类型分别为\n\t\t两个byte类型，两个short类型，两个int类型，两个long类型，\n\t并在main方法中进行测试\n*/\nclass FunctionTest6 {\n\tpublic static void main(String[] args) {\n\t\t//测试\n\t\tbyte b1 = 3;\n\t\tbyte b2 = 4;\n\t\tSystem.out.println(\"byte:\"+compare(b1,b2));\n\t\t\n\t\t//测试\n\t\tshort s1 = 5;\n\t\tshort s2 = 5;\n\t\tSystem.out.println(\"short:\"+compare(s1,s2));\n\t\t\n\t\t//后面的两个自己测试\n\t}\n\t\n\t//byte类型\n\tpublic static boolean compare(byte a,byte b) {\n\t\tSystem.out.println(\"byte\");\n\t\treturn a == b;\n\t}\n\t\n\t//short类型\n\tpublic static boolean compare(short a,short b) {\n\t\tSystem.out.println(\"short\");\n\t\treturn a == b;\n\t}\n\t\n\t//int类型\n\tpublic static boolean compare(int a,int b) {\n\t\tSystem.out.println(\"int\");\n\t\treturn a == b;\n\t}\n\t\n\t//long类型\n\tpublic static boolean compare(long a,long b) {\n\t\tSystem.out.println(\"long\");\n\t\treturn a == b;\n\t}\n}\n```\n\n### 数组概述和定义格式说明\n\n```\n\t数组:存储同一种数据类型的多个元素的容器。\n\t\n\t定义格式：\n\t\tA:数据类型[] 数组名;\n\t\tB:数据类型 数组名[];\n\t\t\n\t举例：\n\t\tA:int[] a; 定义一个int类型的数组a变量\n\t\tB:int a[]; 定义一个int类型的a数组变量\n\t\t\n\t注意：效果可以认为是一样的，都是定义一个int数组，但是念法上有些小区别。推荐使用第一种。\n```\n\n### 数组的初始化动态初始化\n\n```\n\t如何对数组进行初始化呢?\n\t\tA:何谓初始化呢? 就是为数组开辟内存空间，并为每个数组元素赋予值\n\t\tB:有几种方式呢?\n\t\t\ta:动态初始化 只指定长度，由系统给出初始化值\n\t\t\tb:静态初始化 给出初始化值，由系统决定长度\n\t\t\t\n\t动态初始化的格式：\n\t\t数据类型[] 数组名 = new 数据类型[数组长度];\n\t\t\n\t\t举例：\n\t\tint[] arr = new int[3];\t\n\t\t\n\t如何获取数组中的元素呢?\n\t\t通过:\n\t\t\t数组名[索引]\n\t\t\t索引其实就是每个元素的编号，从0开始，最大索引是数组的长度-1。\n*/\nclass ArrayDemo {\n\tpublic static void main(String[] args) {\n\t\t//定义一个数组\n\t\t//int[] a;\n\t\t//可能尚未初始化变量a\n\t\t//System.out.println(a);\n\t\t\n\t\tint[] arr = new int[3];\n\t\t/*\n\t\t\t左边：\n\t\t\t\tint:说明数组中的元素的数据类型是int类型\n\t\t\t\t[]:说明这是一个数组\n\t\t\t\tarr:是数组的名称\n\t\t\t\t\n\t\t\t右边：\n\t\t\t\tnew:为数组分配内存空间。\n\t\t\t\tint:说明数组中的元素的数据类型是int类型\n\t\t\t\t[]:说明这是一个数组\n\t\t\t\t3:数组长度，其实也就是数组中元素的个数\n\t\t*/\n\t\t\n\t\tSystem.out.println(arr); //[I@175078b 地址值。\n\t\t//我要地址值没有意义啊，我就要数据值，怎么办呢?\n\t\t//不用担心，java为你考虑到了。\n\t\t//其实数组中的每个元素都是有编号的，并且是从0开始。最大编号是数组的长度-1。\n\t\t//用数组名和编号的配合就可以获取数组中的指定编号的元素。这个编号的专业叫法：索引\n\t\t//通过数组名访问数据的格式是：数组名[索引];\n\t\tSystem.out.println(arr[0]);\n\t\tSystem.out.println(arr[1]);\n\t\tSystem.out.println(arr[2]);\n\t}\n}\n```\n\n### Java中内存分配以及栈和堆的区别\n\n![tupian2](https://img-blog.csdnimg.cn/20200213004314263.bmp?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poZW5nemhvbmd6,size_16,color_FFFFFF,t_70)\n\n### 数组的内存图解1一个数组\n\n```\n/*\n\t定义一个数组，输出该数组的名称和数组元素值。\n\t给数组元素赋值，再次输出该数组的名称和数组元素值。\n*/\nclass ArrayDemo2 {\n\tpublic static void main(String[] args) {\n\t\t//定义一个数组\n\t\tint[] arr = new int[3];\n\t\t\n\t\t//输出数组名称\n\t\tSystem.out.println(arr);\n\t\t//输出数组元素值\n\t\tSystem.out.println(arr[0]);\n\t\tSystem.out.println(arr[1]);\n\t\tSystem.out.println(arr[2]);\n\t\tSystem.out.println(\"----\");\n\t\t\n\t\t//给数组元素赋值\n\t\tarr[0] = 100;\n\t\tarr[2] = 200;\n\t\t\n\t\t//输出数组名称\n\t\tSystem.out.println(arr);\n\t\t//输出数组元素值\n\t\tSystem.out.println(arr[0]);\n\t\tSystem.out.println(arr[1]);\n\t\tSystem.out.println(arr[2]);\n\t}\n}\n```\n\n![tupian3](https://static.oschina.net/uploads/space/2015/0902/073341_azOE_2001589.png)\n\n### 数组的内存图解2二个数组\n\n```\n/*\n\t定义两个数组，分别输出两个数组各自的数组名及元素值。\n\t然后给每个数组的元素重新赋值，再次分别输出两个数组各自的数组名及元素值。\n*/\nclass ArrayDemo3 {\n\tpublic static void main(String[] args) {\n\t\t//定义第一个数组\n\t\tint[] arr = new int[2];\n\t\t//定义第二个数组\n\t\tint[] arr2 = new int[3];\n\t\t\n\t\t//输出数组名和元素值\n\t\tSystem.out.println(arr);\n\t\tSystem.out.println(arr[0]);\n\t\tSystem.out.println(arr[1]);\n\t\tSystem.out.println(\"----\");\n\t\t\n\t\tSystem.out.println(arr2);\n\t\tSystem.out.println(arr2[0]);\n\t\tSystem.out.println(arr2[1]);\n\t\tSystem.out.println(arr2[2]);\n\t\tSystem.out.println(\"----\");\n\t\t\n\t\t//给元素重新赋值\n\t\tarr[1] = 20;\n\t\t\n\t\tarr2[1] = 30;\n\t\tarr2[0] = 40;\n\t\t\n\t\t//输出数组名和元素值\n\t\tSystem.out.println(arr);\n\t\tSystem.out.println(arr[0]);\n\t\tSystem.out.println(arr[1]);\n\t\tSystem.out.println(\"----\");\n\t\t\n\t\tSystem.out.println(arr2);\n\t\tSystem.out.println(arr2[0]);\n\t\tSystem.out.println(arr2[1]);\n\t\tSystem.out.println(arr2[2]);\n\t}\n}\n```\n\n![tupian4](http://static.oschina.net/uploads/space/2015/0902/073949_o2YO_2001589.png)\n\n### 数组的内存图解3三个数组\n\n```\n/*\n\t定义第一个数组,定义完毕后，给数组元素赋值。赋值完毕后，在输出数组名称和元素。\n\t定义第二个数组,定义完毕后，给数组元素赋值。赋值完毕后，在输出数组名称和元素。\n\t定义第三个数组,把第一个数组的地址值赋值给它。(注意类型一致)，通过第三个数组的名称去把元素重复赋值。\n\t最后，再次输出第一个数组数组名称和元素。\n*/\nclass ArrayDemo4 {\n\tpublic static void main(String[] args) {\n\t\t//定义第一个数组\n\t\tint[] arr = new int[3];\n\t\tarr[0] = 88;\n\t\tarr[1] = 33;\n\t\tarr[2] = 66;\n\t\tSystem.out.println(arr);\n\t\tSystem.out.println(arr[0]);\n\t\tSystem.out.println(arr[1]);\n\t\tSystem.out.println(arr[2]);\n\t\tSystem.out.println(\"----\");\n\t\t\n\t\t//定义第二个数组\n\t\tint[] arr2 = new int[3];\n\t\tarr2[0] = 22;\n\t\tarr2[1] = 44;\n\t\tarr2[2] = 55;\n\t\tSystem.out.println(arr2);\n\t\tSystem.out.println(arr2[0]);\n\t\tSystem.out.println(arr2[1]);\n\t\tSystem.out.println(arr2[2]);\n\t\tSystem.out.println(\"----\");\n\t\t\n\t\t//定义第三个数组\n\t\tint[] arr3 =  arr;\n\t\tarr3[0] = 100;\n\t\tarr3[1] = 200;\n\t\tSystem.out.println(arr);\n\t\tSystem.out.println(arr[0]);\n\t\tSystem.out.println(arr[1]);\n\t\tSystem.out.println(arr[2]);\n\t}\n}\n```\n\n![tupian5](http://static.oschina.net/uploads/space/2015/0902/074929_IVwD_2001589.png)\n\n\n### 数组的初始化静态初始化记内存图\n\n```\n/*\n\t数组的静态初始化：\n\t\t格式：数据类型[] 数组名 = new 数据类型[]{元素1,元素2,…};\n\t\t简化格式：\n\t\t\t数据类型[] 数组名 = {元素1,元素2,…};\n\t\t\n\t\t举例：\n\t\t\tint[] arr = new int[]{1,2,3};\n\t\t\t\n\t\t\t简化后：\n\t\t\t\n\t\t\tint[] arr = {1,2,3};\n\t\t\t\n\t注意事项：\n\t\t不要同时动态和静态进行。\n\t\t如下格式：\n\t\t\tint[] arr = new int[3]{1,2,3}; //错误\n*/\nclass ArrayDemo5 {\n\tpublic static void main(String[] args) {\n\t\t//定义数组\n\t\tint[] arr = {1,2,3};\n\t\t\n\t\tSystem.out.println(arr);\n\t\tSystem.out.println(arr[0]);\n\t\tSystem.out.println(arr[1]);\n\t\tSystem.out.println(arr[2]);\n\t}\n}\n```\n\n![tupian6](http://static.oschina.net/uploads/space/2015/0902/080032_9LAE_2001589.png)\n\n### 数组操作的两个常见小问题：越界和空指针\n\n```\n/*\n\t数组操作的两个常见小问题：\n\t\tArrayIndexOutOfBoundsException:数组索引越界异常\n\t\t\t原因：你访问了不存在的索引。\n\t\t\n\t\tNullPointerException:空指针异常\n\t\t\t原因：数组已经不在指向堆内存了。而你还用数组名去访问元素。\n\t\t\t\n\t\t作用：请自己把所有的场景Exception结尾的问题总结一下。以后遇到就记录下来。\n\t\t\t  现象，原因，解决方案。\n*/\nclass ArrayDemo6 {\n\tpublic static void main(String[] args) {\n\t\t//定义数组\n\t\tint[] arr = {1,2,3};\n\t\t\n\t\t//System.out.println(arr[3]);\n\t\n\t\t//引用类型的常量：空常量 null\n\t\tarr = null;\n\t\tSystem.out.println(arr[0]);\n\t}\n}\n```\n\n### 数组的操作1遍历\n\n```\n/*\n\t数组遍历：就是依次输出数组中的每一个元素。\n\t\n\t注意：数组提供了一个属性length，用于获取数组的长度。\n\t\t  格式：数组名.length\n*/\nclass ArrayTest {\n\tpublic static void main(String[] args) {\n\t\t//定义数组\n\t\tint[] arr = {11,22,33,44,55};\n\t\t\n\t\t//获取每一个元素\n\t\t//如何获取呢?我们知道数组名结合编号(索引)就可以找到数据\n\t\tSystem.out.println(arr[0]);\n\t\tSystem.out.println(arr[1]);\n\t\tSystem.out.println(arr[2]);\n\t\tSystem.out.println(arr[3]);\n\t\tSystem.out.println(arr[4]);\n\t\tSystem.out.println(\"--------------------\");\n\t\t\n\t\t//虽然这种做法可以，但是不是我想要的\n\t\t//我们发现，代码的重复度很高\n\t\t//输出语句，数组名都是相同的，仅仅是索引是变化的\n\t\t//我们就可以使用循环搞定索引值\n\t\tfor(int x=0; x<5; x++) {\n\t\t\t//x=0,1,2,3,4\n\t\t\tSystem.out.println(arr[x]);\n\t\t}\n\t\tSystem.out.println(\"--------------------\");\n\t\t\n\t\t//从0开始我们是明确的，但是为什么到5呢，我们是数了一下数组的个数\n\t\t//继续看下个数组如何遍历\n\t\tint[] arr2 = {1,2,3,4,5,6,7,8,9,10,11,2,2,3,4,5,7,8,5,3,5,6,8,7,8,5,3,5,6,8,7,8,5,3,5,6,8,7,8,5,3,5,6,8,7,8,5,3,5,6,8};\n\t\t//而我们在很多时候，数组的元素不能靠数\n\t\t//这个时候，数组就给我们提供了一个属性：length专门用于获取数组的长度\n\t\t//格式：数组名.length 返回数组的长度\n\t\tSystem.out.println(arr.length);\n\t\tSystem.out.println(arr2.length);\n\t\tSystem.out.println(\"--------------------\");\n\t\t\n\t\t//改进第一个程序\n\t\tfor(int x=0; x<arr.length; x++) {\n\t\t\tSystem.out.println(arr[x]);\n\t\t}\n\t\tSystem.out.println(\"--------------------\");\n\t\t\n\t\t//我们如果想要对多个数组进行遍历，每个数组的遍历我们都把代码写一遍，麻烦不\n\t\t//麻烦，所以，我们准备用方法改进。\n\t\t//用方法改进后，请调用\n\t\tprintArray(arr);\n\t\tSystem.out.println(\"--------------------\");\n\t\tprintArray(arr2);\n\t\tSystem.out.println(\"--------------------\");\n\t\tprintArray2(arr);\n\t}\n\t\n\t/*\n\t\t遍历数组的方法\n\t\t\n\t\t两个明确：\n\t\t\t返回值类型：void\n\t\t\t参数列表：int[] arr\n\t*/\n\tpublic static void printArray(int[] arr) {\n\t\tfor(int x=0; x<arr.length; x++) {\n\t\t\tSystem.out.println(arr[x]);\n\t\t}\n\t}\n\t\n\t//请看改进版本\n\tpublic static void printArray2(int[] arr) {\n\t\tSystem.out.print(\"[\");\n\t\tfor(int x=0; x<arr.length; x++) {\n\t\t\tif(x == arr.length-1) { //这是最后一个元素\n\t\t\t\tSystem.out.println(arr[x]+\"]\");\n\t\t\t}else {\n\t\t\t\tSystem.out.print(arr[x]+\", \");\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n### 数组的操作2获取最值\n\n```\n/*\n\t数组获取最值(获取数组中的最大值最小值)\n\t\n\t分析：\n\t\tA:定义一个数组，并对数组的元素进行静态初始化。\n\t\tB:从数组中任意的找一个元素作为参照物(一般取第一个),默认它就是最大值。\n\t\tC:然后遍历其他的元素，依次获取和参照物进行比较，如果大就留下来，如果小，就离开。\n\t\tD:最后参照物里面保存的就是最大值。\n*/\nclass ArrayTest2 {\n\tpublic static void main(String[] args) {\n\t\t//定义一个数组\n\t\tint[] arr = {34,98,10,25,67};\n\t\t\n\t\t//请获取数组中的最大值\n\t\t/*\n\t\t//从数组中任意的找一个元素作为参照物\n\t\tint max = arr[0];\n\t\t//然后遍历其他的元素\n\t\tfor(int x=1; x<arr.length; x++) {\n\t\t\t//依次获取和参照物进行比较，如果大就留下来，如果小，就离开。\n\t\t\tif(arr[x] > max) {\n\t\t\t\tmax = arr[x];\n\t\t\t}\n\t\t}\n\t\t//最后参照物里面保存的就是最大值。\n\t\tSystem.out.println(\"max:\"+max);\n\t\t*/\n\t\n\t\t//把这个代码用方法改进\n\t\t//调用方法\n\t\tint max = getMax(arr);\n\t\tSystem.out.println(\"max:\"+max);\n\t\t\t\n\t\t//请获取数组中的最小值\n\t\tint min = getMin(arr);\n\t\tSystem.out.println(\"min:\"+min);\n\t}\n\t\n\t/*\n\t\t需求：获取数组中的最大值\n\t\t两个明确：\n\t\t\t返回值类型：int\n\t\t\t参数列表：int[] arr\n\t*/\n\tpublic static int getMax(int[] arr) {\n\t\t//从数组中任意的找一个元素作为参照物\n\t\tint max = arr[0];\n\t\t//然后遍历其他的元素\n\t\tfor(int x=1; x<arr.length; x++) {\n\t\t\t//依次获取和参照物进行比较，如果大就留下来，如果小，就离开。\n\t\t\tif(arr[x] > max) {\n\t\t\t\tmax = arr[x];\n\t\t\t}\n\t\t}\n\t\t//最后参照物里面保存的就是最大值。\n\t\treturn max;\n\t}\n\t\n\tpublic static int getMin(int[] arr) {\n\t\t//从数组中任意的找一个元素作为参照物\n\t\tint min = arr[0];\n\t\t//然后遍历其他的元素\n\t\tfor(int x=1; x<arr.length; x++) {\n\t\t\t//依次获取和参照物进行比较，如果小就留下来，如果大，就离开。\n\t\t\tif(arr[x] < min) {\n\t\t\t\tmin = arr[x];\n\t\t\t}\n\t\t}\n\t\t//最后参照物里面保存的就是最小值。\n\t\treturn min;\n\t}\n}\n```\n\n### 数组的操作3逆序\n\n```\n/*\n\t数组元素逆序 (就是把元素对调)\n\t\n\t分析：\n\t\tA:定义一个数组，并进行静态初始化。\n\t\tB:思路\n\t\t\t把0索引和arr.length-1的数据交换\n\t\t\t把1索引和arr.length-2的数据交换\n\t\t\t...\n\t\t\t只要做到arr.length/2的时候即可。\n*/\nclass ArrayTest3 {\n\tpublic static void main(String[] args) {\n\t\t//定义一个数组，并进行静态初始化。\n\t\tint[] arr = {12,98,50,34,76};\n\t\t\n\t\t//逆序前\n\t\tSystem.out.println(\"逆序前：\");\n\t\tprintArray(arr);\n\t\t\n\t\t//逆序后\n\t\tSystem.out.println(\"逆序后：\");\n\t\t//reverse(arr);\n\t\treverse2(arr);\n\t\tprintArray(arr);\n\t}\n\t\n\t/*\n\t\t需求：数组逆序\n\t\t两个明确：\n\t\t\t返回值类型：void (有人会想到应该返回的是逆序后的数组，但是没必要，因为这两个数组其实是同一个数组)\n\t\t\t参数列表：int[] arr\n\t*/\n\tpublic static void reverse(int[] arr) {\n\t\t/*\n\t\t//第一次交换\n\t\tint temp = arr[0];\n\t\tarr[0] = arr[arr.length-1-0];\n\t\tarr[arr.length-1-0] = temp;\n\t\t\n\t\t//第二次交换\n\t\tint temp = arr[1];\n\t\tarr[1] = arr[arr.length-1-1];\n\t\tarr[arr.length-1-1] = temp;\n\t\t\n\t\t//第三次交换\n\t\tint temp = arr[2];\n\t\tarr[2] = arr[arr.length-1-2];\n\t\tarr[arr.length-1-2] = temp;\n\t\t*/\n\t\t//用循环改进\n\t\tfor(int x=0; x<arr.length/2; x++) {\n\t\t\tint temp = arr[x];\n\t\t\tarr[x] = arr[arr.length-1-x];\n\t\t\tarr[arr.length-1-x] = temp;\n\t\t}\n\t}\n\t\n\tpublic static void reverse2(int[] arr) {\n\t\tfor(int start=0,end=arr.length-1; start<=end; start++,end--) {\n\t\t\tint temp = arr[start];\n\t\t\tarr[start] = arr[end];\n\t\t\tarr[end] = temp;\n\t\t}\n\t}\n\t\n\t//遍历数组\n\tpublic static void printArray(int[] arr) {\n\t\tSystem.out.print(\"[\");\n\t\tfor(int x=0; x<arr.length; x++) {\n\t\t\tif(x == arr.length-1) { //这是最后一个元素\n\t\t\t\tSystem.out.println(arr[x]+\"]\");\n\t\t\t}else {\n\t\t\t\tSystem.out.print(arr[x]+\", \");\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n### 数组的操作4查表法\n\n```\n/*\n\t数组查表法(根据键盘录入索引,查找对应星期)\n\t\t意思是：String[] strArray = {\"星期一\",\"星期二\",...};\n*/\nimport java.util.Scanner;\n\nclass ArrayTest4 {\n\tpublic static void main(String[] args) {\n\t\t//定义一个字符串数组\n\t\tString[] strArray = {\"星期一\",\"星期二\",\"星期三\",\"星期四\",\"星期五\",\"星期六\",\"星期日\"};\n\t\t\n\t\t//创建键盘录入对象\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tSystem.out.println(\"请输入一个数据(0-6)：\");\n\t\tint index = sc.nextInt();\n\t\t\n\t\tSystem.out.println(\"你要查找的日期是：\"+strArray[index]);\n\t}\n}\n```\n\n### 数组的操作5基本查找\n\n```\n/*\n\t需求：数组元素查找(查找指定元素第一次在数组中出现的索引)\n\t\n\t分析：\n\t\tA:定义一个数组，并静态初始化。\n\t\tB:写一个功能实现\n\t\t\t遍历数组，依次获取数组中的每一个元素，和已知的数据进行比较\n\t\t\t如果相等，就返回当前的索引值。\n*/\nclass ArrayTest5 {\n\tpublic static void main(String[] args) {\n\t\t//定义一个数组，并静态初始化\n\t\tint[] arr = {200,250,38,888,444};\n\t\t\n\t\t//需求：我要查找250在这个数组中第一次出现的索引\n\t\tint index = getIndex(arr,250);\n\t\tSystem.out.println(\"250在数组中第一次出现的索引是：\"+index);\n\t\t\n\t\tint index2 = getIndex2(arr,250);\n\t\tSystem.out.println(\"250在数组中第一次出现的索引是：\"+index2);\n\t\t\n\t\tint index3 = getIndex2(arr,2500);\n\t\tSystem.out.println(\"2500在数组中第一次出现的索引是：\"+index3);\n\t}\n\t\n\t/*\n\t\t需求：查找指定数据在数组中第一次出现的索引\n\t\t两个明确：\n\t\t\t返回值类型：int\n\t\t\t参数列表：int[] arr,int value\n\t*/\n\tpublic static int getIndex(int[] arr,int value) {\n\t\t//遍历数组，依次获取数组中的每一个元素，和已知的数据进行比较\n\t\tfor(int x=0; x<arr.length; x++) {\n\t\t\tif(arr[x] == value) {\n\t\t\t\t//如果相等，就返回当前的索引值。\n\t\t\t\treturn x;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//目前的代码有一个小问题\n\t\t//就是假如我要查找的数据在数组中不存在，那就找不到，找不到，你就对应的返回吗?\n\t\t//所以报错。\n\t\t\n\t\t//只要是判断，就可能是false，所以大家要细心。\n\t\t\n\t\t\n\t\t//如果找不到数据，我们一般返回一个负数即可，而且是返回-1\n\t\treturn -1;\n\t}\n\t\n\tpublic static int getIndex2(int[] arr,int value) {\n\t\t//定义一个索引\n\t\tint index = -1;\n\t\t\n\t\t//有就修改索引值\n\t\tfor(int x=0; x<arr.length; x++) {\n\t\t\tif(arr[x] == value) {\n\t\t\t\tindex = x;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//返回index\n\t\treturn index;\n\t}\n}\n```\n\n","tags":["Java系统学习"],"categories":["Java系统学习-JavaSE篇"]},{"title":"再次温习矩阵快速幂的一些思路","url":"/2020/05/19/再次温习矩阵快速幂的一些思路/","content":"\n## 写在前面\n\n因为之前4月份打了将近一个月的个人赛，有些以前学习过的算法已经忘了，所以重新再温习一遍。\n\n<!--more-->\n\n## 关于矩阵快速幂\n\n**矩阵快速幂就是把整数变成矩阵用快速幂来算其次方，比如$A^{n-2}$，其中$A=\\begin{Bmatrix}\n1 & 1\\\\\n 1& 0\n\\end{Bmatrix}$,像这样的就是矩阵快速幂。**\n\n## 矩阵快速幂\n\n### 矩阵的一些名词定义\n\n- $n$阶矩阵：$\\begin{Bmatrix}\n1 & 1\\\\\n 1& 0\n\\end{Bmatrix}$，这就是一个$2∗2$的矩阵，也叫$2$阶矩阵。\n\n- 行向量：只有一行的矩阵，也叫行矩阵，$(a1,a2,...,an)$这就是一个行向量。\n\n- 列向量：只有一列的矩阵，也叫列矩阵，$\\begin{Bmatrix}\na_{1}\\\\\na_{2}\\\\\na_{3}\\\\\n...\\\\\na_{n}\n\\end{Bmatrix}$，这就是一个列向量。\n\n### 矩阵的相关运算\n\n**矩阵加法：**\n\n设有两个$m*n$的矩阵，$A=(a_{ij})$，$B=(b_{ij})$，那么矩阵$A$和$B$的和记做$A+B$。也就是对应相加重新构成的一个矩阵。这里要注意的是，只有当两个矩阵是同型矩阵（也就是行数相等列数也相等）时，这两个矩阵才能进行加法运算。\n\n**矩阵乘法：**\n\n就是对应的第一个矩阵的第一行的第一个数乘以第二个矩阵的第一列的第一个数；\n第一个矩阵的第一行的第二个数乘以第二个矩阵的第一列的第二个数。总结来说就是第一个矩阵的每一行去乘以对应的第二个矩阵的每一列。\n\n**PS1：剩下的许多关于矩阵的知识可以看这篇博客：https://blog.csdn.net/nuoyanli/article/details/105314274**\n\n**PS2：视频讲解可以看这个视频：https://www.bilibili.com/video/BV1gx41127d7?p=1**\n\n## 矩阵快速幂的模板及例题\n\n### 矩阵快速幂的模板\n\n**首先先给出矩阵乘法的模板，这里以51nod-1137为例**\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxx = 1010;\nconst int inf = 0x3f3f3f3f;\nusing namespace std;\nint m1[maxx][maxx], m2[maxx][maxx], m[maxx][maxx];\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int n;\n    cin >> n;\n    memset(m, 0, sizeof(m));\n    for (int i = 1; i <= n; i++)\n        for (int j = 1; j <= n; j++)\n            cin >> m1[i][j];\n    for (int i = 1; i <= n; i++)\n        for (int j = 1; j <= n; j++)\n            cin >> m2[i][j];\n    for (int i = 1; i <= n; i++)\n        for (int j = 1; j <= n; j++)\n            for (int k = 1; k <= n; k++)\n                m[i][j] += m1[i][k] * m2[k][j];\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 1; j <= n; j++)\n            cout << m[i][j] << \" \";\n        cout << endl;\n    }\n    return 0;\n}\n```\n\n**给出矩阵快速幂的模板，这里以51nod-1113为例**\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxx = 110;\nconst int inf = 0x3f3f3f3f;\nconst int mod = 1e9 + 7;\n#define mod(x) ((x) % mod)\nusing namespace std;\nint n;\nstruct mat\n{\n    int m[maxx][maxx];\n} unit; //矩阵\nmat operator*(mat a, mat b)\n{ //重载矩阵乘法\n    mat res;\n    ll x; //可能爆int\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n        {\n            x = 0;\n            for (int k = 0; k < n; k++)\n                x += mod((ll)a.m[i][k] * b.m[k][j]);\n            res.m[i][j] = mod(x);\n        }\n    return res;\n}\nvoid init_unit()\n{ //定义单位矩阵\n    for (int i = 0; i < maxx; i++)\n        unit.m[i][i] = 1;\n    return;\n}\nmat pow_mat(mat a, ll n)\n{ //矩阵快速幂,跟快速幂形式上差不多\n    mat res = unit;\n    while (n)\n    {\n        if (n & 1)\n            res = res * a;\n        a = a * a;\n        n >>= 1;\n    }\n    return res;\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    ll x;\n    init_unit();\n    while (cin >> n >> x)\n    {\n        mat a;\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < n; j++)\n                cin >> a.m[i][j];\n        a = pow_mat(a, x);\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < n; j++)\n            {\n                if (j + 1 == n)\n                    cout << a.m[i][j] << endl;\n                else\n                    cout << a.m[i][j] << \" \";\n            }\n    }\n    return 0;\n}\n```\n\n### 例题：POJ-3070\n\n```\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <deque>\n#include <string>\n#include <vector>\n#include <stdio.h>\n#include <string.h>\n#include <iostream>\ntypedef long long ll;\nconst int maxx = 110;\nconst int inf = 0x3f3f3f3f;\nconst int mod = 1e4;\nusing namespace std;\nint n = 2;\nstruct mat\n{\n    int m[maxx][maxx];\n} unit;\nmat operator*(mat a, mat b)\n{\n    mat res;\n    ll x;\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n        {\n            x = 0;\n            for (int k = 0; k < n; k++)\n                x = (x + a.m[i][k] * b.m[k][j]) % mod;\n            res.m[i][j] = x % mod;\n        }\n    return res;\n}\nvoid init_unit()\n{\n    for (int i = 0; i < maxx; i++)\n        unit.m[i][i] = 1;\n    return;\n}\nmat pow_mat(mat a, ll n)\n{\n    mat res = unit;\n    while (n)\n    {\n        if (n & 1)\n            res = res * a;\n        a = a * a;\n        n >>= 1;\n    }\n    return res;\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    ll x;\n    init_unit();\n    while (cin >> x && x != -1)\n    {\n        mat a;\n        a.m[0][0] = 1;\n        a.m[0][1] = 1;\n        a.m[1][0] = 1;\n        a.m[1][1] = 0;\n        a = pow_mat(a, x);\n        cout << a.m[0][1] << endl;\n    }\n    return 0;\n}\n```\n","tags":["矩阵快速幂再温"],"categories":["算法重温"]},{"title":"Codeforces 628(Div.2)","url":"/2020/05/18/Codeforces 628(Div.2)/","content":"\n### A题\n\n**题意：给你一个数x，求a和b，使得$lcm(a,b)+gcd(a,b)=x$。**\n\n<!--more-->\n\n**思路：这道题的话，直接令a=1,b=x−1，这样$lcm(a,b)=x−1$,$gcd(a,b)=1$，公式成立。**\n\n**AC代码：**\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxx = 100010;\nconst int inf = 0x3f3f3f3f;\nusing namespace std;\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int t;\n    cin >> t;\n    while (t--)\n    {\n        int x;\n        cin >> x;\n        cout << 1 << ' ' << x - 1 << endl;\n    }\n    return 0;\n}\n```\n\n### B题\n\n**题意：给一个长度为n的数组，可以把给定的数组再次接到数组后面使数组长度加n。这个操作可以执行无数次，问能形成的最长上升序列。**\n\n**思路：这道题的话，因为是严格上升子序列，所以每个数至多被选择一次。最后答案即为数组中互不重复的数字个数。**\n\n**AC代码：**\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxx = 100010;\nconst int inf = 0x3f3f3f3f;\nusing namespace std;\nint a[maxx];\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int t;\n    cin >> t;\n    while (t--)\n    {\n        int n;\n        cin >> n;\n        for (int i = 1; i <= n; i++)\n            cin >> a[i];\n        sort(a + 1, a + n + 1);\n        int sum = 0;\n        for (int i = 1; i <= n; i++)\n        {\n            if (a[i] != a[i - 1])\n                sum++;\n        }\n        cout << sum << endl;\n    }\n    return 0;\n}\n```\n\n### C题\n\n**题意：给出你一棵树，但是权值并没有分配，让你构造一种分配的方法来使每一种$u–>v$，即两个节点的路径所经过的权值mex最大值最小。**\n\n**思路：这道题的话，首先先说一下mex的含义，mex这个东西，返回值是这个东西里面出现的最小非负整数，即$mex(1,3)=0$,$mex(0,2)=1$。然后我们用贪心的思路，在输入时记录每个节点被连接的次数，次数越多代表越多的路径会经过它，那么这时候把这条路径改为最大可以赋予的权值就可以使整体的mex尽可能小。又因为要求按输入顺序输出，所以我们是两遍sort，一遍比较节点访问次数来分配权值，一遍比较最初的顺序复原。**\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxx = 100010;\nconst int inf = 0x3f3f3f3f;\nusing namespace std;\nstruct node\n{\n    ll u, v;\n    ll num;\n    ll val;\n    ll pos;\n} edge[maxx];\nll vis[maxx];\nll n;\nbool cmp(node a, node b)\n{\n    a.num = min(vis[a.u], vis[a.v]);\n    b.num = min(vis[b.u], vis[b.v]);\n    return a.num < b.num;\n}\nbool cmp1(node a, node b)\n{\n    return a.pos < b.pos;\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    memset(vis, 0, sizeof(vis));\n    cin >> n;\n    for (int i = 1; i <= n - 1; i++)\n    {\n        cin >> edge[i].u >> edge[i].v;\n        edge[i].pos = i;\n        vis[edge[i].u]++;\n        vis[edge[i].v]++;\n    }\n    sort(edge + 1, edge + n, cmp);\n    for (int i = 1; i <= n - 1; i++)\n        edge[i].val = i - 1;\n    sort(edge + 1, edge + n, cmp1);\n    for (int i = 1; i <= n - 1; i++)\n        cout << edge[i].val << endl;\n    return 0;\n}\n```\n","tags":["CF"],"categories":["CF"]},{"title":"再次温习线段树的一些思路","url":"/2020/05/16/再次温习线段树的一些思路/","content":"\n## 写在前面\n\n因为之前4月份打了将近一个月的个人赛，有些以前学习过的算法已经忘了，所以重新再温习一遍。\n\n<!--more-->\n\n## 关于线段树\n\n**这里提一下完全二叉树。完全二叉树是叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树。若设二叉树的深度为h，除第h层外，其它各层(1～h-1)的结点数都达到最大个数，第h层所有的结点都连续集中在最左边。那么线段树就是完全二叉树，一定条件下成为满二叉树。线段树的主要思想是二分，也就是通过二分的方法来查找节点。假设有编号从1到n的n个点，每个点都存了一些信息，用[L,R]表示下标从L到R的这些点。线段树的用处就是，对编号连续的一些点进行修改或者统计操作，修改和统计的复杂度都是O(log2(n))。**\n\n**线段树的原理，就是，将[1,n]分解成若干特定的子区间(数量不超过4*n),然后，将每个区间[L,R]都分解为少量特定的子区间，通过对这些少量子区间的修改或者统计，来实现快速对[L,R]的修改或者统计。由此看出，用线段树统计的东西，必须符合区间加法，否则，不可能通过分成的子区间来得到[L,R]的统计结果。**\n\n**符合区间加法的例子：**\n\n- 数字之和——总数字之和 = 左区间数字之和 + 右区间数字之和\n\n- 最大公因数(GCD)——总GCD = gcd(左区间GCD,右区间GCD)\n\n- 最大值——总最大值=max(左区间最大值，右区间最大值)\n\n**不符合区间加法的例子：**\n\n- 众数——只知道左右区间的众数，没法求总区间的众数\n\n- 01序列的最长连续零——只知道左右区间的最长连续零，没法知道总的最长连续零\n\n**一个问题，只要能化成对一些连续点的修改和统计问题，基本就可以用线段树来解决。**\n\n## 线段树的原理\n\n**（注：由于线段树的每个节点代表一个区间，以下叙述中不区分节点和区间，只是根据语境需要，选择合适的词）**\n\n线段树本质上是维护下标为1,2,..,n的n个按顺序排列的数的信息，所以，其实是“点树”，是维护n的点的信息，至于每个点的数据的含义可以有很多，\n在对线段操作的线段树中，每个点代表一条线段，在用线段树维护数列信息的时候，每个点代表一个数，但本质上都是每个点代表一个数。以下，在讨论线段树的时候，区间[L,R]指的是下标从L到R的这(R-L+1)个数，而不是指一条连续的线段。只是有时候这些数代表实际上一条线段的统计结果而已。\n\n线段树是将每个区间[L,R]分解成[L,M]和[M+1,R] (其中M=(L+R)/2 这里的除法是整数除法，即对结果下取整)直到 L==R 为止。\n\n开始时是区间[1,n] ,通过递归来逐步分解，假设根的高度为1的话，树的最大高度为![tupian1](https://img-blog.csdn.net/20150908232141714)（n>1）。\n\n线段树对于每个n的分解是唯一的，所以n相同的线段树结构相同，这也是实现可持久化线段树的基础。\n\n下图展示了区间[1,13]的分解过程：\n\n![tupian2](https://img-blog.csdn.net/20150908231214395?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n上图中，每个区间都是一个节点，每个节点存自己对应的区间的统计信息。\n\n### 线段树的点修改\n\n假设要修改[5]的值，可以发现，每层只有一个节点包含[5],所以修改了[5]之后，只需要每层更新一个节点就可以线段树每个节点的信息都是正确的，所以修改次数的最大值为层数![tupian3](https://img-blog.csdn.net/20150908232141714)。\n\n复杂度O(log2(n))\n\n### 线段树的区间修改\n\n在写线段树的区间修改的时候，我们需要先掌握一个知识点，就是懒惰标记。\n\n**什么是懒惰标记？**\n\n试想，我们在操作的时候有可能有这样的操作。首先进行区间修改，修改了800次，然后再进行一次查询。这样，如果我们每次都将整个线段树的数据进行更新，实际上是非常慢的，如果我们能用一段空间，来记录修改数据，只有在使用的时候，一次性更新，就非常的方便。\n\n所以这也是懒惰标记的作用。可以先对修改的数据进行储存，只有在使用的时候才更新线段树。那么，理论上我们应该建一个跟线段树同样大小的数组，称为懒惰数组，表示了每个节点的懒惰标记。有这样的操作：\n\n- 1.修改数据的时候，每次递归到某节点，修改数据以后将数据的变化添加到数组中。\n\n- 2.当使用到这个节点的时候，发现对应的懒惰标记存在，那么就应该更新该节点，以及以下的所有节点的数据，方便使用。\n\n总之，就是不使用的时候就一直在积累，在使用的时候再统一更新。\n\n那么懒惰数组的更新非常简单，对线段树更新的时候就可以添加到懒惰标记，但是在使用的时候，我们需要用一个函数来完成懒惰标记的下推操作，也就是更新积累的值。代码：\n\n```\nvoid Pushdown(int rt, int l, int r) //下推标记的函数。l,r为左子树，右子树的数字数量\n{\n    if (lz[rt])\n    {\n        //下推标记\n        lz[rt << 1] += lz[rt];\n        lz[rt << 1 | 1] += lz[rt];\n        //修改子节点的Sum使之与对应的lz相对应\n        //int mid=(l+r)>>1;与下面Update_tree_interval函数中Pushdown(rt,l,r)对应\n        Sum[rt << 1] += lz[rt] * l;     //Sum[rt<<1]+=(mid-l+1)*lz[rt];与下面Update_tree_interval函数中Pushdown(rt,l,r)对应\n        Sum[rt << 1 | 1] += lz[rt] * r; //Sum[rt<<1|1]+=(r-mid)*lz[rt];与下面Update_tree_interval函数中Pushdown(rt,l,r)对应\n        //清除本节点标记\n        lz[rt] = 0;\n    }\n}\n```\n\nlz数组，即lazy，就是懒惰标记数组。可以看出，当lz[rt]存在值的时候，就说明现在我在使用这个节点，而这个节点以及其下的节点需要更新了，所以就利用二叉树的性质向下传递更新数据，同时更新线段树中的数据。最终，要将该节点的懒惰标记清零。\n\n注意，下推的时候不是一直更新到叶子节点，而是只更新当前节点以及2个子树，因为实际操作的时候，只要碰到对某节点的操作就要调用Pushdown()函数，所以每次只用下推一层即可。\n\nPushdown()函数的使用需要在下面的区间操作中添加。\n\n**区间修改：**\n\n单点更新类似二分查找，更新的时候对经过的路径进行操作就可以了。但是区间更新需要考虑整个区间。线段树除了叶子节点，都表示了一段区间的值，那么就要配合懒惰标记在整个区间上进行操作。\n\n### 线段树的区间查询\n\n区间查询的原理跟区间更新基本一样，也是看结点表示的数据范围有不同的操作。同样，在到某个结点的时候一定要调用Pushdown()。不同点在于跟数据操作无关，但是需要一个sum来储存收集到的区间数据，同时最后return。这样在递归完成以后最后返回的就是区间和了。理解区间修改后，区间查询就容易的多了。\n\n### 线段树的储存结构\n\n线段树是用数组来模拟树形结构，对于每一个节点R ,左子节点为 2 * R (一般写作R<<1)右子节点为 2 * R+1（一般写作R<<1|1）\n\n然后以1为根节点，所以，整体的统计信息是存在节点1中的。\n\n这么表示的原因看下图就很明白了，左子树的节点标号都是根节点的两倍，右子树的节点标号都是左子树+1：\n\n![tupian4](https://img-blog.csdn.net/20150909010827440?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n线段树需要的数组元素个数很大，一般都开4倍空间，比如： int Sum[maxx<<2];\n\n### 脱离lazy数组\n\nlazy数组的使用在很大程度将降低了解决问题所耗费的时间，但是也增加了对模板的修改难度。诚然，lazy很实用，但是在一些问题的构造上并不容易修改。我们平常的区间修改，整个区间的数值变化是统一的，所以我们能够在数学上提前好多个结点先算出来更改情况。但是有很多问题并不是这样的。\n\n例如：hdu4027。11年上海网络赛，要求区间内对每个节点的数值取其二次根。那么再考虑lazy数组就是徒生烦恼。如果我们抛弃lazy数组，直接每次都更新到叶子结点，同时考虑剪枝，速度也并不慢（500ms）。所以，在区间操作不平衡，同时可以剪枝的情况下，完全可以抛弃lazy数组，从而修改为：\n\n```\nboolean cleck(int rt,int l,int r){\n    // 剪枝条件\n}\n \nvoid Update_tree_interval(int rt, int l, int r, int L, int R) {\n    if (L == R) {\n        Sum[rt] = 1; // 更新方式\n        return;\n    }\n    int mid = (L + R) / 2;\n    if (mid >= l && cleck(rt << 1,L,mid))\n    Update_tree_interval(rt << 1, l, r, L, mid);\n    if (mid < r && cleck(rt << 1 | 1,mid+1,R))\n    Update_tree_interval(rt << 1 | 1, l, r, mid + 1, R);\n    Pushup(rt);\n}\n```\n\n## 线段树实现代码\n\n### 首先：定义\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxx = 10010;\nconst int inf = 0x3f3f3f3f;\nusing namespace std;\nint A[maxx];        //存原数组数据下标[1,n]\nint Sum[maxx << 2]; //Sum求和\nint lz[maxx << 2];  //lz为懒惰标记\n```\n\n### 初始化\n\n```\nvoid init()//初始化\n{\n    memset(Sum,0,sizeof(Sum));\n}\n```\n\n### 建树\n\n```\nvoid Pushup(int rt) //Pushup函数更新节点\n{\n    Sum[rt] = Sum[rt << 1] + Sum[rt << 1 | 1];\n}\nvoid Build_tree(int l, int r, int rt) //建树,l,r表示当前节点区间，rt表示当前节点编号\n{\n    if (l == r) //若到达叶节点\n    {\n        Sum[rt] = A[l];//cin>>Sum[rt];\n        return;\n    }\n    int mid = (l + r) >> 1;\n    Build_tree(l, mid, rt << 1);\n    Build_tree(mid + 1, r, rt << 1 | 1);\n    Pushup(rt);\n}\n```\n\n这样的建树，是一个递归的过程。l与r分别表示区间，结合上面的图，当l==r的时候说明递归已经遍历到叶子节点了，而这个节点rt也是二叉树的节点编号。对应了数组的下标。所以进行赋值。然后直接return进行回溯。那么在正常递归的时候，我们需要利用二叉树的性质，即对于rt编号的节点而言，左子树编号为rt<<1，右子树为rt<<1|1。同样，由于二分的性质，利用mid = (l+r)/2，就可以获取下一个子树的区间范围。\n\n在回溯的时候，是从树的最下层开始向最上层回溯，那么同样利用二叉树的性质，我们可以轻松将子树的数据加到父节点上。这样，当函数完成的时候，我们就可以利用数组来构建了一个线段树。\n\n### 懒惰标记，下推操作\n\n```\nvoid Pushdown(int rt, int l, int r) //下推标记的函数。l,r为左子树，右子树的数字数量\n{\n    if (lz[rt])\n    {\n        //下推标记\n        lz[rt << 1] += lz[rt];\n        lz[rt << 1 | 1] += lz[rt];\n        //修改子节点的Sum使之与对应的lz相对应\n        //int mid=(l+r)>>1;与下面Update_tree_interval函数中Pushdown(rt,l,r)对应\n        Sum[rt << 1] += lz[rt] * l;     //Sum[rt<<1]+=(mid-l+1)*lz[rt];与下面Update_tree_interval函数中Pushdown(rt,l,r)对应\n        Sum[rt << 1 | 1] += lz[rt] * r; //Sum[rt<<1|1]+=(r-mid)*lz[rt];与下面Update_tree_interval函数中Pushdown(rt,l,r)对应\n        //清除本节点标记\n        lz[rt] = 0;\n    }\n}\n```\n\n### 单点修改\n\n线段树并不必须要进行区间的操作，如果是对单点进行操作，完全可以用更快的方法来实现。而对于单点修改而言，其实相比区间修改的代码要简单很多（因为lazy数组的存在），所以能用针对单点的修改最好不要用区间修改。单点更新非常类似二分查找，通过递归找到更新点的位置，在回溯的时候更新所有节点的值。\n\n```\nvoid Update_tree_point(int l, int r, int rt, int a, int b) //点修改，假设A[a]=b,l,r表示当前节点区间，rt表示当前节点编号，a为更新点，b为更新值\n{\n    if (l == r) //到叶节点，修改\n    {\n        A[a] = b;\n        Sum[rt] = b;\n        return;\n    }\n    int mid = (l + r) >> 1;\n    //根据条件判断往左子树调用还是往右\n    // Pushdown(rt,mid-l+1,r-mid); 若既有点更新又有区间更新，需要这句话\n    if (a <= mid)\n        Update_tree_point(l, mid, rt << 1, a, b);\n    else\n        Update_tree_point(mid + 1, r, rt << 1 | 1, a, b);\n    Pushup(rt);\n}\n```\n\n### 区间修改\n\n```\nvoid Update_tree_interval(int L, int R, int l, int r, int rt, int b) //区间修改，假设A[L,R]=b,L,R表示操作区间，l,r表示当前节点区间，rt表示当前节点编号,b为更新值\n{\n    if (L <= l && r <= R) //如果本区间完全在操作区间[L,R]以内\n    {\n        Sum[rt] += b * (r - l + 1);\n        lz[rt] += b; //增加lz标记，表示本区间的Sum正确，子区间的Sum仍需要根据lz的值来调整\n        return;\n    }\n    int mid = (l + r) >> 1;\n    Pushdown(rt, mid - l + 1, r - mid); //Pushdown(rt,l,r);//下推标记\n    //这里判断左右子树跟[L,R]有无交集，有交集才递归\n    if (L <= mid)\n        Update_tree_interval(L, R, l, mid, rt << 1, b);\n    if (R > mid)\n        Update_tree_interval(L, R, mid + 1, r, rt << 1 | 1, b);\n    Pushup(rt); //更新本节点信息\n}\n```\n\n### 区间查询\n\n```\nll Query_tree(int L, int R, int l, int r, int rt) //区间查询，L,R表示操作区间，l,r表示当前节点区间，rt表示当前节点编号\n{\n    if (L <= l && r <= R)\n    {\n        //在区间内，直接返回\n        return Sum[rt];\n    }\n    int mid = (l + r) >> 1;\n    //下推标记，否则Sum可能不正确\n    Pushdown(rt, mid - l + 1, r - mid); //Pushdown(rt,l,r);\n    ll sum = 0; //累计答案\n    if (L <= mid)\n        sum += Query_tree(L, R, l, mid, rt << 1);\n    if (R > mid)\n        sum += Query_tree(L, R, mid + 1, r, rt << 1 | 1);\n    return sum;\n}\n```\n\n## 线段树模板\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxx = 10010;\nconst int inf = 0x3f3f3f3f;\nusing namespace std;\nint A[maxx];        //存原数组数据下标[1,n]\nint Sum[maxx << 2]; //Sum求和\nint lz[maxx << 2];  //lz为懒惰标记\n\nvoid init()//初始化\n{\n    memset(Sum,0,sizeof(Sum));\n}\n\nvoid Pushup(int rt) //Pushup函数更新节点\n{\n    Sum[rt] = Sum[rt << 1] + Sum[rt << 1 | 1];\n}\n\nvoid Pushdown(int rt, int l, int r) //下推标记的函数。l,r为左子树，右子树的数字数量\n{\n    if (lz[rt])\n    {\n        //下推标记\n        lz[rt << 1] += lz[rt];\n        lz[rt << 1 | 1] += lz[rt];\n        //修改子节点的Sum使之与对应的lz相对应\n        //int mid=(l+r)>>1;与下面Update_tree_interval函数中Pushdown(rt,l,r)对应\n        Sum[rt << 1] += lz[rt] * l;     //Sum[rt<<1]+=(mid-l+1)*lz[rt];与下面Update_tree_interval函数中Pushdown(rt,l,r)对应\n        Sum[rt << 1 | 1] += lz[rt] * r; //Sum[rt<<1|1]+=(r-mid)*lz[rt];与下面Update_tree_interval函数中Pushdown(rt,l,r)对应\n        //清除本节点标记\n        lz[rt] = 0;\n    }\n}\n\nvoid Build_tree(int l, int r, int rt) //建树,l,r表示当前节点区间，rt表示当前节点编号\n{\n    if (l == r) //若到达叶节点\n    {\n        Sum[rt] = A[l];//cin>>Sum[rt];\n        return;\n    }\n    int mid = (l + r) >> 1;\n    Build_tree(l, mid, rt << 1);\n    Build_tree(mid + 1, r, rt << 1 | 1);\n    Pushup(rt);\n}\n\nvoid Update_tree_point(int l, int r, int rt, int a, int b) //点修改，假设A[a]=b,l,r表示当前节点区间，rt表示当前节点编号，a为更新点，b为更新值\n{\n    if (l == r) //到叶节点，修改\n    {\n        A[a] = b;\n        Sum[rt] = b;\n        return;\n    }\n    int mid = (l + r) >> 1;\n    //根据条件判断往左子树调用还是往右\n    // Pushdown(rt,mid-l+1,r-mid); 若既有点更新又有区间更新，需要这句话\n    if (a <= mid)\n        Update_tree_point(l, mid, rt << 1, a, b);\n    else\n        Update_tree_point(mid + 1, r, rt << 1 | 1, a, b);\n    Pushup(rt);\n}\n\nvoid Update_tree_interval(int L, int R, int l, int r, int rt, int b) //区间修改，假设A[L,R]=b,L,R表示操作区间，l,r表示当前节点区间，rt表示当前节点编号,b为更新值\n{\n    if (L <= l && r <= R) //如果本区间完全在操作区间[L,R]以内\n    {\n        Sum[rt] += b * (r - l + 1);\n        lz[rt] += b; //增加lz标记，表示本区间的Sum正确，子区间的Sum仍需要根据lz的值来调整\n        return;\n    }\n    int mid = (l + r) >> 1;\n    Pushdown(rt, mid - l + 1, r - mid); //Pushdown(rt,l,r);//下推标记\n    //这里判断左右子树跟[L,R]有无交集，有交集才递归\n    if (L <= mid)\n        Update_tree_interval(L, R, l, mid, rt << 1, b);\n    if (R > mid)\n        Update_tree_interval(L, R, mid + 1, r, rt << 1 | 1, b);\n    Pushup(rt); //更新本节点信息\n}\n\nll Query_tree(int L, int R, int l, int r, int rt) //区间查询，L,R表示操作区间，l,r表示当前节点区间，rt表示当前节点编号\n{\n    if (L <= l && r <= R)\n    {\n        //在区间内，直接返回\n        return Sum[rt];\n    }\n    int mid = (l + r) >> 1;\n    //下推标记，否则Sum可能不正确\n    Pushdown(rt, mid - l + 1, r - mid); //Pushdown(rt,l,r);\n    ll sum = 0; //累计答案\n    if (L <= mid)\n        sum += Query_tree(L, R, l, mid, rt << 1);\n    if (R > mid)\n        sum += Query_tree(L, R, mid + 1, r, rt << 1 | 1);\n    return sum;\n}\n```\n\n## 例题：HDU-1166\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxx = 50010;\nconst int inf = 0x3f3f3f3f;\nusing namespace std;\nint A[maxx];        //存原数组数据下标[1,n]\nint Sum[maxx << 2]; //Sum求和\nint lz[maxx << 2];  //lz为懒惰标记\nvoid Pushup(int rt) //Pushup函数更新节点\n{\n    Sum[rt] = Sum[rt << 1] + Sum[rt << 1 | 1];\n}\nvoid Build_tree(int l, int r, int rt) //建树,l,r表示当前节点区间，rt表示当前节点编号\n{\n    if (l == r) //若到达叶节点\n    {\n        Sum[rt] = A[l];// //cin>>Sum[rt];\n        return;\n    }\n    int mid = (l + r) >> 1;\n    Build_tree(l, mid, rt << 1);\n    Build_tree(mid + 1, r, rt << 1 | 1);\n    Pushup(rt);\n}\nvoid Update_tree_point(int l, int r, int rt, int a, int b) //点修改，假设A[a]=b,l,r表示当前节点区间，rt表示当前节点编号，a为更新点，b为更新值\n{\n    if (l == r) //到叶节点，修改\n    {\n        //A[a] = b;\n        Sum[rt] += b;\n        return;\n    }\n    int mid = (l + r) >> 1;\n    //根据条件判断往左子树调用还是往右\n    if (a <= mid)\n        Update_tree_point(l, mid, rt << 1, a, b);\n    else\n        Update_tree_point(mid + 1, r, rt << 1 | 1, a, b);\n    Pushup(rt);\n}\nll Query_tree(int L, int R, int l, int r, int rt) //区间查询，L,R表示操作区间，l,r表示当前节点区间，rt表示当前节点编号\n{\n    if (L <= l && r <= R)\n    {\n        //在区间内，直接返回\n        return Sum[rt];\n    }\n    int mid = (l + r) >> 1;\n    ll sum = 0; //累计答案\n    if (L <= mid)\n        sum += Query_tree(L, R, l, mid, rt << 1);\n    if (R > mid)\n        sum += Query_tree(L, R, mid + 1, r, rt << 1 | 1);\n    return sum;\n}\nint main()\n{\n    int t;\n    scanf(\"%d\", &t);\n    string s;\n    int cnt = 0;\n    while (t--)\n    {\n        ++cnt;\n        printf(\"Case %d:\\n\", cnt);\n        int n;\n        scanf(\"%d\", &n);\n        for (int i = 1; i <= n; i++)\n            scanf(\"%d\", &A[i]);\n        Build_tree(1, n, 1);\n        int x, y;\n        cin >> s;\n        while (s != \"End\")\n        {\n            scanf(\"%d%d\", &x, &y);\n            if (s == \"Query\")\n            {\n                printf(\"%d\\n\", Query_tree(x, y, 1, n, 1));\n            }\n            else if (s == \"Add\")\n            {\n                Update_tree_point(1, n, 1, x, y);\n            }\n            else if (s == \"Sub\")\n            {\n                Update_tree_point(1, n, 1, x, -y);\n            }\n            cin >> s;\n        }\n    }\n    return 0;\n}\n```\n\n## 线段树应用：扫描线求矩形面积并\n\n分析:\n\n1.矩形比较多，坐标也很大，所以横坐标需要离散化（纵坐标不需要），熟悉离散化后这个步骤不难，所以这里不详细讲解了，不明白的还请百度。\n\n2.重点：扫描线法：假想有一条扫描线，从左往右（从右往左），或者从下往上（从上往下）扫描过整个多边形（或者说畸形。。多个矩形叠加后的那个图形）。如果是竖直方向上扫描，则是离散化横坐标，如果是水平方向上扫描，则是离散化纵坐标。下面的分析都是**离散化横坐标的，并且从下往上扫描的。**\n\n扫描之前还需要做一个工作，就是保存好所有矩形的上下边，并且按照它们所处的高度进行排序，另外如果是上边我们给他一个值-1，下边给他一个值1，我们用一个结构体来保存所有的上下边。\n\n```\nstruct segment\n{\ndouble l,r,h;   //l，r表示这条上下边的左右坐标，h是这条边所处的高度\nint f;   //所赋的值，1或-1\n}\n```\n\n接着扫描线从下往上扫描，每遇到一条上下边就停下来，将这条线段投影到总区间上 **（总区间就是整个多边形横跨的长度）** ，这个投影对应的其实是个插入和删除线段操作。 **还记得给他们赋的值1或-1吗，下边是1，扫描到下边的话相当于往总区间插入一条线段，上边-1，扫描到上边相当于在总区间删除一条线段** （如果说插入删除比较抽象，那么就直白说，扫描到下边，投影到总区间，对应的那一段的值都要增1，扫描到上边对应的那一段的值都要减1， **如果总区间某一段的值为0，说明其实没有线段覆盖到它，为正数则有，那会不会为负数呢？是不可能的，** 可以自己思考一下）。\n\n每扫描到一条上下边后并投影到总区间后，就判断总区间现在被覆盖的总长度，然后用下一条边的高度减去当前这条边的高度，乘上总区间被覆盖的长度，就能得到一块面积，并依此做下去，就能得到最后的面积\n\n（这个过程其实一点都不难，只是看文字较难体会，建议纸上画图，一画即可明白，下面献上一图希望有帮助）\n\n![tupian6](https://images0.cnblogs.com/blog/406771/201304/12153052-27995daa57e94349a42362435b3d975c.jpg)\n\n## 扫描线求矩形面积并的例题：POJ-1151 \n\n题目给了n个矩形，每个矩形给了左下角和右上角的坐标，矩形可能会重叠，求的是矩形最后的面积。因为变化范围比较大，我们要用到离散化，离散化就不说了，重点说一说扫描线的过程：\n\n下面有个矩形\n\n![tupian7](https://img-blog.csdn.net/20130726113250031?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQva2szMDM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n现在假设我们有一根线，从下往上开始扫描 \n\n![tupian8](https://img-blog.csdn.net/20130726113310406?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQva2szMDM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n![tupian9](https://img-blog.csdn.net/20130726113323484?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQva2szMDM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n![tupian10](https://img-blog.csdn.net/20130726113335390?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQva2szMDM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n![tupian11](https://img-blog.csdn.net/20130726113346718?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQva2szMDM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n![tupian12](https://img-blog.csdn.net/20130726113358093?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQva2szMDM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n![tupian13](https://img-blog.csdn.net/20130726113407109?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQva2szMDM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n如图所示，我们可以把整个矩形分成如图各个颜色不同的小矩形，那么这个小矩形的高就是我们扫过的距离，那么剩下了一个变量，那就是矩形的长一直在变化。\n\n我们的线段树就是为了维护矩形的长，我们给每一个矩形的上下边进行标记，下面的边标记为1，上面的边标记为-1，每遇到一个矩形时，我们知道了标记为1的边，我们就加进来这一条矩形的长，等到扫描到-1时，证明这一条边需要删除，就删去，利用1和-1可以轻松的到这种状态。\n\n还要注意这里的线段树指的并不是线段的一个端点，而指的是一个区间，所以我们要计算的时候r+1和r-1\n\n再提一下离散化，离散化就是把一段很大的区间映射到一个小区间内，这样会节省大量空间，要进行离散化，我们先对端点进行排序，然后去重，然后二分找值就可以了\n具体的请结合代码分析：\n\n```\n#include <cstdio>\n#include <cstring>\n#include <cctype>\n#include <string>\n#include <set>\n#include <iostream>\n#include <stack>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#define mem(a,b) memset(a,b,sizeof(a))\n#define inf 0x3f3f3f3f\n#define N 220\n#define ll long long\nusing namespace std;\n#define lson l,m,rt<<1\n#define rson m+1,r,rt<<1|1\nstruct Seg\n{\n    double l,r,h;\n    int f;\n    Seg() {}\n    Seg(double a,double b,double c,int d):l(a),r(b),h(c),f(d) {}\n    bool operator < (const Seg &cmp) const\n    {\n        return h<cmp.h;\n    }\n} e[N];\nstruct node\n{\n    int cnt;\n    double len;\n} t[N<<2];\ndouble X[N];\nvoid pushdown(int l,int r,int rt)\n{\n    if(t[rt].cnt)//当前的边被标记，就把当前的长度加上\n        t[rt].len=X[r+1]-X[l];\n    else if(l==r)//当为一个点的时候长度为0\n        t[rt].len=0;\n    else//其他情况把左右两个区间的值加上\n        t[rt].len=t[rt<<1].len+t[rt<<1|1].len;\n}\nvoid update(int L,int R,int l,int r,int rt,int val)\n{\n    if(L<=l&&r<=R)\n    {\n        t[rt].cnt+=val;//加上标记的值\n        pushdown(l,r,rt);//像下更新节点\n        return;\n    }\n    int m=(l+r)>>1;\n    if(L<=m) update(L,R,lson,val);\n    if(R>m) update(L,R,rson,val);\n    pushdown(l,r,rt);\n}\nint main()\n{\n    int n,q=1;\n    double a,b,c,d;\n    while(~scanf(\"%d\",&n)&&n)\n    {\n        mem(t,0);\n        int num=0;\n        for(int i=0; i<n; i++)\n        {\n            scanf(\"%lf%lf%lf%lf\",&a,&b,&c,&d);\n            X[num]=a;\n            e[num++]=Seg(a,c,b,1);//矩形下面用1来标记吗\n            X[num]=c;\n            e[num++]=Seg(a,c,d,-1);//上面用-1来标记\n        }\n        sort(X,X+num);//用于离散化\n        sort(e,e+num);//把矩形的边的纵坐标从小到大排序\n        int m=unique(X,X+num)-X;\n        double ans=0;\n        for(int i=0; i<num; i++)\n        {\n            int l=lower_bound(X,X+m,e[i].l)-X;//找出离散化以后的值\n            int r=lower_bound(X,X+m,e[i].r)-X-1;\n            update(l,r,0,m,1,e[i].f);\n            ans+=t[1].len*(e[i+1].h-e[i].h);\n        }\n        printf(\"Test case #%d\\nTotal explored area: %.2lf\\n\\n\",q++,ans);\n    }\n    return 0;\n}\n```\n\n","tags":["线段树再温"],"categories":["算法重温"]},{"title":"JavaSE-Day(4)学习笔记","url":"/2020/05/14/JavaSE-Day(4)学习笔记/","content":"\n### 选择结构switch语句的格式及其解释\n\n<!--more-->\n\n``` \n1:switch语句(掌握)\n\t(1)格式：\n\t\tswitch(表达式) {\n\t\t\tcase 值1:\n\t\t\t\t语句体1;\n\t\t\t\tbreak;\n\t\t\tcase 值2:\n\t\t\t\t语句体2;\n\t\t\t\tbreak;\n\t\t\t...\n\t\t\tdefault:\n\t\t\t\t语句体n+1;\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\t格式解释说明：\n\t\t\tswitch:说明这是switch语句。\n\t\t\t表达式:可以是byte,short,int,char\n\t\t\t\tJDK5以后可以是枚举\n\t\t\t\tJDK7以后可以是字符串\n\t\t\tcase:后面的值就是要和表达式进行比较的值\n\t\t\tbreak:表示程序到这里中断，跳出switch语句\n\t\t\tdefault:如果所有的情况都不匹配,就执行这里,相当于if语句中的else\n\t(2)面试题\n\t\tswitch语句的表达式可以是byte吗?可以是long吗?可以是String吗?\n\t\t\t可以,不可以,JDK7以后可以\n```\n\n### 选择结构switch语句的基本实用\n\n```\npackage stephencurry;\nimport java.util.*;\nimport java.math.*;\nimport java.io.*;\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n        Scanner sc = new Scanner(System.in);\n        System.out.println(\"请输入一个整数：\");\n        int week = sc.nextInt();\n        switch(week)\n        {\n        case 1:\n        \tSystem.out.println(\"星期一\");\n        \tbreak;\n        case 2:\n\t\t\tSystem.out.println(\"星期二\");\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tSystem.out.println(\"星期三\");\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tSystem.out.println(\"星期四\");\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tSystem.out.println(\"星期五\");\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tSystem.out.println(\"星期六\");\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tSystem.out.println(\"星期日\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tSystem.out.println(\"你输入的数据有误\");\n\t\t\tbreak;\n        }\n\t}\n}\n\n```\n\n### 选择结构switch语句的注意事项\n\n**注意事项：**\nA:case后面只能是常量，不能是变量，而且，多个case后面的值不能出现相同的\nB:default可以省略吗?\n可以省略，但是不建议，因为它的作用是对不正确的情况给出提示。\n特殊情况：\ncase就可以把值固定。\nA,B,C,D\nC:break可以省略吗?\n可以省略，但是结果可能不是我们想要的。\n会出现一个现象：case穿透。\n最终我们建议不要省略\nD:default一定要在最后吗?\n不是，可以在任意位置。但是建议在最后。\nE:switch语句的结束条件\na:遇到break就结束了\nb:执行到末尾就结束了\n\n```\nimport java.util.Scanner;\n\nclass SwitchDemo2 {\n\tpublic static void main(String[] args) {\n\t\t//创建键盘录入对象\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\t//控制键盘录入数据\n\t\tSystem.out.println(\"请输入一个数据(1-7):\");\n\t\tint week = sc.nextInt(); //3\n\t\t\n\t\t//定义常量\n\t\t//int number = 3;\n\t\t//然后把case后面的值改为number，就会报错\n\t\t\n\t\t//switch判断语句\n\t\tswitch(week) {\n\t\t\tcase 1:\n\t\t\t\tSystem.out.println(\"星期一\");\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tSystem.out.println(\"星期二\");\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tSystem.out.println(\"星期三\");\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tSystem.out.println(\"星期四\");\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tSystem.out.println(\"星期五\");\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tSystem.out.println(\"星期六\");\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\tSystem.out.println(\"星期日\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tSystem.out.println(\"你输入的数据有误\");\n\t\t\t\t//break;\n\t\t}\n\t}\n}\n```\n\n### 选择结构switch语句练习1看程序写结果\n\n```\n/*\n\t看程序写结果\n*/\nclass SwitchTest {\n\tpublic static void main(String[] args) {\n\t\tint x = 2;\n\t\tint y = 3;\n\t\tswitch(x){\n\t\t\tdefault:\n\t\t\t\ty++;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\ty++;\n\t\t\tcase 4:\n\t\t\t\ty++;\n\t\t}\n\t\tSystem.out.println(\"y=\"+y);\n\t\tSystem.out.println(\"---------------\");\n\t\t\n\t\tint a = 2;\n\t\tint b = 3;\n\t\tswitch(a){\n\t\t\tdefault:\n\t\t\t\tb++;\n\t\t\tcase 3:\n\t\t\t\tb++;\n\t\t\tcase 4:\n\t\t\t\tb++;\n\t\t}\n\t\tSystem.out.println(\"b=\"+b);\n\t}\n}\n\n结果是：y=4；b=6\n```\n\n### 选择结构switch语句练习2单项选择题\n\n```\n/*\n\t模拟单项选择题。\n\t\n\t分析：\n\t\tA:出一个选择题，然后供你选择。\n\t\tB:键盘录入选择的数据。\n\t\tC:根据选择来给出你选择的结论。\n*/\nimport java.util.Scanner;\n\nclass SwitchTest2 {\n\tpublic static void main(String[] args) {\n\t\t//出一个选择题，然后供你选择。\n\t\t//由于我们现在没有办法键盘录入得到一个'A','B'\n\t\t//这样的东西，我就用65，66这样的值替代\n\t\t//将来我们获取到这样的值以后，强制转换为字符类型\n\t\tSystem.out.println(\"下面的几个人你最爱谁?\");\n\t\tSystem.out.println(\"65 林青霞\");\n\t\tSystem.out.println(\"66 张曼玉\");\n\t\tSystem.out.println(\"67 刘德华\");\n\t\tSystem.out.println(\"68 王力宏\");\n\t\t\n\t\t//键盘录入选择的数据。\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tSystem.out.println(\"请输入你的选择：\");\n\t\tint choiceNumber = sc.nextInt();\n\t\t\n\t\t//强制转换为字符类型\n\t\tchar choice = (char) choiceNumber;\n\t\t\n\t\tswitch(choice) {\n\t\t\tcase 'A':\n\t\t\t\tSystem.out.println(\"恭喜你,选择正确\");\n\t\t\t\tbreak;\n\t\t\tcase 'B':\n\t\t\t\tSystem.out.println(\"不好意思，你选择有误\");\n\t\t\t\tbreak;\n\t\t\tcase 'C':\n\t\t\t\tSystem.out.println(\"不好意思，你选择有误\");\n\t\t\t\tbreak;\n\t\t\tcase 'D':\n\t\t\t\tSystem.out.println(\"不好意思，你选择有误\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tSystem.out.println(\"没有该选项\");\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n```\n\n### 选择结构switch语句练习3表达式求字符串\n\n```\n/*\n\t根据你键盘录入的字符串，判断是否有满足要求的，如果有就输出。\n\t否则，提示有误。\n\t\n\tString s = sc.nextLine();\n*/\nimport java.util.Scanner;\n\nclass SwitchTest3 {\n\tpublic static void main(String[] args) {\n\t\t//创建键盘录入对象\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\t//录入数据\n\t\tSystem.out.println(\"请输入你要判断的字符串：\");\n\t\tString s = sc.nextLine();\n\t\t\n\t\tswitch(s) {\n\t\t\tcase \"hello\":\n\t\t\t\tSystem.out.println(\"你输入的是hello\");\n\t\t\t\tbreak;\n\t\t\tcase \"world\":\n\t\t\t\tSystem.out.println(\"你输入的是world\");\n\t\t\t\tbreak;\n\t\t\tcase \"java\":\n\t\t\t\tSystem.out.println(\"你输入的是java\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tSystem.out.println(\"没有找到你输入的数据\");\n\t\t\t\t//break;\n\t\t}\n\t}\n}\n```\n\n### 选择结构switch和if语句的各自使用场景\n\n```\n/*\n\t用switch语句实现键盘录入月份，输出对应的季节\n\t\n\t分析：\n\t\tA:键盘录入一个月份，用Scanner实现\n\t\tB:用switch语句实现即可\n\t\t\n\tif语句和switch语句的区别?\n\t\tif语句：\n\t\t\tA:针对结果是boolean类型的判断\n\t\t\tB:针对一个范围的判断\n\t\t\tC:针对几个常量值的判断\n\t\t\n\t\tswitch语句：\n\t\t\t针对几个常量值的判断\n*/\nimport java.util.Scanner;\n\nclass SwitchTest4 {\n\tpublic static void main(String[] args) {\n\t\t//创建键盘录入对象\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\t//录入数据\n\t\tSystem.out.println(\"请输入月份(1-12)：\");\n\t\tint month = sc.nextInt();\n\t\t\n\t\t/*\n\t\tswitch(month) {\n\t\t\tcase 1:\n\t\t\t\tSystem.out.println(\"冬季\");\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tSystem.out.println(\"冬季\");\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tSystem.out.println(\"春季\");\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tSystem.out.println(\"春季\");\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tSystem.out.println(\"春季\");\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tSystem.out.println(\"夏季\");\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\tSystem.out.println(\"夏季\");\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\tSystem.out.println(\"夏季\");\n\t\t\t\tbreak;\n\t\t\tcase 9:\n\t\t\t\tSystem.out.println(\"秋季\");\n\t\t\t\tbreak;\n\t\t\tcase 10:\n\t\t\t\tSystem.out.println(\"秋季\");\n\t\t\t\tbreak;\n\t\t\tcase 11:\n\t\t\t\tSystem.out.println(\"秋季\");\n\t\t\t\tbreak;\n\t\t\tcase 12:\n\t\t\t\tSystem.out.println(\"冬季\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tSystem.out.println(\"你输入的月份有误\");\n\t\t}\n\t\t*/\n\t\t\n\t\t//这样写太麻烦了，我们使用一个我们不想使用的东西：case穿透\n\t\tswitch(month) {\n\t\t\tcase 1:\n\t\t\tcase 2:\n\t\t\tcase 12:\n\t\t\t\tSystem.out.println(\"冬季\");\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\tcase 4:\n\t\t\tcase 5:\n\t\t\t\tSystem.out.println(\"春季\");\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\tcase 7:\n\t\t\tcase 8:\n\t\t\t\tSystem.out.println(\"夏季\");\n\t\t\t\tbreak;\n\t\t\tcase 9:\n\t\t\tcase 10:\n\t\t\tcase 11:\n\t\t\t\tSystem.out.println(\"秋季\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tSystem.out.println(\"你输入的月份有误\");\n\t\t}\n\t}\n}\n```\n\n### 循环结构循环语句概述\n\n```\n/*\n\t需求：请在控制台输出10次\"HelloWorld\"\n*/\nclass Demo {\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(\"HelloWorld\");\n\t\tSystem.out.println(\"HelloWorld\");\n\t\tSystem.out.println(\"HelloWorld\");\n\t\tSystem.out.println(\"HelloWorld\");\n\t\tSystem.out.println(\"HelloWorld\");\n\t\tSystem.out.println(\"HelloWorld\");\n\t\tSystem.out.println(\"HelloWorld\");\n\t\tSystem.out.println(\"HelloWorld\");\n\t\tSystem.out.println(\"HelloWorld\");\n\t\tSystem.out.println(\"HelloWorld\");\n\t}\n}\n```\n\n### 循环结构for语句的格式和基本使用\n\n```\n/*\n\t循环语句：for循环,while循环,do...while循环。\n\t\n\tfor循环格式：\n\t\tfor(初始化语句;判断条件语句;控制条件语句) {\n\t\t\t循环体语句;\n\t\t}\n\t\t\n\t\t执行流程：\n\t\t\tA:执行初始化语句\n\t\t\tB:执行判断条件语句,看其返回值是true还是false\n\t\t\t\t如果是true，就继续执行\n\t\t\t\t如果是false，就结束循环\n\t\t\tC:执行循环体语句;\n\t\t\tD:执行控制条件语句\n\t\t\tE:回到B继续。\n\t\t\t\n\t需求：请在控制台输出10次\"HelloWorld\"\n*/\nclass ForDemo {\n\tpublic static void main(String[] args) {\n\t\t//最原始的做法\n\t\tSystem.out.println(\"HelloWorld\");\n\t\tSystem.out.println(\"HelloWorld\");\n\t\tSystem.out.println(\"HelloWorld\");\n\t\tSystem.out.println(\"HelloWorld\");\n\t\tSystem.out.println(\"HelloWorld\");\n\t\tSystem.out.println(\"HelloWorld\");\n\t\tSystem.out.println(\"HelloWorld\");\n\t\tSystem.out.println(\"HelloWorld\");\n\t\tSystem.out.println(\"HelloWorld\");\n\t\tSystem.out.println(\"HelloWorld\");\n\t\tSystem.out.println(\"----------\");\n\t\t\n\t\t//这种做法不好,代码的重复度太高。\n\t\t//所以呢，我们用循环改进\n\t\tfor(int x=1;x<=10;x++) {\n\t\t\tSystem.out.println(\"HelloWorld\");\n\t\t}\n\t}\n}\n```\n\n### 循环结构for语句的注意事项\n\n**注意事项：**\nA:判断条件语句无论简单还是复杂结果是boolean类型。\n\nB:循环体语句如果是一条语句，大括号可以省略；如果是多条语句，大括号不能省略。建议永远不要省略。\n\nC:一般来说：有左大括号就没有分号，有分号就没有左大括号\n\n### 循环结构for语句练习1获取数据\n\n```\n/*\n\t需求：请在控制台输出数据1-10\n*/\nclass ForDemo2 {\n\tpublic static void main(String[] args) {\n\t\t//原始做法\n\t\tSystem.out.println(1);\n\t\tSystem.out.println(2);\n\t\tSystem.out.println(3);\n\t\tSystem.out.println(4);\n\t\tSystem.out.println(5);\n\t\tSystem.out.println(6);\n\t\tSystem.out.println(7);\n\t\tSystem.out.println(8);\n\t\tSystem.out.println(9);\n\t\tSystem.out.println(10);\n\t\t\n\t\tSystem.out.println(\"-------------\");\n\t\t\n\t\t//如何改进呢?用循环改进\n\t\tfor(int x=1; x<=10; x++) {\n\t\t\tSystem.out.println(x);\n\t\t}\n\t\t\n\t\tSystem.out.println(\"-------------\");\n\t\t\n\t\t//从0开始\n\t\tfor(int x=0; x<10; x++) {\n\t\t\tSystem.out.println(x+1);\n\t\t}\n\t}\n}\t\n```\n\n### 循环结构for语句练习2求和思想\n\n```\n/*\n\t需求：求出1-10之间数据之和\n\t\n\t分析：\n\t\t0+1=1\n\t\t\t1+2=3\n\t\t\t\t3+3=6\n\t\t\t\t\t6+4=10\n\t\t\t\t\t\t10+5=15\n\t\t\t\t\t\t\t ...\n\t\t\t\t\t\t\t \n\t\t由此可见我们要定义两个变量：\n\t\t\t一个变量用于存储第一个加数，第一个加数其实保存的是以前的所有数据和。默认初始化值应该是0。\n\t\t\t一个变量用于存储第二个加数，第二个加数其实就是每次的数据变化的值。\n\t\t\t\n\t求和思想。\t\t\n*/\nclass ForDemo3 {\n\tpublic static void main(String[] args) {\n\t\t//原始做法\n\t\tSystem.out.println(1+2+3+4+5+6+7+8+9+10);\n\t\t\n\t\t//定义第一个加数\n\t\tint sum = 0;\n\t\t\n\t\tfor(int x=1; x<=10; x++) {\n\t\t\t//这里的x其实是第二个加数\n\t\t\tsum = sum + x;\n\t\t\t/*\n\t\t\t\t0 + 1 = 1\n\t\t\t\t\t\t1 + 2 = 3\n\t\t\t\t\t\t\t\t3 + 3 = 6\n\t\t\t\t\t\t\t\t...\n\t\t\t*/\n\t\t\t\n\t\t\t//sum += x;\n\t\t}\n\t\t\n\t\tSystem.out.println(\"sum:\"+sum);\n\t}\n}\n```\n\n### 循环结构for语句练习3偶数和\n\n```\n/*\n\t需求：\n\t\tA:求1-100之和。\n\t\tB:求出1-100之间偶数和\n\t\tC:求出1-100之间奇数和(自己做)\n*/\nclass ForDemo4 {\n\tpublic static void main(String[] args) {\n\t\t//求1-100之和。\n\t\tint sum1 = 0;\n\t\t\n\t\tfor(int x=1; x<=100; x++) {\n\t\t\tsum1 +=x;\n\t\t}\n\t\t\n\t\tSystem.out.println(\"1-100之和是：\"+sum1);\n\t\tSystem.out.println(\"------------------\");\n\t\t\n\t\t//求出1-100之间偶数和\n\t\t//方式1\n\t\tint sum2 = 0;\n\t\t\n\t\tfor(int x=1; x<=100; x++) {\n\t\t\tif(x%2 == 0) {\n\t\t\t\tsum2 += x;\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(\"1-100偶数之和是：\"+sum2);\n\t\tSystem.out.println(\"------------------\");\n\t\t\n\t\t//方式2\n\t\tint sum3 = 0;\n\t\t\n\t\tfor(int x=0; x<=100; x+=2) {\n\t\t\t\tsum3 += x;\n\t\t}\n\t\t\n\t\tSystem.out.println(\"1-100偶数之和是：\"+sum3);\n\t\tSystem.out.println(\"------------------\");\n\t}\n}\n```\n\n### 循环结构for语句练习4阶乘\n\n```\n/*\n\t需求：求5的阶乘。\n\t\n\t什么是阶乘呢?\n\t\tn! = n*(n-1)! 规则\n\t\tn! = n*(n-1)*(n-2)*...*3*2*1\n\t\t\n\t求和思想。\n\t求阶乘思想。\n*/\nclass ForDemo5 {\n\tpublic static void main(String[] args) {\n\t\t//定义最终结果变量\n\t\tint jc = 1;\n\t\t\n\t\t//这里的x其实可以直接从2开始\n\t\t//for(int x=1; x<=5; x++) \n\t\t\n\t\tfor(int x=2; x<=5; x++) {\n\t\t\tjc *=x;\n\t\t}\n\t\t\n\t\tSystem.out.println(\"1-5的阶乘是：\"+jc);\n\t}\n}\n```\n\n### 循环结构for语句练习5水仙花数\n\n```\n/*\n\t天将降大任于斯人也,必先盗其QQ,封其微博,收其wifi,夺其手机。让其静心学习Java欧耶。\n\n\t需求：在控制台输出所有的”水仙花数”\n\t\n\t分析：\n\t\t我们都不知道什么叫\"水仙花数\"，你让我怎么做呢?\n\t\t\n\t\t所谓的水仙花数是指一个三位数，其各位数字的立方和等于该数本身。\n\t\t举例：153就是一个水仙花数。\n\t\t153 = 1*1*1 + 5*5*5 + 3*3*3 = 1 + 125 + 27 = 153\n\n\t\tA:三位数其实是告诉了我们范围。\n\t\tB:通过for循环我们就可以实现获取每一个三位数\n\t\t  但是麻烦是如何获取这个三位数的个,十,百位上的数据\n\t\t  \n\t\t  我们如何获取一个数据的个,十,百呢?\n\t\t\t假设有个一个数据:153\n\t\t\tge:\t153%10 = 3\n\t\t\tshi: 153/10%10 = 5\n\t\t\tbai：153/10/10%10 = 1\n\t\t\tqian：x/10/10/10%10\n\t\t\twan:  x/10/10/10/10%10\n\t\t\t...\n\n\t\tC:让ge*ge*ge+shi*shi*shi+bai*bai*bai和该数据比较\n\t\t  如果相同，就把该数据在控制台输出。\n*/\nclass ForDemo6 {\n\tpublic static void main(String[] args) {\n\t\t//三位数其实是告诉了我们范围。\n\t\tfor(int x=100; x<1000; x++) {\n\t\t\tint ge = x%10;\n\t\t\tint shi = x/10%10;\n\t\t\tint bai = x/10/10%10;\n\t\t\t\n\t\t\t//让ge*ge*ge+shi*shi*shi+bai*bai*bai和该数据比较\n\t\t\tif(x == (ge*ge*ge+shi*shi*shi+bai*bai*bai)) {\n\t\t\t\t//如果相同，就把该数据在控制台输出。\n\t\t\t\tSystem.out.println(x);\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n### 循环结构for语句练习6改进版的回文数\n\n```\n/*\n\t练习：\n\t\t请在控制台输出满足如下条件的五位数\n\t\t个位等于万位\n\t\t十位等于千位\n\t\t个位+十位+千位+万位=百位\n\t\t\n\t分析：\n\t\tA:五位数就告诉了我们范围。\n\t\tB:分解每一个五位数的个，十，百，千，万位上的数据\n\t\tC:按照要求进行判断即可\n*/\nclass ForDemo7 {\n\tpublic static void main(String[] args) {\n\t\t//五位数就告诉了我们范围。\n\t\tfor(int x=10000; x<100000; x++) {\n\t\t\t//分解每一个五位数的个，十，百，千，万位上的数据\n\t\t\tint ge = x%10;\n\t\t\tint shi = x/10%10;\n\t\t\tint bai  = x/10/10%10;\n\t\t\tint qian = x/10/10/10%10;\n\t\t\tint wan = x/10/10/10/10%10;\n\t\t\t\n\t\t\t//按照要求进行判断即可\n\t\t\tif((ge==wan) && (shi==qian) && (ge+shi+qian+wan==bai)) {\n\t\t\t\tSystem.out.println(x);\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n### 循环结构for语句练习7统计思想\n\n```\n/*\n\t需求：统计”水仙花数”共有多少个\n\t\n\t分析：\n\t\tA:首先必须知道什么是水仙花数\n\t\t\t所谓的水仙花数是指一个三位数，其各位数字的立方和等于该数本身。\n\t\t\t举例：153就是一个水仙花数。\n\t\t\t153 = 1*1*1 + 5*5*5 + 3*3*3 = 1 + 125 + 27 = 153\n\t\tB:定义统计变量，初始化值是0\n\t\tC:三位数告诉了我们范围，用for循环就可以搞定\n\t\tD:获取每一个三位数的个，十，百的数据\n\t\tE:按照要求进行判断\n\t\tF:如果满足要求就计数。\n*/\nclass ForDemo8 {\n\tpublic static void main(String[] args) {\n\t\t//定义统计变量，初始化值是0\n\t\tint count = 0;\n\t\t\n\t\t//三位数告诉了我们范围，用for循环就可以搞定\n\t\tfor(int x=100; x<1000; x++) {\n\t\t\t//获取每一个三位数的个，十，百的数据\n\t\t\tint ge = x%10;\n\t\t\tint shi = x/10%10;\n\t\t\tint bai = x/10/10%10;\n\t\t\t\n\t\t\t//按照要求进行判断\n\t\t\tif(x == (ge*ge*ge+shi*shi*shi+bai*bai*bai)) {\n\t\t\t\t//如果满足要求就计数。\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(\"水仙花数共有\"+count+\"个\");\n\t}\n}\n```\n\n### 循环结构for语句练习8同时取余问题\n\n```\n/*\n\t需求：请统计1-1000之间同时满足如下条件的数据有多少个：\n\t\t\t对3整除余2\n\t\t\t对5整除余3\n\t\t\t对7整除余2\n\n\t分析：\n\t\tA:定义统计变量,初始化值是0\n\t\tB:1-1000之间是一个范围，用for很容易就可以实现。\n\t\tC:每个数据要同时满足如下要求\n\t\t\tx%3==2\n\t\t\tx%5==3\n\t\t\tx%7==2\n\t\tD:如果满足条件，统计数据++即可，最后输出统计变量\n*/\nclass ForDemo9 {\n\tpublic static void main(String[] args) {\n\t\t//定义统计变量,初始化值是0\n\t\tint count = 0;\n\t\n\t\t//1-1000之间是一个范围，用for很容易就可以实现。\n\t\tfor(int x=1; x<=1000; x++) {\n\t\t\t/*\n\t\t\t\t每个数据要同时满足如下要求\n\t\t\t\tx%3==2\n\t\t\t\tx%5==3\n\t\t\t\tx%7==2\n\t\t\t*/\n\t\t\tif(x%3==2 && x%5==3 && x%7==2) {\n\t\t\t\tcount++;\n\t\t\t\tSystem.out.println(x);\n\t\t\t}\n\t\t}\n\t\t\n\t\t//输出数据\n\t\tSystem.out.println(\"满足这样条件的数据共有：\"+count+\"个\");\n\t}\n}\n```\n\n### 循环结构while语句的基本格式和使用\n\n```\n/*\n\twhile循环的基本格式：\n\t\twhile(判断条件语句) {\n\t\t\t循环体语句;\n\t\t}\n\t\t\n\t\t扩展格式：\n\t\t\n\t\t初始化语句;\n\t    while(判断条件语句) {\n\t\t\t 循环体语句;\n\t\t\t 控制条件语句;\n\t\t}\n\t\t\n\t\t通过这个格式，我们就可以看到其实和for循环是差不多的。\n\t\t\n\t\tfor(初始化语句;判断条件语句;控制条件语句) {\n\t\t\t循环体语句;\n\t\t}\n*/\nclass WhileDemo {\n\tpublic static void main(String[] args) {\n\t\t//输出10次\"HelloWorld\"\n\t\t//for语句版\n\t\tfor(int x=0; x<10; x++) {\n\t\t\tSystem.out.println(\"HelloWorld\");\n\t\t}\n\t\tSystem.out.println(\"--------------\");\n\t\t//while语句版\n\t\tint x=0;\n\t\twhile(x<10) {\n\t\t\tSystem.out.println(\"HelloWorld\");\n\t\t\tx++;\n\t\t}\n\t}\n}\n```\n\n### 循环结构while语句的练习1求和思想\n\n```\n/*\n\t练习：用while循环实现\n\t左边：求出1-100之和\n\t右边：统计水仙花数有多少个\n\t\n\t初始化语句;\n\twhile(判断条件语句) {\n\t\t 循环体语句;\n\t\t 控制条件语句;\n\t}\n\t\n\t\n\t\n\tfor(初始化语句;判断条件语句;控制条件语句) {\n\t\t循环体语句;\n\t}\n\n*/\nclass WhileDemo2 {\n\tpublic static void main(String[] args) {\n\t\t//求出1-100之和\n\t\t//for语句版本\n\t\tint sum = 0;\n\t\t\n\t\tfor(int x=1; x<=100; x++) {\n\t\t\tsum+=x;\n\t\t}\n\t\t\n\t\tSystem.out.println(\"sum:\"+sum);\n\t\tSystem.out.println(\"--------\");\n\t\t//while语句版本\n\t\tint sum2 = 0;\n\t\t\n\t\tint y=1;\n\t\twhile(y<=100) {\n\t\t\tsum2+=y;\n\t\t\ty++;\n\t\t}\n\t\t\n\t\tSystem.out.println(\"sum2:\"+sum2);\n\t\tSystem.out.println(\"--------\");\n\t}\n}\n```\n\n### 循环结构while语句的练习2统计思想\n\n```\n/*\n\t需求：统计水仙花数有多少个\n*/\nclass WhileDemo3 {\n\tpublic static void main(String[] args) {\n\t\t//for循环版本\n\t\tint count = 0;\n\t\t\n\t\tfor(int x=100; x<1000; x++) {\n\t\t\tint ge = x%10;\n\t\t\tint shi = x/10%10;\n\t\t\tint bai = x/10/10%10;\n\t\t\t\n\t\t\tif((ge*ge*ge+shi*shi*shi+bai*bai*bai) == x) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(\"count:\"+count);\n\t\tSystem.out.println(\"------------\");\n\t\t\n\t\t//while循环版本\n\t\tint count2 = 0;\n\t\t\n\t\tint y = 100;\n\t\twhile(y<1000) {\n\t\t\tint ge = y%10;\n\t\t\tint shi = y/10%10;\n\t\t\tint bai = y/10/10%10;\n\t\t\t\n\t\t\tif((ge*ge*ge+shi*shi*shi+bai*bai*bai) == y) {\n\t\t\t\tcount2++;\n\t\t\t}\n\t\t\t\n\t\t\ty++;\n\t\t}\n\t\t\n\t\tSystem.out.println(\"count2:\"+count2);\n\t}\n}\n```\n\n### 循环结构while语句和for语句的区别\n\n```\n/*\n\twhile循环和for循环的区别?\n\t\t使用区别：如果你想在循环结束后，继续使用控制条件的那个变量，用while循环，否则用for循环。不知道用for循环。\n\t\t          因为变量及早的从内存中消失，可以提高内存的使用效率。\n\t\t\t\t  \n\t\t其实还有一种场景的理解:\n\t\t\t如果是一个范围的，用for循环非常明确。\n\t\t\t如果是不明确要做多少次，用while循环较为合适。\n\t\t\t\t举例：吃葡萄。\n*/\nclass WhileDemo4 {\n\tpublic static void main(String[] args) {\n\t\t//for循环实现\n\t\tfor(int x=0; x<10; x++) {\n\t\t\tSystem.out.println(\"学习Java技术哪家强,中国北京传智播客\");\n\t\t}\n\t\t//这里不能在继续访问了\n\t\t//System.out.println(x);\n\t\t\n\t\t//while循环实现\n\t\tint y = 0;\n\t\twhile(y<10) {\n\t\t\tSystem.out.println(\"学习Java技术哪家强,中国北京传智播客\");\n\t\t\ty++;\n\t\t}\n\t\t//这里是可以继续访问的\n\t\tSystem.out.println(y);\n\t}\n} \n```\n\n### 循环结构while语句和练习珠穆朗玛峰\n\n```\n/*\n\t我国最高山峰是珠穆朗玛峰：8848m，我现在有一张足够大的纸张，厚度为：0.01m。\n\t请问，我折叠多少次，就可以保证厚度不低于珠穆朗玛峰的高度?\n\n\t分析：\n\t\tA:定义一个统计变量，默认值是0\n\t\tB:最高山峰是珠穆朗玛峰：8848m这是最终的厚度\n\t\t  我现在有一张足够大的纸张，厚度为：0.01m这是初始厚度\n\t\tC:我折叠多少次，就可以保证厚度不低于珠穆朗玛峰的高度?\n\t\t  折叠一次有什么变化呢?就是厚度是以前的2倍。\n\t\tD:只要每次变化的厚度没有超过珠穆朗玛峰的高度，就折叠，统计变量++\n\t\tE:输出统计变量。\n*/\n\nclass WhileDemo5 {\n\tpublic static void main(String[] args) {\n\t\t//定义一个统计变量，默认值是0\n\t\tint count = 0;\n\t\t\n\t\t//最高山峰是珠穆朗玛峰：8848m这是最终的厚度\n\t\t//我现在有一张足够大的纸张，厚度为：0.01m这是初始厚度\n\t\t//为了简单，我把0.01变成1，同理8848就变成了884800\n\t\tint end = 884800;\n\t\tint start = 1;\n\t\t\n\t\twhile(start<end) {\n\t\t\t//只要每次变化的厚度没有超过珠穆朗玛峰的高度，就折叠，统计变量++\n\t\t\tcount++;\n\t\t\t\n\t\t\t//折叠一次有什么变化呢?就是厚度是以前的2倍。\n\t\t\tstart *= 2;\n\t\t\t\n\t\t\tSystem.out.println(\"第\"+count+\"次厚度是\"+start);\n\t\t}\n\t\t\n\t\t//输出统计变量。\n\t\tSystem.out.println(\"要叠\"+count+\"次\");\n\t}\n}\n```\n\n### 循环结构do...while语句的格式和基本使用\n\n```\n/*\n\tdo...while循环的基本格式：\n\t\tdo {\n\t\t\t循环体语句;\n\t\t}while(判断条件语句);\n\t\t\n\t\t扩展格式；\n\t\t初始化语句;\n\t\tdo {\n\t\t\t循环体语句;\n\t\t\t控制条件语句;\n\t\t}while(判断条件语句);\n*/\nclass DoWhileDemo {\n\tpublic static void main(String[] args) {\n\t\t//输出10次HelloWorld。\n\t\tint x = 0;\n\t\tdo {\n\t\t\tSystem.out.println(\"HelloWorld\");\n\t\t\tx++;\n\t\t}while(x<10);\n\t\t\n\t\tSystem.out.println(\"--------------\");\n\t\t\n\t\t//求和1-100\n\t\tint sum = 0;\n\t\tint a = 1;\n\t\tdo {\n\t\t\tsum += a;\n\t\t\ta++;\n\t\t}while(a<=100);\n\t\t\n\t\tSystem.out.println(sum);\n\t}\n}\n```\n\n### 循环结构三种循环语句的区别\n\n```\n/*\n\t循环语句的区别:\n\t\tdo...while循环至少执行一次循环体。\n\t\t而for,while循环必须先判断条件是否成立，然后决定是否执行循环体语句。\n\t\t\n\t那么，我们一般使用哪种循环呢?\n\t\t优先考虑for，其次考虑while，最后考虑do...while\n*/\nclass DoWhileDemo2 {\n\tpublic static void main(String[] args) {\n\t\tint x = 3;\n\t\twhile(x < 3) {\n\t\t\tSystem.out.println(\"我爱林青霞\");\n\t\t\tx++;\n\t\t}\n\t\t\n\t\tSystem.out.println(\"--------------\");\n\t\t\n\t\tint y = 3;\n\t\tdo {\n\t\t\tSystem.out.println(\"我爱林青霞\");\n\t\t\ty++;\n\t\t}while(y < 3);\n\t}\n}\n```\n\n### 循环结构循环注意事项之死循环\n\n```\n/*\n\t注意死循环：\n\t\tA:一定要注意控制条件语句控制的那个变量的问题，不要弄丢了，否则就容易死循环。\n\t\tB:两种最简单的死循环格式\n\t\t\twhile(true){...}\n\t\t\tfor(;;){...}\n\t\t\t\n*/\nclass DoWhileDemo3 {\n\tpublic static void main(String[] args) {\n\t\tint x = 0;\n\t\twhile(x < 10) {\n\t\t\tSystem.out.println(x);\n\t\t\tx++;\n\t\t}\n\t\tSystem.out.println(\"------------\");\n\t\t\n\t\t/*\n\t\twhile(true) {\n\t\t\tSystem.out.println(\"今天我很高兴，学习了死循环\");\n\t\t\t\n\t\t}\n\t\t*/\n\t\t\n\t\tfor(;;) {\n\t\t\tSystem.out.println(\"今天我很高兴，学习了死循环\");\n\t\t}\n\t}\n}\n```\n\n### 循环结构循环嵌套输出4行5列的星星\n\n```\n/*\n\t需求：请输出一个4行5列的星星(*)图案。\n\t结果：\n\t\t*****\n\t\t*****\n\t\t*****\n\t\t*****\n\t\t\n\t循环嵌套：就是循环语句的循环体本身是一个循环语句。\n\t\n\t通过结果我们知道这样的一个结论：\n\t\t外循环控制行数\n\t\t内循环控制列数\n*/\nclass ForForDemo {\n\tpublic static void main(String[] args) {\n\t\t//原始做法\n\t\tSystem.out.println(\"*****\");\n\t\tSystem.out.println(\"*****\");\n\t\tSystem.out.println(\"*****\");\n\t\tSystem.out.println(\"*****\");\n\t\tSystem.out.println(\"-------------\");\n\t\t\n\t\t//虽然可以完成需求，但是不是很好\n\t\t//如果是多行多列就会比较麻烦\n\t\t//所以我们准备改进\n\t\t//如何改进呢?\n\t\t//我先考虑如何实现一行*的问题\n\t\t//System.out.println(\"*****\");\n\t\t//我们要想的是如何实现一次输出一颗*的问题\n\t\t//System.out.println(\"*\");\n\t\t//System.out.println(\"*\");\n\t\t//现在虽然可以一次一颗*，但是却换行了，我要求不能换行，怎么办呢?\n\t\t//输出语句的另一种格式：System.out.print(); 这个是不带换行的\n\t\t//System.out.print(\"*\");\n\t\t//System.out.print(\"*\");\n\t\t//System.out.print(\"*\");\n\t\t//System.out.print(\"*\");\n\t\t//System.out.print(\"*\");\n\t\t//如果我要在一行上打出多颗*，比较麻烦，而代码是重复的，所以我决定用循环改进\n\t\tfor(int x=0; x<5; x++) {\n\t\t\tSystem.out.print(\"*\");\n\t\t}\n\t\t//我们可以通过空的输出语句实现换行：System.out.println();\n\t\tSystem.out.println();\n\t\t\n\t\t//既然我可以打出一行，我就可以打出第二行\n\t\tfor(int x=0; x<5; x++) {\n\t\t\tSystem.out.print(\"*\");\n\t\t}\n\t\t//我们可以通过空的输出语句实现换行：System.out.println();\n\t\tSystem.out.println();\n\t\n\t\t//同理打出第三行，第四行\n\t\tfor(int x=0; x<5; x++) {\n\t\t\tSystem.out.print(\"*\");\n\t\t}\n\t\t//我们可以通过空的输出语句实现换行：System.out.println();\n\t\tSystem.out.println();\n\t\t\n\t\t//既然我可以打出一行，我就可以打出第二行\n\t\tfor(int x=0; x<5; x++) {\n\t\t\tSystem.out.print(\"*\");\n\t\t}\n\t\t//我们可以通过空的输出语句实现换行：System.out.println();\n\t\tSystem.out.println();\n\t\tSystem.out.println(\"-----------------\");\n\t\t//同样的代码出现了4次，说明我们程序写的不好，用循环改进\n\t\tfor(int y=0; y<4; y++) {\n\t\t\tfor(int x=0; x<5; x++) {\n\t\t\t\tSystem.out.print(\"*\");\n\t\t\t}\n\t\t\t//我们可以通过空的输出语句实现换行：System.out.println();\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}\n```\n\n### 循环结构循环嵌套输出直角三角形\n\n```\n/*\n\t需求：请输出下列的形状\n\t\t*\n\t\t**\n\t\t***\n\t\t****\n\t\t*****\n*/\nclass ForForDemo2 {\n\tpublic static void main(String[] args) {\n\t\t//通过简单的观察，我们看到这是一个行是5，列数是变化的形状\n\t\t//我们先打印出一个5行5列的形状\n\t\tfor(int x=0; x<5; x++) {\n\t\t\tfor(int y=0; y<5; y++) {\n\t\t\t\tSystem.out.print(\"*\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\t\n\t\tSystem.out.println(\"--------------\");\n\t\t\n\t\t//我们实现了一个5行5列的形状\n\t\t//但是这不是我们想要的\n\t\t//我们要的是列数变化的\n\t\t//列数是如何变化的呢?\n\t\t//第一行：1列\ty=0,y<=0,y++\n\t\t//第二行：2列\ty=0,y<=1,y++\n\t\t//第三行：3列\ty=0,y<=2,y++\n\t\t//第四行：4列\ty=0,y<=3,y++\n\t\t//第五行：5列\ty=0,y<=4,y++\n\t\t//在看外循环x的变化，恰好就是x=0,1,2,3,4\n\t\t//所以这个最终版的程序就是如下\n\t\tfor(int x=0; x<5; x++) {\n\t\t\tfor(int y=0; y<=x; y++) {\n\t\t\t\tSystem.out.print(\"*\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}\n```\n\n### 循环结构九九乘法表\n\n```\n/*\n\t需求：在控制台输出九九乘法表。\n\t\n\t首先我们写出九九乘法表：\n\t\t1*1=1\n\t\t1*2=2\t2*2=4\n\t\t1*3=3\t2*3=6\t3*3=9\n\t\t1*4=4\t2*4=8\t3*4=12\t4*4=16\n\t\t...\n\t\t1*9=9\t2*9=18\t3*9=27\t...\n\t\t\n\t我们先把这个九九乘法表看出是这样的一个形状：\n\t\t*\n\t\t**\n\t\t***\n\t\t****\n\t\t*****\n\t\t******\n\t\t*******\n\t\t********\n\t\t*********\n\t\t\n\t注意：\n\t\t'\\x' x表示任意，这种做法叫转移字符。\n\t\t\n\t\t'\\t'\ttab键的位置\n\t\t'\\r'\t回车\n\t\t'\\n'\t换行\n*/\nclass ForForDemo3 {\n\tpublic static void main(String[] args) {\n\t\tfor(int x=0; x<9; x++) {\n\t\t\tfor(int y=0; y<=x; y++) {\n\t\t\t\tSystem.out.print(\"*\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println(\"--------------\");\n\t\t//为了使用数据，我们从1开始\n\t\tfor(int x=1; x<=9; x++) {\n\t\t\tfor(int y=1; y<=x; y++) {\n\t\t\t\tSystem.out.print(y+\"*\"+x+\"=\"+y*x+\"\\t\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}\n```\n\n### 控制跳转语句break语句\n\n```\npackage stephencurry;\nimport java.util.*;\nimport java.math.*;\nimport java.io.*;\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n        Scanner sc = new Scanner(System.in);\n        for(int x=0; x<10; x++) {\n\t\t\tif(x == 3) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tSystem.out.println(\"HelloWorld\");\n\t\t}\n\t\t\n\t\tSystem.out.println(\"over\");\n\t\tSystem.out.println(\"-------------\");\n\t\t\n\t\twc:for(int x=0; x<3; x++) {\n\t\t\tnc:for(int y=0; y<4; y++) {\n\t\t\t\tif(y == 2) {\n\t\t\t\t\t//break nc;\n\t\t\t\t\tbreak wc;\n\t\t\t\t}\n\t\t\t\tSystem.out.print(\"*\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}\n\n```\n\n### 控制跳转语句continue语句\n\n```\n/*\n\tcontinue:继续\n\t\n\t使用场景：\n\t\t循环中。离开此场景无意义。\n\t\t\n\t测试，找到和break的区别：\n\t\tbreak:跳出单层循环\n\t\tcontinue:跳出一次循环，进入下一次的执行\n\t\t\n\t练习题：\n\t\tfor(int x=1; x<=10; x++) {\n\t\t\tif(x%3==0) {\n\t\t\t\t//在此处填写代码\n\t\t\t}\n\t\t\tSystem.out.println(“Java基础班”);\n\t\t}\n\t\t\n\t\t我想在控制台输出2次:“Java基础班“\n\t\t\tbreak;\n\t\t我想在控制台输出7次:“Java基础班“\n\t\t\tcontinue;\n\t\t我想在控制台输出13次:“Java基础班“\t\n\t\t\tSystem.out.println(“Java基础班”);\n\n\n*/\nclass ContinueDemo {\n\tpublic static void main(String[] args) {\n\t\tfor(int x=0; x<10; x++) {\n\t\t\tif(x == 3) {\n\t\t\t\t//break;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(x);\n\t\t}\n\t}\n}\n```\n\n### 控制跳转语句return语句\n\n```\n/*\n\treturn:返回\n\t\n\t其实它的作用不是结束循环的，而是结束方法的。\n*/\nclass ReturnDemo {\n\tpublic static void main(String[] args) {\n\t\tfor(int x=0; x<10; x++) {\n\t\t\tif(x == 2) {\n\t\t\t\tSystem.out.println(\"退出\");\n\t\t\t\t//break;\n\t\t\t\t//continue;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(x);\n\t\t}\n\t\t\n\t\tSystem.out.println(\"over\");\n\t}\n}\n```\n\n### while语句和break结合使用之小芳存钱\n\n```\n/*\n\t需求：小芳的妈妈每天给她2.5元钱，她都会存起来，但是，\n\t      每当这一天是存钱的第5天或者5的倍数的话，她都会花去6元钱，\n\t\t  请问，经过多少天，小芳才可以存到100元钱。\n\n\t分析：\n\t\tA:小芳的妈妈每天给她2.5元钱\n\t\t\tdouble dayMoney = 2.5;\n\t\tB:她都会存起来\n\t\t\tdouble daySum = 0;\n\t\tC:从第一天开始存储\n\t\t\tint dayCount = 1;\n\t\tD:经过多少天，小芳才可以存到100元钱。\n\t\t\tdouble result = 100;\n\t\tE:这一天是存钱的第5天或者5的倍数的话，她都会花去6元钱，\n\t\t\t说明要判断dayCount的值，如果对5整除就减去6元钱。\n\t\t\t\tdaySum -= 6;\n\t\t  由此还隐含了一个问题，就是如果不是5的倍数天的话，钱要累加\n\t\t\t\tdaySum += dayMoney;\n\t\tF:因为不知道是多少天，所以我用死循环，一旦超过100元我就退出循环。\n*/\nclass WhileDemo {\n\tpublic static void main(String[] args) {\n\t\t//每天要存储的钱是2.5元\n\t\tdouble dayMoney = 2.5;\n\t\t\n\t\t//存钱的初始化值是0\n\t\tdouble daySum = 0;\n\t\t\n\t\t//从第一天开始存储\n\t\tint dayCount = 1;\n\t\t\n\t\t//最终存储不小于100就不存储了\n\t\tint result = 100;\n\t\t\n\t\t//因为不知道是多少天，所以我用死循环，\n\t\twhile(true) {\n\t\t\t//累加钱\n\t\t\tdaySum += dayMoney;\n\t\t\t\n\t\t\t//一旦超过100元我就退出循环。\n\t\t\tif(daySum >= result) {\n\t\t\t\tSystem.out.println(\"共花了\"+dayCount+\"天存储了100元\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tif(dayCount%5 == 0) {\n\t\t\t\t//花去6元钱\n\t\t\t\tdaySum -= 6;\n\t\t\t\tSystem.out.println(\"第\"+dayCount+\"天花了6元钱\");\n\t\t\t}\n\t\t\t\n\t\t\t//天数变化\n\t\t\tdayCount++;\n\t\t}\n\t}\n}\n```\n","tags":["Java系统学习"],"categories":["Java系统学习-JavaSE篇"]},{"title":"牛客算法周周练6","url":"/2020/05/13/牛客算法周周练6/","content":"\n### A题\n\n大小各不相同的一队青蛙站在河左岸的石墩（记为A）上，要过到对岸的石墩(记为D)上去。河心有几片菏叶(分别记为Y1…Ym)和几个石墩(分别记为S1…Sn)。图示如下：\n\n<!--more-->\n\n![tupian](https://uploadfiles.nowcoder.com/images/20180701/305473_1530409311818_55A3FDD5552A97D657101D27CE6E2F90)\n\n青蛙的站队和移动方法规则如下：\n\n1． 每只青蛙只能站在荷叶、石墩，或者仅比它大一号的青蛙背上（统称为合法的落脚点）；\n\n2． 一只青蛙只有背上没有其它青蛙的时候才能够从一个落脚点跳到另一个落脚点；\n\n3． 青蛙允许从左岸A直接跳到河心的石墩、荷叶和右岸的石墩D上，允许从河心的石墩和荷叶跳到右岸的石墩D上；\n\n4． 青蛙在河心的石墩之间、荷叶之间以及石墩和荷叶之间可以来回跳动；\n\n5． 青蛙在离开左岸石墩后，不能再返回左岸；到达右岸后，不能再跳回；\n\n6． 假定石墩承重能力很大，允许无论多少只青蛙都可呆在上面。但是，由于石墩的面积不大，至多只能有一只青蛙直接站在上面，而其他的青蛙只能依规则1落在比它大一号的青蛙的背上。\n7． 荷叶不仅面积不大，而且负重能力也有限，至多只能有一只青蛙站在上面。\n\n8． 每一步只能移动一只青蛙，并且移动后需要满足站队规则；\n\n9． 在一开始的时候，青蛙均站在A上，最大的一只青蛙直接站在石墩上，而其它的青蛙依规则6站在比其大一号的青蛙的背上。\n\n青蛙希望最终能够全部移动到D上，并完成站队。\n\n设河心有m片荷叶和n个石墩，请求出这队青蛙至多有多少只，在满足站队和移动规则的前提下，能从A过到D。\n\n例如，在m=1且n=1时，河心有一片荷叶（Y1）和一个石墩（S1），此时至多有4只青蛙能够过河（由小到大称为1、2、3、4），过河的一种方法为：\n\n![tupian2](https://uploadfiles.nowcoder.com/images/20180701/305473_1530409345048_6028F142230141307F51778CA0C5A02F)\n\n输入描述:\n仅有两行，每一行仅包含一个整数和一个换行/回车符。第一行的数字为河心的石墩数n(0 ≤ N ≤ 25)，第二行为荷叶数m(0 ≤ M ≤ 25)。\n\n输出描述:\n仅包含一个数字和一个换行/回车符。该数字为在河心有n个石墩和m片荷叶时，最多能够过河的青蛙的只数。\n\n输入\n\n1\n\n1\n\n输出\n\n4\n\n**题意：**\n中文题，不过多叙述题意。\n\n**思路：**\n这道题的话，看起来像汉诺塔，但是汉诺塔可以随意移动，虽然也有一定前提。但是对这个题目来说最要命的约束条件就是到了对面就不能动了。所以我们可以知道一定是重的青蛙先跳去对面。所以我们从几个极端来看。\n如果给出莲叶数是m，石头数目是n。\n\n如果n是0，那么最多可以允许m+1个青蛙，m个青蛙填满莲叶，最后一个青蛙跳过去。\n如果n是1，那么最多允许m+1个青蛙先填满莲叶，在去石头上面过渡，另外的m+1个青蛙根据m=0的情况跳。所以一共 （m + 1）*2。所以我们得出结论：\n$$ans=2^{n}*(m+1)$$\n\n**AC代码：**\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxx = 100010;\nconst int inf = 0x3f3f3f3f;\nusing namespace std;\nint main()\n{\n    int n, m;\n    cin >> n >> m;\n    cout << (1 << n) * (m + 1) << endl;\n    return 0;\n}\n```\n\n### B题\n\n**题意：**\n月月给华华出了一道题，先给你一个式子：$F_{1}=A,F_{2}=B,F_{i}=F_{i-1}+F_{i-2}(i>2)$，然后求$gcd(F_{N},F_{N+1})$。\n\n**思路：**\n这道题的话，考察裴蜀定理,裴蜀定理具体如下：裴蜀定理（或贝祖定理）得名于法国数学家艾蒂安·裴蜀，说明了对任何整数a、b和它们的最大公约数d，关于未知数x和y的线性不定方程（称为裴蜀等式）：若a,b是整数,且$gcd(a,b)=d$，那么对于任意的整数x,y,ax+by都一定是d的倍数，特别地，一定存在整数x,y，使$ax+by=d$成立。由裴蜀定理可知，要求$gcd(F_{N},F_{N+1})$,只要求出$gcd(A,B)$就可以了，这两者是相等的。并且C++函数库中已经封装了_$gcd(a,b)$用来求a与b之间的最大公约数，我们只需要套用就可以了。\n\n**AC代码：**\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxx = 100010;\nconst int inf = 0x3f3f3f3f;\nusing namespace std;\nint main()\n{\n    ll a, b, n;\n    cin >> a >> b >> n;\n    cout << __gcd(a, b) << endl;\n    return 0;\n}\n```\n\n### C题\n\n**题意：**\nNancy喜欢博弈！\nJohnson和Nancy得到了一个神奇的多重集合，仅包含一个正整数n，两个人轮流进行操作。\n一次操作可以将集合中一个数字分解为它的任意两个非1的因数，并加入集合中。\n他们想知道，在Johnson和Nancy绝顶聪明的情况下，如果Nancy先手进行操作，最后谁没有办法继续操作了呢？\n\n**思路：**\n这道题的话，每次操作可以将集合中的一个数字分解为它的任意两个非1的因数, 集合中的数字个数+1。因为质因数是无法再被分解的,所以最后集合中的数全为 n 的质因数。因此只需要看题目给定的n有多少个质因数。假设n有p个质因数，那么这场游戏将进行p-1次操作（每次操作后集合中的数字个数+1），如果p-1为奇数那么后手便无法再进行操作，如果p-1为偶数则先手再无法进行操作。所以我们只要筛一下素数就行了。最后$n==1$的情况要判断一下。\n\n**AC代码：**\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxx = 100010;\nconst int inf = 0x3f3f3f3f;\nusing namespace std;\nint main()\n{\n    int n;\n    cin >> n;\n    if (n == 1)\n    {\n        cout << \"Nancy\" << endl;\n        return 0;\n    }\n    int ans = 0;\n    for (int i = 2; i <= n; i++)\n    {\n        while (n % i == 0)\n        {\n            n /= i;\n            ans++;\n        }\n    }\n    if (ans % 2 != 0)\n        cout << \"Nancy\" << endl;\n    else\n        cout << \"Johnson\" << endl;\n    return 0;\n}\n```\n\n### D题\n\n**题意：**\n胡队长带领HA实验的战士们玩真人CS，真人CS的地图由一些据点组成，现在胡队长已经占领了n个据点，为了方便，将他们编号为1~n，为了隐蔽，胡队长命令战士们在每个据点出挖一个坑，让战士们躲在坑里。由于需要在任意两个点之间传递信息，两个坑之间必须挖出至少一条通路，而挖沟是一件很麻烦的差事，所以胡队长希望挖出数量尽可能少的沟，使得任意两个据点之间有至少一条通路，顺便，尽可能的$\\sum d[i][j]$使最小（其中$d[i][j]$为据点i到j的距离）。\n\n**思路：**\n这道题的话，就是一道裸的最小生成树，直接做就可以了。\n\n**AC代码：**\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxx = 100010;\nconst int inf = 0x3f3f3f3f;\nusing namespace std;\nstruct node\n{\n    int s;\n    int e;\n    int v;\n} edge[maxx*5];\nbool cmp(node a, node b)\n{\n    return a.v < b.v;\n}\nint pre[maxx];\nint n, m;\nvoid init()\n{\n    for (int i = 0; i <= n; i++)\n        pre[i] = i;\n}\nint getf(int a)\n{\n    if (pre[a] == a)\n        return a;\n    int tmp = getf(pre[a]);\n    return pre[a] = tmp;\n}\nint Kruskal(int a, int b)\n{\n    int fa = getf(a);\n    int fb = getf(b);\n    if (fa != fb)\n    {\n        pre[fa] = fb;\n        return 1;\n    }\n    else\n        return 0;\n}\nint main()\n{\n    while (cin >> n >> m)\n    {\n        init();\n        for (int i = 1; i <= m; i++)\n            cin >> edge[i].s >> edge[i].e >> edge[i].v;\n        sort(edge + 1, edge + m + 1, cmp);\n        int ans = 0;\n        for (int i = 1; i <= m; i++)\n        {\n            if (Kruskal(edge[i].s, edge[i].e))\n                ans += edge[i].v;\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n```\n\n### E题\n\n**题意：**\n这道题给你了一些代码，让你补全。\n\n**思路：**\n这道题的话，看完代码后不难看出是求的线段树，所以我们按要求补全即可。\n\n**AC代码：**\n\n```\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <climits>\n#include <cstdio>\n#include <vector>\n#include <cstdlib>\n#include <ctime>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#define fi first\n#define lc (x << 1)\n#define se second\n#define U unsigned\n#define rc (x << 1 | 1)\n#define Re register\n#define LL long long\n#define MP std::make_pair\n#define CLR(i, a) memset(i, a, sizeof(i))\n#define FOR(i, a, b) for (Re int i = a; i <= b; ++i)\n#define ROF(i, a, b) for (Re int i = a; i >= b; --i)\n#define SFOR(i, a, b, c) for (Re int i = a; i <= b; i += c)\n#define SROF(i, a, b, c) for (Re int i = a; i >= b; i -= c)\n#define DEBUG(x) std::cerr << #x << '=' << x << std::endl\nconst int MAXN = 1000000 + 5;\nint N, maxL;\nstd::set<std::pair<int, int>> L;\nint a[MAXN];\ninline int calc()\n{\n    // 返回 set 中所有线段的并长度。(每个 pair 表示一个线段[first,second]\n    int ans = 0;\n    for (int i = 1; i <= maxL; i++)\n    {\n        if (a[i])\n            ans++;\n    }\n    return ans;\n}\nint main()\n{\n    scanf(\"%d%d\", &N, &maxL);\n    while (N--)\n    {\n        int opt, x, y;\n        scanf(\"%d%d%d\", &opt, &x, &y);\n        if (opt == 1)\n        {\n            if (L.find(MP(x, y)) != L.end())\n                continue;\n            L.insert(MP(x, y));\n            for (int i = x; i <= y; i++)\n                a[i]++;\n        }\n        if (opt == 2)\n        {\n            if (L.find(MP(x, y)) == L.end())\n                continue;\n            L.erase(MP(x, y));\n            for (int i = x; i <= y; i++)\n                a[i]--;\n        }\n        if (opt == 3)\n        {\n            printf(\"%d\\n\", calc());\n        }\n    }\n    return 0;\n}\n```\n","tags":["牛客题解"],"categories":["牛客题解"]},{"title":"JavaSE-Day(3)学习笔记","url":"/2020/05/12/JavaSE-Day(3)学习笔记/","content":"\n## 数据类型中补充的几个小问题\n\n<!--more-->\n\n```\n1:在定义Long或者Float类型变量的时候，要加L或者f。\n  整数默认是int类型，浮点数默认是double。\n  \n  byte，short在定义的时候，他们接收的其实是一个int类型的值。\n  这个是自己做了一个数据检测的，如果不再它们的范围内，就报错。\n  \n2:byte值的问题\n\tbyte b1 = 127;\n\tbyte b2 = (byte)128; //-128\n\tbyte b3 = (byte)129; //-127\n\tbyte b4 = (byte)130; //-126\n\t\n\tbyte的范围：-128 ~ 127\n\t\n\t128：10000000\n\t-128：10000000 (这里的1即是符号位，也是数值位)\n\t\n3:数据类型转换之默认转换\n\tbyte,short,char -- int -- long -- float -- double\n\t\n\tlong: 8个字节\n\tfloat：4个字节\n\t\n\tA:它们底层的存储结构不同。\n\tB:float表示的数据范围比long的范围要大\n\t\tlong：2^63-1\n\t\tfloat：3.4*10^38 > 2*10^38 > 2*8^38 = 2*2^3^38 = 2*2^114 > 2^63-1\n\n4:Java语言中的字符char可以存储一个中文汉字吗?为什么呢?\n\t可以。因为java语言中的字符占用两个字节。\n\t\n\tJava语言采用的是Unicode编码。\n```\n\n## 算术运算符的基本用法\n\n### 算术运算符\n\n```\n/*\n\t算术运算符：\n\t\t+,-,*,/,%,++,--\n\t\t\n\t注意事项：\n\t\tA:整数相除只能得到整数。如果想得到小数，必须把数据变化为浮点数类型\n\t\tB:/获取的是除法操作的商，%获取的是除法操作的余数\n*/\n\nclass OperatorDemo {\n\tpublic static void main(String[] args) {\n\t\t//定义变量\n\t\tint x = 3;  //把3赋值给int类型的变量x\n\t\tint y = 4;\n\t\t\n\t\tSystem.out.println(x+y);\n\t\tSystem.out.println(x-y);\n\t\tSystem.out.println(x*y);\n\t\tSystem.out.println(x/y); //整数相除只能得到整数\n\t\t\n\t\t//我就想得到小数，该肿么办呢?\n\t\t//只需要把操作的数据中任意的一个数据变为浮点数\n\t\tSystem.out.println(x*1.0/y);\n\t\t\n\t\t//%的应用\n\t\tSystem.out.println(x%y); //得到的是余数\n\t}\n}\n```\n\n### 算术运算符++和--的使用\n\n```\n/*\n\t++,--运算符的使用：\n\t\t单独使用：\n\t\t\t放在操作数的前面和后面效果一样。(这种用法是我们比较常见的)\n\t\t参与运算使用：\n\t\t\t放在操作数的前面，先自增或者自减，然后再参与运算。\n\t\t\t放在操作数的后面，先参与运算，再自增或者自减。\n\t\t\t\n\t作用：就是对变量进行自增1或者自减1。\n*/\nclass OperatorDemo2 {\n\t\tpublic static void main(String[] args) {\n\t\t\t//定义两个变量\n\t\t\tint x = 3;\n\t\t\tint y = 4;\n\t\t\t\n\t\t\t//字符串的拼接\n\t\t\t//System.out.println(\"x:\"+x);\n\t\t\t//System.out.println(\"y:\"+y);\n\t\t\t\n\t\t\tSystem.out.println(\"x:\"+x+\",y:\"+y);\n\t\t\t\n\t\t\t//单独使用\n\t\t\t//x++;\n\t\t\t//y--;\n\t\t\t++x;\n\t\t\t--y;\n\t\t\t//System.out.println(x);\n\t\t\tSystem.out.println(\"x:\"+x+\",y:\"+y);\n\t\t\t\n\t\t\t//意外的类型,常量是不可以这样做的\n\t\t\t//System.out.println(10++);\n\t\t\t\n\t\t\tSystem.out.println(\"-------------------\");\n\t\t\t//参与运算使用\n\t\t\tint a = 3;\n\t\t\tint b = 4;\n\t\t\t\n\t\t\t//int c = a++;\n\t\t\t//int d = b--;\n\t\t\t\n\t\t\tint c = ++a;\n\t\t\tint d = --b;\n\t\t\t\n\t\t\tSystem.out.println(\"a:\"+a); //4, 4\n\t\t\tSystem.out.println(\"b:\"+b); //3, 3\n\t\t\tSystem.out.println(\"c:\"+c); //3, 4\n\t\t\tSystem.out.println(\"d:\"+d); //4, 3\n\t\t}\n}\n```\n\n### 算术运算符+的多种用法\n\n```\n/*\n\t+的用法：\n\t\tA:加法\n\t\tB:正号\n\t\tC:字符串连接符\n*/\nclass OperatorDemo3 {\n\tpublic static void main(String[] args) {\n\t\t//加法\n\t\tSystem.out.println(3+4);\n\t\t\n\t\t//正号\n\t\tSystem.out.println(+4);\n\t\t\n\t\tSystem.out.println('a');\n\t\tSystem.out.println('a'+1); //这里是加法\n\t\t\n\t\t//字符串连接符\n\t\tSystem.out.println(\"hello\"+'a'+1);\n\t\tSystem.out.println('a'+1+\"hello\");\n\t}\n}\n```\n\n### 算术运算符++和--的练习\n\n```\n/*\n\t++,--的练习题\n\t\n\t第一题：\n\tint a = 10;\n\tint b = 10;\n\tint c = 10;\n\n\ta = b++;\n\tc = --a;\n\tb = ++a;\n\ta = c--;\n\t请分别计算出a,b,c的值\n\t\n\t第二题：\n\tint x = 4;\n\tint y = (x++)+(++x)+(x*10);\n\t请分别计算出x,y的值\n*/\nclass OperatorTest {\n\tpublic static void main(String[] args) {\n\t\tint a = 10;\n\t\tint b = 10;\n\t\tint c = 10;\n\n\t\ta = b++; //a=10,b=11,c=10\n\t\tc = --a; //a=9,b=11,c=9\n\t\tb = ++a; //a=10,b=10,c=9\n\t\ta = c--; //a=9,b=10,c=8\n\t\t\n\t\tSystem.out.println(\"a:\"+a);\n\t\tSystem.out.println(\"b:\"+b);\n\t\tSystem.out.println(\"c:\"+c);\n\t\tSystem.out.println(\"--------------\");\n\t\t\n\t\tint x = 4;\n\t\tint y = (x++)+(++x)+(x*10);\n\t\t//4+6+60\n\t\t//x=5,6\n\t\t\n\t\tSystem.out.println(\"x:\"+x);\n\t\tSystem.out.println(\"y:\"+y);\n\t}\n}\n```\n\n### 赋值运算符的基本用法\n\n```\n/*\n\t赋值运算符：\n\t\t基本的赋值运算符：=\n\t\t\t把=右边的数据赋值给左边。\n\t\t\t\n\t\t扩展的赋值运算符：+=,-=,*=,/=,%=\n\t\t\t+= 把左边和右边做加法，然后赋值给左边。\n*/\nclass OperatorDemo {\n\tpublic static void main(String[] args) {\n\t\t//定义一个变量\n\t\tint x = 10;\n\t\t\n\t\t//其他用法\n\t\tint a,b; \n\t\ta = b = 10;\n\t\tSystem.out.println(a); \n\t\tSystem.out.println(b);\n\t\tSystem.out.println(\"-----------\");\n\n\t\t//定义一个变量\n\t\tint y = 10;\n\t\t\n\t\ty += 20;\n\t\t\n\t\tSystem.out.println(y);\n\t\t\n\t}\n}\n```\n\n### 赋值运算符的面试题\n\n```\n/*\n\t面试题：\n\t\tshort s=1;s = s+1; \n\t\t\n\t\tshort s=1;s+=1;\n\t\t上面两个代码有没有问题，如果有，那里有问题。\n\t\t\n\t\t为什么第二个木有问题呢?\n\t\t\t扩展的赋值运算符其实隐含了一个强制类型转换。\n\t\t\t\n\t\t\ts += 1;\n\t\t\t不是等价于 s = s + 1;\n\t\t\t而是等价于 s = (s的数据类型)(s + 1);\n*/\nclass OperatorTest {\n\tpublic static void main(String[] args) {\n\t\t//short s = 1;\n\t\t//s = s + 1;\n\t\t//System.out.println(s);\n\t\t\n\t\tshort s = 1;\n\t\ts += 1; //好像是 s = s + 1;\n\t\tSystem.out.println(s);\n\t}\n}\n```\n\n### 比较运算符的基本用法及其注意事项\n\n```\n/*\n\t比较运算符：\n\t\t==,!=,>,>=,<,<=\n\t\t\n\t特点：\n\t\t无论你的操作是简单还是复杂，结果是boolean类型。\n\t\t\n\t注意事项：\n\t\t\"==\"不能写成\"=\"。\n*/\nclass OperatorDemo {\n\tpublic static void main(String[] args) {\n\t\tint x = 3;\n\t\tint y = 4;\n\t\tint z = 3;\n\t\n\t\tSystem.out.println(x == y);\n\t\tSystem.out.println(x == z);\n\t\tSystem.out.println((x+y) == (x+z));\n\t\tSystem.out.println(\"------------\");\n\t\t\n\t\tSystem.out.println(x != y);\n\t\tSystem.out.println(x > y);\n\t\tSystem.out.println(x >= y);\n\t\tSystem.out.println(x < y);\n\t\tSystem.out.println(x <= y);\n\t\tSystem.out.println(\"------------\");\n\t\t\n\t\tint a = 10;\n\t\tint b = 20;\n\t\t\n\t\t//boolean flag = (a == b);\n\t\t//boolean flag = (a = b); //这个是有问题的，不兼容的类型\n\t\t//System.out.println(flag);\n\t\t\n\t\tint c = (a = b); //把b赋值给a，然后把a留下来\n\t\tSystem.out.println(c);\n\t}\n}\n```\n\n### 逻辑运算符的基本用法\n\n```\n/*\n\t逻辑运算符：\n\t\t&,|,^,!\n\t\t&&,||\n\t\t\n\t特点：\n\t\t逻辑运算符一般用于连接boolean类型的表达式或者值。\n\t\t\t\n\t\t表达式：就是用运算符把常量或者变量连接起来的符合java语法的式子。\n\t\t\t算术表达式：a + b\n\t\t\t比较表达式：a == b\n\t\t\t\n\t结论：\n\t\t&逻辑与:有false则false。\n\t\t|逻辑或:有true则true。\n\t\t^逻辑异或:相同为false，不同为true。\n\t\t\t举例：情侣关系。男男,男女,女男,女女\n\t\t!逻辑非:非false则true，非true则false。\n\t\t\t特点：偶数个不改变本身。\n*/\nclass OperatorDemo {\n\tpublic static void main(String[] args) {\n\t\tint a = 3;\n\t\tint b = 4;\n\t\tint c = 5;\n\t\t\n\t\t//&逻辑与\n\t\tSystem.out.println((a > b) & (a > c)); //false & false = false\n\t\tSystem.out.println((a > b) & (a < c)); //false & true = false\n\t\tSystem.out.println((a < b) & (a > c)); //true & false = false\n\t\tSystem.out.println((a < b) & (a < c)); //true & true = true\n\t\tSystem.out.println(\"---------------\");\n\t\t\n\t\t//|逻辑或\n\t\tSystem.out.println((a > b) | (a > c)); //false | false = false\n\t\tSystem.out.println((a > b) | (a < c)); //false | true = true\n\t\tSystem.out.println((a < b) | (a > c)); //true | false = true\n\t\tSystem.out.println((a < b) | (a < c)); //true | true = true\n\t\tSystem.out.println(\"---------------\");\n\t\t\n\t\t//^逻辑异或\n\t\tSystem.out.println((a > b) ^ (a > c)); //false ^ false = false\n\t\tSystem.out.println((a > b) ^ (a < c)); //false ^ true = true\n\t\tSystem.out.println((a < b) ^ (a > c)); //true ^ false = true\n\t\tSystem.out.println((a < b) ^ (a < c)); //true ^ true = false\n\t\tSystem.out.println(\"---------------\");\n\t\t\n\t\t//!逻辑非\n\t\tSystem.out.println(!(a > b)); //!false = true\n\t\tSystem.out.println(!(a < b)); //!true = false\n\t\tSystem.out.println(!!(a > b)); //!!false = false\n\t\tSystem.out.println(!!!(a > b)); //!!false = true\n\t}\n}\n```\n\n### 逻辑运算符&&和&的区别\n\n```\n/*\n\t&&和&的区别? 同理||和|的区别?\n\t\tA:最终结果一样。\n\t\tB:&&具有短路效果。左边是false，右边不执行。\n\t\tC:||具有短路效果，左边是true，右边不执行。\n\t\t\n\t开发中常用的逻辑运算符：\n\t\t&&,||,!\n*/\nclass OperatorDemo2 {\n\tpublic static void main(String[] args) {\n\t\tint a = 3;\n\t\tint b = 4;\n\t\tint c = 5;\n\t\t\n\t\t//&&双与\n\t\tSystem.out.println((a > b) && (a > c)); //false && false = false\n\t\tSystem.out.println((a > b) && (a < c)); //false && true = false\n\t\tSystem.out.println((a < b) && (a > c)); //true && false = false\n\t\tSystem.out.println((a < b) && (a < c)); //true && true = true\n\t\tSystem.out.println(\"----------------\");\n\t\t\n\t\tint x = 3;\n\t\tint y = 4;\n\t\t\n\t\t//boolean b1 = ((x++ == 3) & (y++ == 4));\n\t\t//boolean b1 = ((x++ == 3) && (y++ == 4));\n\t\t//boolean b1 = ((++x == 3) & (y++ == 4));\n\t\tboolean b1 = ((++x == 3) && (y++ == 4));\n\t\tSystem.out.println(\"x:\"+x);\n\t\tSystem.out.println(\"y:\"+y);\n\t\tSystem.out.println(b1);\n\t}\n}\n```\n\n### 位运算的基本用法1\n\n```\n/*\n\t位运算符：\n\t\t&,|,^,~\n\t\t<<,>>,>>>\n\t\t\n\t注意：\n\t\t要做位运算，首先要把数据转换为二进制。\n*/\nclass OperatorDemo {\n\tpublic static void main(String[] args) {\n\t\t//&,|,^,~\n\t\t\n\t\tint a = 3;\n\t\tint b = 4;\n\t\t\n\t\tSystem.out.println(3 & 4);\n\t\tSystem.out.println(3 | 4);\n\t\tSystem.out.println(3 ^ 4);\n\t\tSystem.out.println(~3);\n\t}\n}\n/*\n\t分析：因为是位运算，所以我们必须先把数据换算成二进制。\n\t\n\t3的二进制：11\n\t\t00000000 00000000 00000000 00000011\n\t4的二进制：100\n\t\t00000000 00000000 00000000 00000100\n\t\n\t&位与运算：有0则0。\n\t\t00000000 00000000 00000000 00000011\n\t   &00000000 00000000 00000000 00000100\n\t\t-----------------------------------\n\t\t00000000 00000000 00000000 00000000\n\t\t结果是：0\n\t\t\n\t|位或运算：有1则1。\n\t\t00000000 00000000 00000000 00000011\n\t   |00000000 00000000 00000000 00000100\n\t\t-----------------------------------\n\t\t00000000 00000000 00000000 00000111\n\t\t结果是：7\n\t\t\n\t^位异或运算：相同则0，不同则1。\n\t\t00000000 00000000 00000000 00000011\n\t   &00000000 00000000 00000000 00000100\n\t\t-----------------------------------\n\t\t00000000 00000000 00000000 00000111\n\t\t结果是：7\n\t\t\n\t~按位取反运算符：0变1，1变0\n\t\t00000000 00000000 00000000 00000011\n\t   ~11111111 11111111 11111111 11111100 (补码)\n\t   \n\t   补码：11111111 11111111 11111111 11111100\n\t   反码：11111111 11111111 11111111 11111011\n\t   原码：10000000 00000000 00000000 00000100\n\t\t结果是：-4\n*/\n```\n\n### 位异或运算符的特点\n\n```\n/*\n\t^的特点：一个数据对另一个数据位异或两次，该数本身不变。\n*/\nclass OperatorDemo2 {\n\tpublic static void main(String[] args) {\n\t\tint a = 10;\n\t\tint b = 20;\n\t\t\n\t\tSystem.out.println(a ^ b ^ b); //10\n\t\tSystem.out.println(a ^ b ^ a); //20\n\t}\n}\n```\n\n### 位运算的面试题\n\n```\n/*\n\t面试题：\n\t\t请自己实现两个整数变量的交换\n\t\t注意：以后讲课的过程中，我没有明确指定数据的类型，默认int类型。\n*/\nclass OperatorTest {\n\tpublic static void main(String[] args) {\n\t\tint a = 10;\n\t\tint b = 20;\n\t\t\n\t\tSystem.out.println(\"a:\"+a+\",b:\"+b);\n\t\t\n\t\t//方式1：使用第三方变量(开发中用的)\n\t\t/*\n\t\tint c = a;\n\t\ta = b;\n\t\tb = c;\n\t\tSystem.out.println(\"a:\"+a+\",b:\"+b);\n\t\tSystem.out.println(\"------------\");\n\t\t*/\n\t\t\n\t\t//方式2：用位异或实现(面试用)\n\t\t//左边：a,b,a\n\t\t//右边：a ^ b\n\t\t/*\n\t\ta = a ^ b;\n\t\tb = a ^ b; //a ^ b ^ b = a\n\t\ta = a ^ b; //a ^ b ^ a = b\n\t\tSystem.out.println(\"a:\"+a+\",b:\"+b);\n\t\t*/\n\t\t\n\t\t//方式3：用变量相加的做法\n\t\t/*\n\t\ta = a + b; //a=30\n\t\tb = a - b; //b=10\n\t\ta = a - b; //a=20\n\t\tSystem.out.println(\"a:\"+a+\",b:\"+b);\n\t\t*/\n\t\t\n\t\t//方式4：一句话搞定\n\t\tb = (a+b) - (a=b); //b=30-20=10,a=20\n\t\tSystem.out.println(\"a:\"+a+\",b:\"+b);\n\t}\n}\n```\n\n### 位运算的基本用法2及面试题\n\n```\n/*\n\t<<:左移\t左边最高位丢弃，右边补齐0\n\t>>:右移\t最高位是0，左边补齐0；最高为是1，左边补齐1\n\t>>>:无符号右移 无论最高位是0还是1，左边补齐0\n\t\n\t面试题：\n\t\t请用最有效率的方式写出计算2乘以8的结果?\n\t\t\t2 * 8\n\t\t\t\n\t\t\t2 << 3\n\n*/\nclass OperatorDemo3 {\n\tpublic static void main(String[] args) {\n\t\t//<< 把<<左边的数据乘以2的移动次幂\n\t\tSystem.out.println(3 << 2); //3*2^2 = 3*4 = 12;\n\t\n\t\t//>> 把>>左边的数据除以2的移动次幂\n\t\tSystem.out.println(24 >> 2); //24 / 2^2 = 24 / 4 = 6\n\t\tSystem.out.println(24 >>> 2);\n\t\t\n\t\tSystem.out.println(-24 >> 2); \n\t\tSystem.out.println(-24 >>> 2);\n\t}\n}\n/*\n\t计算出3的二进制：11\n\t\t00000000 00000000 00000000 00000011\n\t(00)000000 00000000 00000000 0000001100\n\t\t\n\t>>的移动：\t\n\t计算出24的二进制：11000\n\t\t原码：10000000 00000000 00000000 00011000\n\t\t反码：11111111 11111111 11111111 11100111\n\t\t补码：11111111 11111111 11111111 11101000\n\t\t\n\t\t11111111 11111111 11111111 11101000\n\t\t1111111111 11111111 11111111 111010(00) 补码\n\t\t\n\t\t补码：1111111111 11111111 11111111 111010\n\t\t反码：1111111111 11111111 11111111 111001\n\t\t原码：1000000000 00000000 00000000 000110\n\t\t\n\t\t结果：-6\n\t\t\n\t>>>的移动：\n\t\t计算出24的二进制：11000\n\t\t原码：10000000 00000000 00000000 00011000\n\t\t反码：11111111 11111111 11111111 11100111\n\t\t补码：11111111 11111111 11111111 11101000\n\t\t\n\t\t11111111 11111111 11111111 11101000\n\t\t0011111111 11111111 11111111 111010(00)\n\t\t\n\t\t结果：\n*/\n```\n\n### 三元运算符的基本用法\n\n```\n/*\n\t单目运算符：~3\n\t双目运算符：3 + 4\n\n\t三目运算符：\n\t\t格式：比较表达式?表达式1:表达式2;\n\t\t\n\t\t比较表达式:结果是一个boolean类型。\n\t\t\n\t\t执行流程：\n\t\t\t根据比较表达式的计算返回一个true或者false。\n\t\t\t如果是true，就把表达式1作为结果。\n\t\t\t如果是false，就把表达式2作为结果。\n*/\nclass OperatorDemo {\n\tpublic static void main(String[] args) {\n\t\tint x = 100;\n\t\tint y = 200;\n\t\t\n\t\tint z = ((x > y)? x: y);\n\t\t\n\t\t//int z = ((x < y)? x: y);\n\t\t\n\t\t//int z = ((x == y)? x: y);\n\t\t\n\t\t//报错\n\t\t//int z = ((x = y)? x : y);\n\t\t\n\t\tSystem.out.println(\"z:\"+z);\n\t}\n}\n```\n\n### 三元运算符的练习\n\n```\n/*\n\t练习：\n\t\t获取两个整数中的最大值\n\t\t获取三个整数中的最大值\n\t\t比较两个整数是否相同\n*/\nclass OperatorTest {\n\tpublic static void main(String[] args) {\n\t\t//获取两个整数中的最大值\n\t\tint x = 100;\n\t\tint y = 200;\n\t\t\n\t\tint max = (x > y? x: y);\n\t\tSystem.out.println(\"max:\"+max);\n\t\tSystem.out.println(\"--------\");\n\t\t\n\t\t//获取三个整数中的最大值\n\t\tint a = 10;\n\t\tint b = 30;\n\t\tint c = 20;\n\t\t\n\t\t//分两步：\n\t\t//A:先比较a,b的最大值\n\t\t//B:拿a,b的最大值在和c进行比较\n\t\tint temp = ((a > b)? a: b);\n\t\t//System.out.println(temp);\n\t\tint max1 = (temp > c? temp: c);\n\t\tSystem.out.println(\"max1:\"+max1);\n\t\t\n\t\t//一步搞定\n\t\t//int max2 = (a > b)?((a > c)? a: c):((b > c)? b: c);\n\t\t//这种做法不推荐。\n\t\t//int max2 = a > b?a > c? a: c:b > c? b: c;\n\t\t//System.out.println(\"max2:\"+max2);\n\t\tSystem.out.println(\"--------\");\n\t\t\n\t\t//比较两个整数是否相同\n\t\tint m = 100;\n\t\tint n = 200;\n\t\t\n\t\t//boolean flag = (m == n)? true: false;\n\t\tboolean flag = (m == n);\n\t\tSystem.out.println(flag);\n\t}\n}\n```\n\n### 键盘录入的基本格式讲解\n\n```\n/*\n\t为了让程序的数据更符合开发的数据，我们就加入了键盘录入。\n\t让程序更灵活一下。\n\t\n\t那么，我们如何实现键盘数据的录入呢?\n\t\tA:导包\n\t\t\t格式：\n\t\t\t\timport java.util.Scanner; \n\t\t\t位置：\n\t\t\t\t在class上面。\n\t\tB:创建键盘录入对象\n\t\t\t格式：\n\t\t\t\tScanner sc = new Scanner(System.in);\n\t\tC:通过对象获取数据\t\n\t\t\t格式：\n\t\t\t\tint x = sc.nextInt();\n*/\nimport java.util.Scanner;\n\nclass ScannerDemo {\n\tpublic static void main(String[] args) {\n\t\t//创建键盘录入数据对象\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tSystem.out.println(\"请你输入一个数据：\");\n\t\tint x = sc.nextInt();\n\t\t\n\t\tSystem.out.println(\"你输入的数据是：\"+x);\n\t}\n}\n```\n\n### 键盘录入的练习1\n\n```\n/*\n\t键盘录入练习：\n\t\t键盘录入两个数据，并对这两个数据求和，输出其结果\n*/\nimport java.util.Scanner;\n\nclass ScannerTest {\n\tpublic static void main(String[] args) {\n\t\t//键盘录入两个数据，并对这两个数据求和，输出其结果\n\t\t//创建键盘录入对象\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tSystem.out.println(\"请输入第一个数据：\");\n\t\tint x = sc.nextInt();\n\t\t\n\t\tSystem.out.println(\"请输入第二个数据：\");\n\t\tint y = sc.nextInt();\n\t\t\n\t\t//把键盘录入的数据进行相加即可\n\t\tint sum = (x + y);\n\t\tSystem.out.println(\"sum:\"+sum);\n\t}\n}\n\n/*\n\t键盘录入练习：键盘录入两个数据，获取这两个数据中的最大值\n*/\n\nimport java.util.Scanner;\n\nclass ScannerTest2 {\n\tpublic static void main(String[] args) {\n\t\t//创建键盘录入对象\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tSystem.out.println(\"请输入第一个数据：\");\n\t\tint a = sc.nextInt();\n\t\t\n\t\tSystem.out.println(\"请输入第二个数据：\");\n\t\tint b = sc.nextInt();\n\t\t\n\t\t//获取这两个数据中的最大值\n\t\tint max = (a > b? a: b);\n\t\tSystem.out.println(\"max:\"+max);\n\t}\n}\n```\n\n### 键盘录入的练习2\n\n```\n/*\n\t练习：\n\t\t键盘录入三个数据，获取这三个数据中的最大值\n\t\t键盘录入两个数据，比较这两个数据是否相等\n*/\nimport java.util.Scanner;\n\nclass ScannerTest3 {\n\tpublic static void main(String[] args) {\n\t\t//键盘录入三个数据，获取这三个数据中的最大值\n\t\n\t\t//创建键盘录入对象\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tSystem.out.println(\"请输入第一个数据：\");\n\t\tint a = sc.nextInt();\n\t\t\n\t\tSystem.out.println(\"请输入第二个数据：\");\n\t\tint b = sc.nextInt();\n\t\t\n\t\tSystem.out.println(\"请输入第三个数据：\");\n\t\tint c = sc.nextInt();\n\t\t\n\t\t//获取这三个数据中的最大值\n\t\tint temp = ((a > b)? a: b);\n\t\tint max = (temp > c? temp : c);\n\t\tSystem.out.println(\"max:\"+max);\n\t\tSystem.out.println(\"------------------\");\n\t\t\n\t\t//键盘录入两个数据\n\t\tSystem.out.println(\"请输入第一个数据：\");\n\t\tint x = sc.nextInt();\n\t\t\n\t\tSystem.out.println(\"请输入第二个数据：\");\n\t\tint y = sc.nextInt();\n\t\t\n\t\t//比较这两个数据是否相等\n\t\tboolean flag = (x == y);\n\t\tSystem.out.println(\"flag:\"+flag);\n\t}\n}\n```\n\n### 顺序结构语句\n\n```\n/*\n\t流程控制语句：可以控制程序的执行流程。\n\t\n\t分类：\n\t\t顺序结构\n\t\t选择结构\n\t\t循环结构\n\t\t\n\t顺序结构：\n\t\t从上往下，依次执行。\n*/\nclass ShunXuJieGouDemo {\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(\"程序开始了\");\n\t\t\n\t\tSystem.out.println(\"我爱Java\");\n\t\t\n\t\tSystem.out.println(\"程序结束了\");\n\t}\n}\n```\n\n### 选择结构if语句格式1\n\n```\n/*\n\t选择结构：\n\t\tif语句\n\t\tswitch语句\n\t\t\n\tif语句：\n\t\t格式1\n\t\t格式2\n\t\t格式3\n\t\t\n\tif语句的格式：\n\t\tif(比较表达式) {\n\t\t\t语句体;\n\t\t}\n\t\t\n\t\t执行流程：\n\t\t\t先计算比较表达式的值，看其返回值是true还是false。\n\t\t\t如果是true，就执行语句体；\n\t\t\t如果是false，就不执行语句体；\n*/\nclass IfDemo {\n\tpublic static void main(String[] args) {\n\t\tint x = 10;\n\t\t\n\t\tif(x == 10) {\n\t\t\tSystem.out.println(\"x等于10\");\n\t\t}\n\t\t\n\t\tif(x == 20) {\n\t\t\tSystem.out.println(\"x等于20\");\n\t\t}\n\t\t\n\t\tSystem.out.println(\"over\");\n\t}\n}\n```\n\n### 选择结构if语句注意事项\n\n```\n/*\n\tif语句的注意事项：\n\t\tA:比较表达式无论简单还是复杂，结果必须是boolean类型\n\t\tB:if语句控制的语句体如果是一条语句，大括号可以省略；\n\t\t  如果是多条语句，就不能省略。建议永远不要省略。\n\t\tC:一般来说：有左大括号就没有分号，有分号就没有左大括号\n*/\nclass IfDemo2 {\n\tpublic static void main(String[] args) {\n\t\tint x = 10;\n\t\t\n\t\tif(x == 10) {\n\t\t\tSystem.out.println(\"x等于10\");\n\t\t}\n\t\t\n\t\tif((x > 5) || (x == 10)) {\n\t\t\tSystem.out.println(\"x大于或者等于10\");\n\t\t}\n\t\tSystem.out.println(\"-------------------\");\n\t\t\n\t\tint a = 100;\n\t\t\n\t\t/*\n\t\tif(a == 100) {\n\t\t\tSystem.out.println(\"a的值是100\");\n\t\t}\n\t\t*/\n\t\t\n\t\tif(a != 100) {\n\t\t\tSystem.out.println(\"a的值是100\");\n\t\t\tSystem.out.println(\"over\");\n\t\t}\n\t\tSystem.out.println(\"-------------------\");\n\t\t\n\t\tint b = 100;\n\t\tif(b != 100);  //这里其实是有语句体的，只不过是空语句体。\n\t\t\n\t\t//代码块\n\t\t{\n\t\t\tSystem.out.println(\"b的值是100\");\n\t\t\tSystem.out.println(\"over\");\n\t\t}\n\t}\n}\n```\n\n### 选择结构if语句格式2\n\n```\n/*\n\tif语句格式2：\n\t\tif(比较表达式) {\n\t\t\t语句体1;\n\t\t}else {\n\t\t\t语句体2;\n\t\t}\n\t执行流程：\n\t\t首先计算比较表达式的值，看其返回值是true还是false。\n\t\t如果是true，就执行语句体1；\n\t\t如果是false，就执行语句体2；\n\t\t\n\t注意：else后面是没有比较表达式的，只有if后面有。\n*/\nclass IfDemo3 {\n\tpublic static void main(String[] args) {\n\t\t//判断两个数据是否相等\n\t\t\n\t\tint a = 10;\n\t\tint b = 20;\n\t\t\n\t\tif(a == b) {\n\t\t\tSystem.out.println(\"a等于b\");\n\t\t}else {\n\t\t\tSystem.out.println(\"a不等于b\");\n\t\t}\n\t}\n}\n```\n\n### 选择结构if语句格式2的练习\n\n```\n/*\n\tif语句格式2的练习：\n\t\tA:获取两个数据中较大的值\n\t\tB:判断一个数据是奇数还是偶数,并输出是奇数还是偶数\n*/\nimport java.util.Scanner;\n\nclass IfTest {\n\tpublic static void main(String[] args) {\n\t\t//创建键盘录入对象\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\t//获取两个数据中较大的值\n\t\tSystem.out.println(\"请输入第一个数据：\");\n\t\tint a = sc.nextInt();\n\t\t\n\t\tSystem.out.println(\"请输入第二个数据：\");\n\t\tint b = sc.nextInt();\n\t\t\n\t\t//定义一个变量接收最大值\n\t\tint max;\n\t\t\n\t\tif(a > b) {\n\t\t\tmax = a;\n\t\t}else {\n\t\t\tmax = b;\n\t\t}\n\t\t\n\t\tSystem.out.println(\"max:\"+max);\n\t\tSystem.out.println(\"----------------\");\n\t\t\n\t\t//判断一个数据是奇数还是偶数\n\t\tSystem.out.println(\"请输入你要判断的数据：\");\n\t\tint x = sc.nextInt();\n\t\t\n\t\tif(x%2 == 0) {\n\t\t\tSystem.out.println(x+\"这个数据是偶数\");\n\t\t}else {\n\t\t\tSystem.out.println(x+\"这个数据是奇数\");\n\t\t}\n\t}\n}\n```\n\n### if语句的格式2和三元的相互转换问题\n\n```\n/*\n\t由于if语句的第二种格式刚才也完成了三元运算符可以完成的效果。\n\t所以，我们就认为他们可以完成一样的操作。\n\t但是，他们就一点区别没有吗?肯定不是。\n\t\n\t区别：\n\t\t三元运算符实现的，都可以采用if语句实现。反之不成立。\n\t\t\n\t\t什么时候if语句实现不能用三元改进呢?\n\t\t\t当if语句控制的操作是一个输出语句的时候就不能。\n\t\t\t为什么呢?因为三元运算符是一个运算符，运算符操作完毕就应该有一个结果，而不是一个输出。\n*/\nclass IfDemo4 {\n\tpublic static void main(String[] args) {\n\t\t//获取两个数据的最大值\n\t\tint a = 10;\n\t\tint b = 20;\n\t\t\n\t\t//用if语句实现\n\t\tint max1;\n\t\tif(a > b) {\n\t\t\tmax1 = a;\n\t\t}else {\n\t\t\tmax1 = b;\n\t\t}\n\t\tSystem.out.println(\"max1:\"+max1);\n\t\t\n\t\t//用三元改进\n\t\tint max2 = (a > b)? a: b;\n\t\tSystem.out.println(\"max2:\"+max2);\n\t\tSystem.out.println(\"----------\");\n\t\t\n\t\t//判断一个数据是奇数还是偶数,并输出是奇数还是偶数\n\t\tint x = 100;\n\t\t\n\t\tif(x%2 == 0) {\n\t\t\tSystem.out.println(\"100是一个偶数\");\n\t\t}else {\n\t\t\tSystem.out.println(\"100是一个奇数\");\n\t\t} \n\t\t\n\t\t//用三元改进\n\t\t//这种改进是错误的。\n\t\t//String s = (x%2 == 0)?System.out.println(\"100是一个偶数\");:System.out.println(\"100是一个奇数\");;\n\t}\n}\n```\n\n### 选择结构if语句格式3\n\n```\n/*\n\tif语句的格式3：\n\t\tif(比较表达式1) {\n\t\t\t语句体1;\n\t\t}else if(比较表达式2) {\n\t\t\t语句体2;\n\t\t}else if(比较表达式3) {\n\t\t\t语句体3;\n\t\t}\n\t\t...\n\t\telse {\n\t\t\t语句体n+1;\n\t\t}\n\t\t\n\t执行流程：\n\t\t首先计算比较表达式1看其返回值是true还是false，\n\t\t如果是true，就执行语句体1，if语句结束。\n\t\t如果是false，接着计算比较表达式2看其返回值是true还是false，\n\t\t\n\t\t如果是true，就执行语句体2，if语句结束。\n\t\t如果是false，接着计算比较表达式3看其返回值是true还是false，\n\t\t...\n\t\t\n\t\t如果都是false，就执行语句体n+1。\n*/\nimport java.util.Scanner;\n\nclass IfDemo5 {\n\tpublic static void main(String[] args) {\n\t\t//需求：键盘录入一个成绩，判断并输出成绩的等级。\n\t\t/*\n\t\t\t90-100 优秀\n\t\t\t80-90  好\n\t\t\t70-80  良\n\t\t\t60-70  及格\n\t\t\t0-60   不及格\n\t\t*/\n\t\t\n\t\t//创建键盘录入对象\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\t//录入数据\n\t\tSystem.out.println(\"请输入你的考试成绩：\");\n\t\tint score = sc.nextInt();\n\t\t\n\t\t/*\n\t\tif(score>=90 && score<=100) {\n\t\t\tSystem.out.println(\"优秀\");\n\t\t}else if(score>=80 && score<90) {\n\t\t\tSystem.out.println(\"好\");\n\t\t}else if(score>=70 && score<80) {\n\t\t\tSystem.out.println(\"良\");\n\t\t}else if(score>=60 && score<70) {\n\t\t\tSystem.out.println(\"及格\");\n\t\t}else {\n\t\t\tSystem.out.println(\"不及格\");\n\t\t}\n\t\t*/\n\t\t//这样写已经满足我的基本要求，但是可能别人在使用的时候，不会按照你要求的数据给出了。\n\t\t//在做一个程序的基本测试的时候，一定要考虑这样的几个问题：\n\t\t//正确数据，错误数据，边界数据。\n\t\t//而我们刚才写的程序并没有处理错误数据，所以这个程序不是很好，要改进\n\t\t/*\n\t\tif(score>=90 && score<=100) {\n\t\t\tSystem.out.println(\"优秀\");\n\t\t}else if(score>=80 && score<90) {\n\t\t\tSystem.out.println(\"好\");\n\t\t}else if(score>=70 && score<80) {\n\t\t\tSystem.out.println(\"良\");\n\t\t}else if(score>=60 && score<70) {\n\t\t\tSystem.out.println(\"及格\");\n\t\t}else if(score>=0 && score<60){\n\t\t\tSystem.out.println(\"不及格\");\n\t\t}else {\n\t\t\tSystem.out.println(\"你输入的成绩有误\");\n\t\t}\n\t\t*/\n\t\t\n\t\t//另一种判断改进\n\t\tif(score<0 || score>100) {\n\t\t\tSystem.out.println(\"你输入的成绩有误\");\n\t\t}else if(score>=90 && score<=100) {\n\t\t\tSystem.out.println(\"优秀\");\n\t\t}else if(score>=80 && score<90) {\n\t\t\tSystem.out.println(\"好\");\n\t\t}else if(score>=70 && score<80) {\n\t\t\tSystem.out.println(\"良\");\n\t\t}else if(score>=60 && score<70) {\n\t\t\tSystem.out.println(\"及格\");\n\t\t}else {\n\t\t\tSystem.out.println(\"不及格\");\n\t\t}\n\t}\n}\n```\n\n### 选择结构if语句格式3的练习\n\n```\n/*\n\t键盘录入月份的值，输出对应的季节。\n\t\n\t春\t3,4,5\n\t夏\t6,7,8\n\t秋\t9,10,11\n\t冬\t12,1,2\n\t\n\t分析：\n\t\tA:键盘录入月份的值，所以我们要使用Scanner。\n\t\tB:我们应该判断这个月份在那个季节，而这个判断情况较多，所以，用if语句格式3。\n\t\t\n\tif语句的使用场景：\n\t\tA:针对表达式是一个boolean类型的判断\n\t\tB:针对一个范围的判断\n*/\nimport java.util.Scanner;\n\nclass IfTest3 {\n\tpublic static void main(String[] args) {\n\t\t//创建键盘录入对象\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\t//录入数据\n\t\tSystem.out.println(\"请你输入一个月份:\");\n\t\tint month = sc.nextInt();\n\t\t\n\t\t//第三种格式实现即可\n\t\tif(month<1 || month>12) {\n\t\t\tSystem.out.println(\"你输入的月份有误\");\n\t\t}else if(month == 1) {\n\t\t\tSystem.out.println(\"冬季\");\n\t\t}else if(month == 2) {\n\t\t\tSystem.out.println(\"冬季\");\n\t\t}else if(month == 3) {\n\t\t\tSystem.out.println(\"春季\");\n\t\t}else if(month == 4) {\n\t\t\tSystem.out.println(\"春季\");\n\t\t}else if(month == 5) {\n\t\t\tSystem.out.println(\"春季\");\n\t\t}else if(month == 6) {\n\t\t\tSystem.out.println(\"夏季\");\n\t\t}else if(month == 7) {\n\t\t\tSystem.out.println(\"夏季\");\n\t\t}else if(month == 8) {\n\t\t\tSystem.out.println(\"夏季\");\n\t\t}else if(month == 9) {\n\t\t\tSystem.out.println(\"秋季\");\n\t\t}else if(month == 10) {\n\t\t\tSystem.out.println(\"秋季\");\n\t\t}else if(month == 11) {\n\t\t\tSystem.out.println(\"秋季\");\n\t\t}else {\n\t\t\tSystem.out.println(\"冬季\");\n\t\t}\n\t\tSystem.out.println(\"--------------\");\n\t\t\n\t\t//这个程序确实是符合了我们的需求，但是就是看起来比较麻烦\n\t\t//那么，我们能不能改进一下呢?\n\t\t//month == 3\n\t\t//month == 4\n\t\t//month == 5\n\t\t//我们发现，上面三个都是春季。\n\t\t//而他们本身每一个都是一个boolean表达式\n\t\t//所以，我们就可以考虑使用逻辑运算符给他们连接起来改进\n\t\tif(month<1 || month>12) {\n\t\t\tSystem.out.println(\"你输入的月份有误\");\n\t\t}else if(month==3 || month==4 || month==5) {\n\t\t\tSystem.out.println(\"春季\");\n\t\t}else if(month==6 || month==7 || month==8) {\n\t\t\tSystem.out.println(\"夏季\");\n\t\t}else if(month==9 || month==10 || month==11) {\n\t\t\tSystem.out.println(\"秋季\");\n\t\t}else {\n\t\t\tSystem.out.println(\"冬季\");\n\t\t}\n\t\tSystem.out.println(\"--------------\");\n\t\t\n\t\t//这个时候，程序代码以及可以了。\n\t\t//但是呢，假如我要求你输入一个月份，判断是上半年还是下半年。\n\t\t//这个时候，我们的判断条件连接就是6个boolean表达式\n\t\t//我们可能还有更多的连接\n\t\t//这个时候，其实我们还有另外的一种改进方案：\n\t\t//month == 3\n\t\t//month == 4\n\t\t//month == 5\n\t\t//month>=3 && month<=5\n\t\t//用范围也是可以改进的。\n\t\tif(month<1 || month>12) {\n\t\t\tSystem.out.println(\"你输入的月份有误\");\n\t\t}else if(month>=3 && month<=5) {\n\t\t\tSystem.out.println(\"春季\");\n\t\t}else if(month>=6 && month<=8) {\n\t\t\tSystem.out.println(\"夏季\");\n\t\t}else if(month>=9 && month<=11) {\n\t\t\tSystem.out.println(\"秋季\");\n\t\t}else {\n\t\t\tSystem.out.println(\"冬季\");\n\t\t}\n\t\tSystem.out.println(\"--------------\");\n\t}\n}\n```\n\n### 选择结构if语句的嵌套使用\n\n```\n/*\n\t获取三个数据中的最大值\n\t\n\t由此案例主要是为了讲解if语句是可以嵌套使用的。而且是可以任意的嵌套。\n*/\nclass IfTest4 {\n\tpublic static void main(String[] args) {\n\t\tint a = 10;\n\t\tint b = 30;\n\t\tint c = 20;\n\t\t\n\t\t//三元实现\n\t\t//int temp = (a>b)? a: b;\n\t\t//int max = (temp>c)? temp: c;\n\t\t//System.out.println(\"max:\"+max);\n\t\t//System.out.println(\"--------\");\n\t\t\n\t\t//用if语句实现\n\t\tint max;\n\t\tif(a > b) {\n\t\t\tif(a > c) {\n\t\t\t\tmax = a;\n\t\t\t}else {\n\t\t\t\tmax = c;\n\t\t\t}\n\t\t}else {\n\t\t\tif(b > c) {\n\t\t\t\tmax = b;\n\t\t\t}else {\n\t\t\t\tmax = c;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"max:\"+max);\n\t}\n}\n```\n","tags":["Java系统学习"],"categories":["Java系统学习-JavaSE篇"]},{"title":"Constructing Roads（POJ-2421）（最小生成树）","url":"/2020/05/12/Constructing Roads（POJ-2421）（最小生成树）/","content":"\nThere are N villages, which are numbered from 1 to N, and you should build some roads such that every two villages can connect to each other. We say two village A and B are connected, if and only if there is a road between A and B, or there exists a village C such that there is a road between A and C, and C and B are connected.\n\n<!--more-->\n\nWe know that there are already some roads between some villages and your job is the build some roads such that all the villages are connect and the length of all the roads built is minimum.\nInput\nThe first line is an integer N (3 <= N <= 100), which is the number of villages. Then come N lines, the i-th of which contains N integers, and the j-th of these N integers is the distance (the distance should be an integer within [1, 1000]) between village i and village j.\n\nThen there is an integer Q (0 <= Q <= N * (N + 1) / 2). Then come Q lines, each line contains two integers a and b (1 <= a < b <= N), which means the road between village a and village b has been built.\nOutput\nYou should output a line contains an integer, which is the length of all the roads to be built such that all the villages are connected, and this value is minimum.\nSample Input\n3\n0 990 692\n\n990 0 179\n\n692 179 0\n\n1\n\n1 2\n\nSample Output\n179\n\n**题意：**\n**要修公路，输入一个n，表示n个村庄。接着输入n*n的矩阵，该图的邻接矩阵，然后输入一个q 接下来的q行，每行包含两个数a，b，表示a、b这条边联通，就是已经有公路不用修了，要让所有村庄联通在一起问：修路最小代价是多少。**\n\n**思路：**\n**这道题的话，根据题目输入构造邻接矩阵，然后把已经联通的村庄的距离设置为0，表示不用在修这条公路。然后用Prim算法即可。**\n\n**AC代码：**\n\n```\n#include <stdio.h>\n#include <string>\n#include <string.h>\n#include <iostream>\n#include <algorithm>\n#include <math.h>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\ntypedef long long ll;\nconst int maxx = 10010;\nconst int mod = 10007;\nconst int inf = 0x3f3f3f3f;\nconst double eps = 1e-8;\nusing namespace std;\nint mapp[maxx][maxx];\nint dis[maxx];\nbool vis[maxx];\nint n;\nvoid Prim()\n{\n    int sum = 0;\n    int now;\n    for (int i = 1; i <= n; i++)\n    {\n        dis[i] = i;\n        vis[i] = false;\n    }\n    for (int i = 1; i <= n; i++)\n        dis[i] = mapp[1][i];\n    dis[1] = 0;\n    vis[1] = true;\n    for (int i = 1; i < n; i++)\n    {\n        now = inf;\n        int minn = inf;\n        for (int j = 1; j <= n; j++)\n        {\n            if (!vis[j] && dis[j] < minn)\n            {\n                now = j;\n                minn = dis[j];\n            }\n        }\n        if(now == inf)\n        break;\n        vis[now] = true;\n        sum += minn;\n        for (int j = 1; j <= n; j++)\n        {\n            if (!vis[j] && dis[j] > mapp[now][j])\n                dis[j] = mapp[now][j];\n        }\n    }\n    printf(\"%d\\n\", sum);\n}\nint main()\n{\n    while (~scanf(\"%d\", &n))\n    {\n        for (int i = 1; i <= n; i++)\n            for (int j = 1; j <= n; j++)\n                scanf(\"%d\", &mapp[i][j]);\n        int q, a, b;\n        scanf(\"%d\", &q);\n        for (int i = 1; i <= q; i++)\n        {\n            scanf(\"%d%d\", &a, &b);\n            mapp[a][b] = mapp[b][a] = 0;\n        }\n        Prim();\n    }\n    return 0;\n}\n```\n","tags":["最小生成树"],"categories":["最小生成树"]},{"title":"QS Network（ZOJ-1586）（最小生成树）","url":"/2020/05/12/QS Network（ZOJ-1586）（最小生成树）/","content":"\nSunny Cup 2003 - Preliminary Round\nApril 20th, 12:00 - 17:00\n\nProblem E: QS Network\n\n<!--more-->\n\nIn the planet w-503 of galaxy cgb, there is a kind of intelligent creature named QS. QScommunicate with each other via networks. If two QS want to get connected, they need to buy two network adapters (one for each QS) and a segment of network cable. Please be advised that ONE NETWORK ADAPTER CAN ONLY BE USED IN A SINGLE CONNECTION.(ie. if a QS want to setup four connections, it needs to buy four adapters). In the procedure of communication, a QS broadcasts its message to all the QS it is connected with, the group of QS who receive the message broadcast the message to all the QS they connected with, the procedure repeats until all the QS's have received the message.\n\nA sample is shown below:\n\n![tupian](https://vj.z180.cn/1120637f03c5c4bc9402775a6100caa8?v=1589071552)\n\nA sample QS network, and QS A want to send a message.\n\nStep 1. QS A sends message to QS B and QS C;\n\nStep 2. QS B sends message to QS A ; QS C sends message to QS A and QS D;\n\nStep 3. the procedure terminates because all the QS received the message.\n\nEach QS has its favorate brand of network adapters and always buys the brand in all of its connections. Also the distance between QS vary. Given the price of each QS's favorate brand of network adapters and the price of cable between each pair of QS, your task is to write a program to determine the minimum cost to setup a QS network.\n\n\nInput\n\nThe 1st line of the input contains an integer t which indicates the number of data sets.\n\nFrom the second line there are t data sets.\n\nIn a single data set,the 1st line contains an interger n which indicates the number of QS.\n\nThe 2nd line contains n integers, indicating the price of each QS's favorate network adapter.\n\nIn the 3rd line to the n+2th line contain a matrix indicating the price of cable between ecah pair of QS.\n\nConstrains:\n\nall the integers in the input are non-negative and not more than 1000.\n\n\nOutput\n\nfor each data set,output the minimum cost in a line. NO extra empty lines needed.\n\n\nSample Input\n\n1\n\n3\n\n10 20 30\n\n0 100 200\n\n100 0 300\n\n200 300 0\n\nSample Output\n\n370\n\n**题意：**\n**第一行给出T，代表有T组数据。每组数据第一行给出N，代表图有N个结点。接着一行给出N个数，代表每个结点的权值（就是接收器的费用），接着N行每行N个数，矩阵的形式给出各点之间边的权值（也就是连接接收器网线的费用）。最后实际权值就是边的权值加上两个点的权值，输出最小生成树的权值总和即可。**\n\n**思路：**\n**这道题的话，因为输入的是矩阵，我们用Prim算法更好一些，套下模板即可。**\n\n**AC代码：**\n\n```\n#include <stdio.h>\n#include <string>\n#include <string.h>\n#include <iostream>\n#include <algorithm>\n#include <math.h>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\ntypedef long long ll;\nconst int maxx = 10010;\nconst int mod = 10007;\nconst int inf = 0x3f3f3f3f;\nconst double eps = 1e-8;\nusing namespace std;\nint mapp[maxx][maxx];\nint dis[maxx];\nint val[maxx];\nbool vis[maxx];\nint n;\nvoid Prim()\n{\n    int sum = 0;\n    int now;\n    for (int i = 1; i <= n; i++)\n    {\n        dis[i] = i;\n        vis[i] = false;\n    }\n    for (int i = 1; i <= n; i++)\n        dis[i] = mapp[1][i];\n    dis[1] = 0;\n    vis[1] = true;\n    for (int i = 1; i < n; i++)\n    {\n        now = inf;\n        int minn = inf;\n        for (int j = 1; j <= n; j++)\n        {\n            if (!vis[j] && dis[j] < minn)\n            {\n                now = j;\n                minn = dis[j];\n            }\n        }\n        if (now == inf)\n            break;\n        vis[now] = true;\n        sum += minn;\n        for (int j = 1; j <= n; j++)\n        {\n            if (!vis[j] && dis[j] > mapp[now][j])\n                dis[j] = mapp[now][j];\n        }\n    }\n    printf(\"%d\\n\", sum);\n}\nint main()\n{\n    int t;\n    scanf(\"%d\", &t);\n    while (t--)\n    {\n        scanf(\"%d\", &n);\n        for (int i = 1; i <= n; i++)\n            scanf(\"%d\", &val[i]);\n        for (int i = 1; i <= n; i++)\n            for (int j = 1; j <= n; j++)\n            {\n                scanf(\"%d\", &mapp[i][j]);\n                mapp[i][j] += val[i] + val[j];\n            }\n        Prim();\n    }\n    return 0;\n}\n```\n","tags":["最小生成树"],"categories":["最小生成树"]},{"title":"再次温习最小生成树的一些思路","url":"/2020/05/12/再次温习最小生成树的一些思路/","content":"\n## 写在前面\n\n因为之前4月份打了将近一个月的个人赛，有些以前学习过的算法已经忘了，所以重新再温习一遍。\n\n<!--more-->\n\n## 关于最小生成树\n\n**最小生成树（minimum spanning tree）是由n个顶点，n-1条边，将一个连通图连接起来，且使权值最小的结构。\n最小生成树可以用Prim（普里姆）算法或kruskal（克鲁斯卡尔）算法求出。**\n\n## Kruskal算法详解及模板与例题\n\n### Kruskal算法简介\n\n**Kruskal算法是基于并查集算法而进行的，很简单的思路就是，对一张图，将所有的边都拆出来，然后对每条边的边权进行排序（从大到小，从小到大看题目需要），然后再将边连回去，连边的时候判断两个点是否被连通了，如果是连通的，那么就将该边扔了再看下一条边，如果没有被连通，那么就将该条边连上，然后用并查集合并即可。**\n\n**时间复杂度：O（NlogN）（N为边数）\nkruskal算法又称“加边法”，用于边数较少的稀疏图\n方法：每次找图中权值最小的边，将边连接的两个顶点加入最小生成树集合中\n注意：相同权值任选其中一个即可，但是不允许出现闭合回路的情况。**\n\n### Kruskal算法图解\n\n![tupian1](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwODIwMTE1NjM2MTE3?x-oss-process=image/format,png)\n\n![tupian2](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwODIwMTE1NjQ2MzA4?x-oss-process=image/format,png)\n\n![tupian3](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwODIwMTE1NjU4MzI0?x-oss-process=image/format,png)\n\n![tupian4](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwODIwMTE1NzExODQ1?x-oss-process=image/format,png)\n\n![tupian5](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwODIwMTE1NzIzMTg5?x-oss-process=image/format,png)\n\n![tupian6](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwODIwMTE1NzMyNjMy?x-oss-process=image/format,png)\n\n### Kruskal算法代码详解及模板\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxx = 200010;\nconst int inf = 0x3f3f3f3f;\nusing namespace std;\nint pre[maxx];\nint n;\nstruct node//存边权值\n{\n    int s;\n    int e;\n    int v;\n} edge[maxx];\nbool cmp(node a, node b)//看情况修改 优先级给小边权还是大边权\n{\n    return a.v < b.v;\n}\nvoid init()//初始化\n{\n    for (int i = 0; i <= n; i++)\n        pre[i] = i;\n}\nint getf(int a)//并查集 看两点是否在同一个图内\n{\n    if (pre[a] == a)\n        return a;\n    int tmp = getf(pre[a]);\n    return pre[a] = tmp;\n}\nint Kruskal(int a, int b) //并查集合并操作，看是否在同一个图内 如果在就跳过 不在就合并\n{\n    int fa = getf(a);\n    int fb = getf(b);\n    if (fa != fb)\n    {\n        pre[fa] = fb;\n        return 1;\n    }\n    else\n        return 0;\n}\nint main()\n{\n    while (~scanf(\"%d\", &n), n)\n    {\n        init();\n        int m = (n * (n - 1)) / 2;\n        for (int i = 1; i <= m; i++)\n            scanf(\"%d%d%d\", &edge[i].s, &edge[i].e, &edge[i].v);\n        sort(edge + 1, edge + m + 1, cmp);\n        int ans = 0;\n        for (int i = 1; i <= m; i++)\n        {\n            if (Kruskal(edge[i].s, edge[i].e))\n                ans += edge[i].v;\n        }\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}\n```\n\n### Kruskal算法例题\n\n**例题一：POJ-1287**\n\n```\n#include <stdio.h>\n#include <string>\n#include <string.h>\n#include <iostream>\n#include <algorithm>\n#include <math.h>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\ntypedef long long ll;\nconst int maxx = 10010;\nconst int mod = 10007;\nconst int inf = 0x3f3f3f3f;\nconst double eps = 1e-8;\nusing namespace std;\nstruct node\n{\n    int s;\n    int e;\n    int v;\n} edge[maxx];\nbool cmp(node a, node b)\n{\n    return a.v < b.v;\n}\nint pre[maxx];\nint n, r;\nvoid init()\n{\n    for (int i = 0; i <= n; i++)\n        pre[i] = i;\n}\nint getf(int a)\n{\n    if (pre[a] == a)\n        return a;\n    int tmp = getf(pre[a]);\n    return pre[a] = tmp;\n}\nint Kruskal(int a, int b)\n{\n    int fa = getf(a);\n    int fb = getf(b);\n    if (fa != fb)\n    {\n        pre[fa] = fb;\n        return 1;\n    }\n    else\n        return 0;\n}\nint main()\n{\n    while (~scanf(\"%d%d\", &n, &r), n)\n    {\n        init();\n        for (int i = 1; i <= r; i++)\n            scanf(\"%d%d%d\", &edge[i].s, &edge[i].e, &edge[i].v);\n        sort(edge + 1, edge + r + 1, cmp);\n        int ans = 0;\n        for (int i = 1; i <= r; i++)\n        {\n            if (Kruskal(edge[i].s, edge[i].e))\n                ans += edge[i].v;\n        }\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}\n```\n\n## Prim算法详解及模板与例题\n\n### Prim算法简介\n\n**时间复杂度：O（N^2）（N为顶点数）\nprim算法又称“加点法”，用于边数较多的带权无向连通图\n方法：每次找与之连线权值最小的顶点，将该点加入最小生成树集合中\n注意：相同权值任选其中一个即可，但是不允许出现闭合回路的情况。**\n\n### Prim算法图解\n\n![tupian1](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwODIwMTEzODU0ODA3?x-oss-process=image/format,png)\n\n![tupian2](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwODIwMTEzOTA1MTQ0?x-oss-process=image/format,png)\n\n![tupian3](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwODIwMTEzOTEzODk1?x-oss-process=image/format,png)\n\n![tupian4](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwODIwMTEzOTIxMDQ3?x-oss-process=image/format,png)\n\n![tupian5](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwODIwMTEzOTI5Mjcz?x-oss-process=image/format,png)\n\n![tupian6](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwODIwMTEzOTM4NDI0?x-oss-process=image/format,png)\n\n![tupian7](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwODIwMTEzOTQ2MTQx?x-oss-process=image/format,png)\n\n### Prim算法代码详解及模板\n\n```\n#include <stdio.h>\n#include <string>\n#include <string.h>\n#include <iostream>\n#include <algorithm>\n#include <math.h>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\ntypedef long long ll;\nconst int maxx = 210;\nconst int mod = 10007;\nconst int inf = 0x3f3f3f3f;\nconst double eps = 1e-8;\nusing namespace std;\nint mapp[maxx][maxx]; //存图\nint dis[maxx];        //记录任意一点到这个点的最近距离\nbool vis[maxx];       //用来标记0和1  表示这个点是否被选择过\nint n;\nvoid Prim()\n{\n    int sum = 0;\n    int now;\n    for (int i = 1; i <= n; i++) //初始化\n    {\n        dis[i] = inf;\n        vis[i] = false;\n    }\n    for (int i = 1; i <= n; i++) //选择1为起始点，初始化\n        dis[i] = mapp[1][i];\n    dis[1] = 0;                 //起点的上一个节点没有节点，所以为0\n    vis[1] = true;              //定义起点已经加入了最小生成树\n    for (int i = 1; i < n; i++) //循环找最小边，循环n-1次\n    {\n        now = inf;\n        int minn = inf;\n        for (int j = 1; j <= n; j++) //找dis最小的节点并加入最小生成树\n        {\n            if (!vis[j] && dis[j] < minn)\n            {\n                now = j;//找出最小的顶点\n                minn = dis[j];//找出权值最短的路径长度\n            }\n        }\n        if (now == inf)\n            break; //防止不成图\n        vis[now] = true;\n        sum += minn;//求和\n        for (int j = 1; j <= n; j++) //添入新点后更新最小距离\n        {\n            if (!vis[j] && dis[j] > mapp[now][j])\n                dis[j] = mapp[now][j];\n        }\n    }\n    printf(\"%d\\n\", sum);\n}\nint main()\n{\n    while (~scanf(\"%d\", &n), n)\n    {\n        for (int i = 1; i <= n; i++) //初始化邻接矩阵\n            for (int j = 1; j <= n; j++)\n            {\n                if (i == j)\n                    mapp[i][j] = 0;\n                else\n                    mapp[i][j] = inf;\n            }\n        int a,b,c;\n        for (int i = 1; i < n; i++)\n        {\n            scanf(\"%d%d%d\",&a,&b,&c);\n            mapp[a][b] = mapp[b][a] = c;\n        }\n        Prim();\n    }\n    return 0;\n}\n```\n\n### Prim算法例题\n\n**例题一：POJ-1251**\n\n```\n#include <stdio.h>\n#include <string>\n#include <string.h>\n#include <iostream>\n#include <algorithm>\n#include <math.h>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\ntypedef long long ll;\nconst int maxx = 210;\nconst int mod = 10007;\nconst int inf = 0x3f3f3f3f;\nconst double eps = 1e-8;\nusing namespace std;\nint mapp[maxx][maxx];\nint dis[maxx];\nbool vis[maxx];\nint n;\nvoid Prim()\n{\n    int sum = 0;\n    int now;\n    for (int i = 1; i <= n; i++)\n    {\n        dis[i] = inf;\n        vis[i] = false;\n    }\n    for (int i = 1; i <= n; i++)\n        dis[i] = mapp[1][i];\n    dis[1] = 0;\n    vis[1] = true;\n    for (int i = 1; i < n; i++)\n    {\n        now = inf;\n        int minn = inf;\n        for (int j = 1; j <= n; j++)\n        {\n            if (!vis[j] && dis[j] < minn)\n            {\n                now = j;\n                minn = dis[j];\n            }\n        }\n        if (now == inf)\n            break;\n        vis[now] = true;\n        sum += minn;\n        for (int j = 1; j <= n; j++)\n        {\n            if (!vis[j] && dis[j] > mapp[now][j])\n                dis[j] = mapp[now][j];\n        }\n    }\n    printf(\"%d\\n\", sum);\n}\nint main()\n{\n    char a, b;\n    int num1, num2;\n    int x, y;\n    while (~scanf(\"%d\", &n), n)\n    {\n        for (int i = 1; i <= n; i++)\n            for (int j = 1; j <= n; j++)\n            {\n                if (i == j)\n                    mapp[i][j] = 0;\n                else\n                    mapp[i][j] = inf;\n            }\n\n        for (int i = 1; i < n; i++)\n        {\n            cin >> a >> num1;\n            for (int j = 1; j <= num1; j++)\n            {\n                cin >> b >> num2;\n                x = a - 64;\n                y = b - 64;\n                mapp[x][y] = mapp[y][x] = num2;\n            }\n        }\n        Prim();\n    }\n    return 0;\n}\n```\n\n**例题二：Hihocoder-1097**\n\n```\n#include <stdio.h>\n#include <string>\n#include <string.h>\n#include <iostream>\n#include <algorithm>\n#include <math.h>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\ntypedef long long ll;\nconst int maxx = 10010;\nconst int mod = 10007;\nconst int inf = 0x3f3f3f3f;\nconst double eps = 1e-8;\nusing namespace std;\nint mapp[maxx][maxx];\nint dis[maxx];\nbool vis[maxx];\nint n;\nvoid Prim()\n{\n    int sum = 0;\n    int now;\n    for (int i = 1; i <= n; i++)\n    {\n        dis[i] = inf;\n        vis[i] = false;\n    }\n    for (int i = 1; i <= n; i++)\n        dis[i] = mapp[1][i];\n    dis[1] = 0;\n    vis[1] = true;\n    for (int i = 1; i < n; i++)\n    {\n        now = inf;\n        int minn = inf;\n        for (int j = 1; j <= n; j++)\n        {\n            if (!vis[j] && dis[j] < minn)\n            {\n                now = j;\n                minn = dis[j];\n            }\n        }\n        if (now == inf)\n            break;\n        vis[now] = true;\n        sum += minn;\n        for (int j = 1; j <= n; j++)\n        {\n            if (!vis[j] && dis[j] > mapp[now][j])\n                dis[j] = mapp[now][j];\n        }\n    }\n    printf(\"%d\\n\", sum);\n}\nint main()\n{\n    while (~scanf(\"%d\", &n))\n    {\n        for (int i = 1; i <= n; i++)\n            for (int j = 1; j <= n; j++)\n            {\n                if (i == j)\n                    mapp[i][j] = 0;\n                else\n                    mapp[i][j] = inf;\n            }\n        int a;\n        for (int i = 1; i <= n; i++)\n            for (int j = 1; j <= n; j++)\n            {\n                scanf(\"%d\", &a);\n                if (a < mapp[i][j])\n                    mapp[i][j] = mapp[j][i] = a;\n            }\n        Prim();\n    }\n    return 0;\n}\n```\n","tags":["最小生成树再温"],"categories":["算法重温"]},{"title":"Codeforces 625(Div.2)","url":"/2020/05/11/Codeforces 625(Div.2)/","content":"\n**A题**\n\n题意：输入两组数，为1表示有该任务，0表示没有，现在由你定义每个任务的分数，使得最高分最小的情况下，第一个人的总分大于第二个人，如果无法满足，输出-1。\n\n<!--more-->\n\n思路：这道题的话，先处理两个人的特有任务，如果第一个人特有的任务第二个人都有，那么一定无法满足，因为两个人任务的分数是相同的，第二个人特有的任务按照题目要求，应当为1分，第一个人的特有任务，按照第二个人特有任务的数量，平均分配即可。\n\nAC代码：\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxx = 100010;\nconst int inf = 0x3f3f3f3f;\nusing namespace std;\nint a[maxx];\nint b[maxx];\nint main()\n{\n    int n;\n    while (cin >> n)\n    {\n        for (int i = 1; i <= n; i++)\n            cin >> a[i];\n        for (int i = 1; i <= n; i++)\n            cin >> b[i];\n        int ans1 = 0, ans2 = 0;\n        for (int i = 1; i <= n; i++)\n        {\n            if (a[i] + b[i] == 1)\n            {\n                ans1 += a[i];\n                ans2 += b[i];\n            }\n        }\n        if (ans1 == 0)\n            cout << \"-1\" << endl;\n        else\n            cout << (ans1 + ans2) / ans1 << endl;\n    }\n    return 0;\n}\n```\n\n**B题**\n\n题意 ：有n个数，对于Ai和Aj这两个数，如果满足Ai-Aj=i-j，那么两个数就可以求和，输出整个数组能够求和的最大值。\n\n思路：这道题的话，因为每个城市有beauty值b，可以相互连通的城市i和j之间 i-j==b[i]-b[j]，所以i-b[i]==j-b[j]，所以可以连通的所有城市i-b[i]都是相等的，所以我们记录可以给到每一个差值的beauty值之和再取max就可以了。\n\nAC代码：\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxx = 200010;\nconst int inf = 0x3f3f3f3f;\nusing namespace std;\nunordered_map<ll, ll> mp;\nint main()\n{\n    int n;\n    cin >> n;\n    ll a;\n    ll ans = -1;\n    for (ll i = 1; i <= n; i++)\n    {\n        cin >> a;\n        mp[a - i] += a;\n        ans = max(ans, mp[a - i]);\n    }\n    cout << ans << endl;\n    return 0;\n}\n```\n\n**C题**\n\n题意：一个字符串，如果与某个位置相邻的字母，至少有一个比该位置的字母小1，那么该位置的字母就可以删掉，剩下的字母接上来，输出对于整个字符串，最多可以删多少个字母。\n\n思路：这道题的话，直接暴力，不难想到先删字母大的，然后再删小的可以保证删的最多，所以就从 'z' 遍历到 'a'， 一个一个删，当前字母不能删就往前循环。\n\nAC代码：\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxx = 200010;\nconst int inf = 0x3f3f3f3f;\nusing namespace std;\nstring s;\nint main()\n{\n    int n;\n    while (cin >> n >> s)\n    {\n        for (char i = 'z'; i >= 'b'; i--)\n        {\n            if (s.size() == 1)\n                break;\n            while (1)\n            {\n                if (s.size() == 1)\n                    break;\n                int flag = 1;\n                for (int j = 0; j < s.size(); j++)\n                {\n                    if (s[j] != i)\n                        continue;\n                    if (j == 0)\n                    {\n                        if (s[j + 1] == i - 1)\n                        {\n                            flag = 0;\n                            s.erase(s.begin() + j, s.begin() + j + 1);\n                            break;\n                        }\n                    }\n                    else if (j == s.size() - 1)\n                    {\n                        if (s[j - 1] == i - 1)\n                        {\n                            flag = 0;\n                            s.erase(s.begin() + j, s.begin() + j + 1);\n                            break;\n                        }\n                    }\n                    else\n                    {\n                        if (s[j - 1] == i - 1 || s[j + 1] == i - 1)\n                        {\n                            flag = 0;\n                            s.erase(s.begin() + j, s.begin() + j + 1);\n                            break;\n                        }\n                    }\n                }\n                if (flag)\n                    break;\n            }\n        }\n        cout << n - s.size() << endl;\n    }\n    return 0;\n}\n```\n","tags":["CF"],"categories":["CF"]},{"title":"再次温习并查集的一些思路","url":"/2020/05/08/再次温习并查集的一些思路/","content":"\n## 写在前面\n\n因为之前4月份打了将近一个月的个人赛，有些以前学习过的算法已经忘了，所以重新再温习一遍。\n\n<!--more-->\n\n## 普通并查集\n\n**并查集（Union Find）是一种树型的数据结构，用于处理一些不相交集合（Disjoint Sets）的合并及查询问题。在一些有N个元素的集合应用问题中，我们通常是在开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中。**\n\n**对于并查集的理解**\n\n首先并查集是一种树型结构，树型结构，顾名思义就是存在着子节点和父节点。\n\n所以我们先设一个数组pre[]，这个数组里面存放每个元素的父节点。然后这里借鉴大佬的例子来解释并查集的作用。\n\n例：话说江湖上散落着各式各样的大侠，有上千个之多。他们没有什么正当职业，整天背着剑在外面走来走去，碰到和自己不是一路人的，就免不了要打一架。但大侠们有一个优点就是讲义气，绝对不打自己的朋友。而且他们信奉“朋友的朋友就是我的朋友”，只要是能通过朋友关系串联起来的，不管拐了多少个弯，都认为是自己人。这样一来，江湖上就形成了一个一个的帮派，通过两两之间的朋友关系串联起来。而不在同一个帮派的人，无论如何都无法通过朋友关系连起来，于是就可以放心往死了打。但是两个原本互不相识的人，如何判断是否属于一个朋友圈呢？\n\n我们可以在每个朋友圈内推举出一个比较有名望的人，作为该圈子的代表人物。这样，每个圈子就可以这样命名“中国同胞队”美国同胞队”……两人只要互相对一下自己的队长是不是同一个人，就可以确定敌友关系了。\n\n但是还有问题啊，大侠们只知道自己直接的朋友是谁，很多人压根就不认识队长要判断自己的队长是谁，只能漫无目的的通过朋友的朋友关系问下去：“你是不是队长？你是不是队长？”这样，想打一架得先问个几十年，饿都饿死了，受不了。这样一来，队长面子上也挂不住了，不仅效率太低，还有可能陷入无限循环中。于是队长下令，重新组队。队内所有人实行分等级制度，形成树状结构，我队长就是根节点，下面分别是二级队员、三级队员。每个人只要记住自己的上级是谁就行了。遇到判断敌友的时候，只要一层层向上问，直到最高层，就可以在短时间内确定队长是谁了。由于我们关心的只是两个人之间是否是一个帮派的，至于他们是如何通过朋友关系相关联的，以及每个圈子内部的结构是怎样的，甚至队长是谁，都不重要了。所以我们可以放任队长随意重新组队，只要不搞错敌友关系就好了。于是，门派产生了。\n\n![bcj](https://img-blog.csdnimg.cn/20190301210948491.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg0NjEzOQ==,size_16,color_FFFFFF,t_70)\n\n下面我们来看并查集的实现。 int pre[1000]; 这个数组，记录了每个大侠的上级是谁。大侠们从1或者0开始编号（依据题意而定），pre[15]=3就表示15号大侠的上级是3号大侠。如果一个人的上级就是他自己，那说明他就是掌门人了，查找到此为止。也有孤家寡人自成一派的，比如欧阳锋，那么他的上级就是他自己。每个人都只认自己的上级。比如胡青牛同学只知道自己的上级是杨左使。张无忌是谁？不认识！要想知道自己的掌门是谁，只能一级级查上去。\ngetf这个函数就是找掌门用的，意义再清楚不过了（路径压缩算法先不论，后面再说）。\n\n```\nint getf(int a)//查找根节点\n{\n    if (pre[a] == a)//我的上级不是掌门\n        return a;\n    int tmp = getf(pre[a]);//我就找他的上级，直到掌门出现\n    return pre[a] = tmp;//掌门出现\n}\n```\n\n再来看看mer函数，就是在两个点之间连一条线，这样一来，原先它们所在的两个板块的所有点就都可以互通了。这在图上很好办，画条线就行了。但我们现在是用并查集来描述武林中的状况的，一共只有一个pre[]数组，该如何实现呢？ 还是举江湖的例子，假设现在武林中的形势如图所示。虚竹帅锅与周芷若MM是我非常喜欢的两个人物，他们的终极boss分别是玄慈方丈和灭绝师太，那明显就是两个阵营了。我不希望他们互相打架，就对他俩说：“你们两位拉拉勾，做好朋友吧。”他们看在我的面子上，同意了。这一同意可非同小可，整个少林和峨眉派的人就不能打架了。这么重大的变化，可如何实现呀，要改动多少地方？其实非常简单，我对玄慈方丈说：“大师，麻烦你把你的上级改为灭绝师太吧。这样一来，两派原先的所有人员的终极boss都是师太，那还打个球啊！反正我们关心的只是连通性，门派内部的结构不要紧的。”玄慈一听肯定火大了：“我靠，凭什么是我变成她手下呀，怎么不反过来？我抗议！”于是，两人相约一战，杀的是天昏地暗，风云为之变色啊，但是啊，这场战争终究会有胜负，胜者为王。弱者就被吞并了。反正谁加入谁效果是一样的，门派就由两个变成一个了。这段函数的意思明白了吧？\n\n```\nvoid mer(int a, int b)//虚竹和周芷若做朋友\n{\n    int fa = getf(a);//我老大是玄慈\n    int fb = getf(b);//我老大是灭绝\n    if (fa != fb)\n        pre[fa] = fb;//打一仗，谁赢就当对方老大\n}\n```\n\n再来看看路径压缩算法。建立门派的过程是用mer函数两个人两个人地连接起来的，谁当谁的手下完全随机。最后的树状结构会变成什么样，我也无法预知，一字长蛇阵也有可能。这样查找的效率就会比较低下。最理想的情况就是所有人的直接上级都是掌门，一共就两级结构，只要找一次就找到掌门了。哪怕不能完全做到，也最好尽量接近。这样就产生了路径压缩算法。\n设想这样一个场景：两个互不相识的大侠碰面了，想知道能不能干一场。 于是赶紧打电话问自己的上级：“你是不是掌门？” 上级说：“我不是呀，我的上级是谁谁谁，你问问他看看。” 一路问下去，原来两人的最终boss都是东厂曹公公。 “哎呀呀，原来是自己人，有礼有礼，在下三营六组白面葫芦娃!” “幸会幸会，在下九营十八组仙子狗尾巴花！” 两人高高兴兴地手拉手喝酒去了。 “等等等等，两位大侠请留步，还有事情没完成呢！”我叫住他俩。 “哦，对了，还要做路径压缩。”两人醒悟。 白面葫芦娃打电话给他的上级六组长：“组长啊，我查过了，其实偶们的掌门是曹公公。不如偶们一起结拜在曹公公手下吧，省得级别太低，以后查找掌门麻烦。” “唔，有道理。” 白面葫芦娃接着打电话给刚才拜访过的三营长……仙子狗尾巴花也做了同样的事情。 这样，查询中所有涉及到的人物都聚集在曹公公的直接领导下。每次查询都做了优化处理，所以整个门派树的层数都会维持在比较低的水平上。路径压缩的代码，看得懂很好，看不懂可以自己模拟一下，很简单的一个递归而已。总之它所实现的功能就是这么个意思。\n\n![aa](https://img-blog.csdnimg.cn/20190301211224963.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg0NjEzOQ==,size_16,color_FFFFFF,t_70)\n\n```\nint tmp = getf(pre[a]);//路径压缩\n    return pre[a] = tmp;\n```\n\n**要实现这个例子的代码：**\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxx = 10010;\nconst int inf = 0x3f3f3f3f;\nusing namespace std;\nint pre[maxx];\nint n, m, ans;\nvoid init()\n{\n    for (int i = 0; i <= n; i++)\n        pre[i] = i;\n}\nint getf(int a)\n{\n    if (a == pre[a])\n        return a;\n    return pre[a] = getf(pre[a]);\n}\nint mer(int a, int b)\n{\n    int fa = getf(a);\n    int fb = getf(b);\n    if (fa != fb)\n    {\n        pre[fa] = fb;\n        ans--;\n    }\n}\nint main()\n{\n    while (~scanf(\"%d%d\", &n, &m), n)\n    {\n        init();\n        int a, b;\n        ans = n - 1;\n        for (int i = 0; i < m; i++)\n        {\n            scanf(\"%d%d\", &a, &b);\n            mer(a, b);\n        }\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}\n```\n\n## 带权并查集\n\n**就像名字一样，带权并查集就是要多维护一个权值数组;和普通的并查集大同小异,用pre[]数组存父节点，v存当前结点到父亲结点的权值。**\n\n首先是初始化：\n\n```\nvoid init()\n{\n    for (int i = 0; i <= n; i++)\n    {\n        pre[i] = i;\n        v[i] = 0;\n    }\n}\n```\n\n![tu](https://img-blog.csdnimg.cn/20191012205623707.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MDc3NDU1,size_16,color_FFFFFF,t_70)\n\n没有进行状态压缩的时候可以知道，pre[3]=2,pre[2]=1,pre[1]=1;v[3]=4;v[2]=3;v[1]=0;\n\n![tu](https://img-blog.csdnimg.cn/20191012205953664.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MDc3NDU1,size_16,color_FFFFFF,t_70)\n\n状态压缩后，pre[3]=1;v[3]=7;其他不变;所以可以得出代码如下\n\n```\nint getf(int a)\n{\n    if(pre[a]==a)\n        return a;\n    int tmp=getf(pre[a]);  //这里不能够没有，因为在递归的过程中pre[a]的值会被改变，会影响v[a]的更新\n    v[a]=v[a]+v[pre[a]];\n    return pre[a]=tmp;\n}\n```\n\n而对于合并两个集合，是将元素间关系看成向量\n我们可以列出向量图:\n\n![tu](https://img-blog.csdnimg.cn/20191012211424881.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MDc3NDU1,size_16,color_FFFFFF,t_70)\n\n我们假设上图中2->1表示1比2大3，同理得其他的，一开始1，2处于一个集合,3,处于另一个集合，现在要将这两个集合合并,那么1->4得权值就可以得出，根据平行四边形法则,v[1]=(-v[2]+v+v[3])=8(其中v表示3比2大多少有，也就是2->3)，就是说4比1大8，由此我们便得到了如何将两个带权集合合并。\n\n```\nvoid mer(int a, int b, int s)\n{\n    int fa = getf(a);\n    int fb = getf(b);\n    if (fa != fb)\n    {\n        pre[fa] = fb;\n        v[fa] = -v[a] + s + v[b];\n    }\n}\n```\n\n**例题一：HihoCoder-1515**\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxx = 100010;\nconst int inf = 0x3f3f3f3f;\nusing namespace std;\nint pre[maxx], v[maxx];\nint n, m, q;\nint x, y, s;\nint ans;\nvoid init()\n{\n    for (int i = 0; i <= n; i++)\n    {\n        pre[i] = i;\n        v[i] = 0;\n    }\n}\nint getf(int a)\n{\n    if (pre[a] == a)\n        return a;\n    int tmp = getf(pre[a]);\n    v[a] = v[a] + v[pre[a]];\n    return pre[a] = tmp;\n}\nvoid mer(int a, int b, int s)\n{\n    int fa = getf(a);\n    int fb = getf(b);\n    if (fa != fb)\n    {\n        pre[fa] = fb;\n        v[fa] = -v[a] + s + v[b];\n    }\n}\ntemplate <class T>\ninline void read(T &res) //快速读入模板\n{\n    char c;\n    T flag = 1;\n    while ((c = getchar()) < '0' || c > '9')\n        if (c == '-')\n            flag = -1;\n    res = c - '0';\n    while ((c = getchar()) >= '0' && c <= '9')\n        res = res * 10 + c - '0';\n    res *= flag;\n}\nint main()\n{\n    read(n), read(m), read(q);\n    init();\n    while (m--)\n    {\n        read(x), read(y), read(s);\n        mer(x, y, s);\n    }\n    while (q--)\n    {\n        read(x), read(y);\n        if (getf(x) == getf(y))\n            printf(\"%d\\n\", v[x] - v[y]);\n        else\n            printf(\"-1\\n\");\n    }\n    return 0;\n}\n```\n\n**例题二：HDU-3038**\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxx = 200010;\nconst int inf = 0x3f3f3f3f;\nusing namespace std;\nint pre[maxx], v[maxx];\nint n, m;\nint x, y, s;\nvoid init()\n{\n    for (int i = 0; i <= n; i++)\n    {\n        pre[i] = i;\n        v[i] = 0;\n    }\n}\nint getf(int a)\n{\n    if (pre[a] == a)\n        return a;\n    int tmp = getf(pre[a]);\n    v[a] = v[a] + v[pre[a]];\n    return pre[a] = tmp;\n}\nint mer(int a, int b, int s)\n{\n    int fa = getf(a);\n    int fb = getf(b);\n    if (fa == fb)\n        return v[a] != v[b] + s;\n    else\n    {\n        pre[fa] = fb;\n        v[fa] = -v[a] + v[b] + s;\n        return 0;\n    }\n}\nint main()\n{\n    while (~scanf(\"%d%d\", &n, &m))\n    {\n        init();\n        int ans = 0;\n        while (m--)\n        {\n            scanf(\"%d%d%d\", &x, &y, &s);\n            y++;\n            if (mer(x, y, s))\n                ans++;\n        }\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}\n```\n\n## 种类并查集\n\n**种类并查集，顾名思义，在所给数据中或多或少会带有种类的区别。**\n\n种类并查集延用了带权并查集的特性,还是相当于维护了一个权值，只不过这个权值带有一定的意义，拿例题“食物链”来说，我们指定x->y表示与y是x的父节点，即pre[x]=y;我们用rela[i]来表示节点i和它的父节点之间的关系，规定rela[x]=0表示x,y是同类，rela[x]=1表示y吃x，rela[x]=2表示x吃y，那么我们可以根据这些权值推断出两个结点之间实际的关系。\n\n![tu](https://img-blog.csdnimg.cn/20191022194850194.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MDc3NDU1,size_16,color_FFFFFF,t_70)\n\n比如现在告诉你3->1的值为1（1吃3），而2->1的值为2（2吃1），那么我们根据题意就可以得出3吃2，即2->3为1,也就得到了上图的关系。假设现在再来一句话说2吃3那么就是错的。问题是如何得到这样的关系。对于给定的x,y和它们之间的关系,我们分两种情况\n1.假设pre[x]==pre[y]，就是说它们是一个集合的，现在的任务就是把它们推出它们之间的关系，也就是上图的情况，1为父节点，先开始的条件有3->1的为1,2->1=2，如何得到2->3=1呢？同样我们可以用向量的方法：2->3=2->1 - 1->3(添负号，箭头反向)=2-1=1；这样我们得到了2->3的值为1（这里在想一下，如果我们想得到假设之前我们已经建立了2->1的关系，现在又给出2->1的关系，如何得到到给出的关系对不对呢；我们只需要把上图的3换成1就可以了，同时3->1=1就变成了1->1=0同样的方法）\n2.假设pre[x]!=pre[y]，x,y不在同一个集合也就是要联合x,y两个集合,已知y->x=1,x->fx=1,y->fy=0\n\n![tu](https://img-blog.csdnimg.cn/20191022200751469.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MDc3NDU1,size_16,color_FFFFFF,t_70)\n\n同样的用向量就可以了fy->fx=-(y->fy)+y->x+x->fx=1+1=2;(已知fx吃x，x吃y，y和fy是同类，所以由题意可知fy吃fx),这样我们就可以将两个集合联合在一起并且维护好关系。\n值得注意的是，这些操作对向量方向的要求很高，不能弄错方向，比如联合两个集合的时候,我们求的是fy->fx，也就是fy是儿子，fx是父亲,那么我们就应该pre[fy]=fx；而不是pre[fx]=fy;同样我们求的关系是rela[fy]的值，而不是rela[fx]，如果箭头反向，这些操作都要变.\n\n**给出食物链这题的代码(POJ-1182)：**\n\n```\n#include <stdio.h>\n#include <string>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <map>\ntypedef long long ll;\nconst int maxx = 100010;\nconst int inf = 0x3f3f3f3f;\nusing namespace std;\nint pre[maxx], rela[maxx];\nint n, k;\nvoid init()\n{\n    for (int i = 0; i <= n; i++)\n    {\n        pre[i] = i;\n        rela[i] = 0;\n    }\n}\nint getf(int a)\n{\n    if (pre[a] == a)\n        return a;\n    int tmp = getf(pre[a]);\n    rela[a] = (rela[a] + rela[pre[a]] + 3) % 3;\n    return pre[a] = tmp;\n}\nint mer(int c, int a, int b)\n{\n    int fa = getf(a);\n    int fb = getf(b);\n    if (fa == fb)\n    {\n        if (c == 1 && rela[a] == rela[b])\n            return 1;\n        else if (c == 2 && (rela[a] - rela[b] + 3) % 3 == c - 1)\n            return 1;\n        else\n            return 0;\n    }\n    else\n    {\n        pre[fb] = fa;\n        rela[fb] = (-rela[b] + rela[a] - c + 1 + 3) % 3;\n        return 1;\n    }\n}\nint main()\n{\n    scanf(\"%d%d\", &n, &k);\n    init();\n    int d, x, y;\n    int sum = 0;\n    while (k--)\n    {\n        scanf(\"%d%d%d\", &d, &x, &y);\n        if (x > n || y > n)\n            sum++;\n        else if (d == 2 && x == y)\n            sum++;\n        else\n        {\n            if (!mer(d, x, y))\n                sum++;\n        }\n    }\n    printf(\"%d\\n\", sum);\n    return 0;\n}\n```\n\n**例题二：POJ-1703**\n\n```\n#include <stdio.h>\n#include <string>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <map>\ntypedef long long ll;\nconst int maxx = 100010;\nconst int inf = 0x3f3f3f3f;\nusing namespace std;\nint pre[maxx * 2];\nint n, m;\nvoid init()\n{\n    for (int i = 0; i <= 2 * n; i++)\n    {\n        pre[i] = i;\n    }\n}\nint getf(int a)\n{\n    if (pre[a] == a)\n        return a;\n    int tmp = getf(pre[a]);\n    return pre[a] = tmp;\n}\nvoid mer(int a, int b)\n{\n    int fa = getf(a);\n    int fb = getf(b);\n    if (fa != fb)\n        pre[fa] = fb;\n}\nint same(int a, int b)\n{\n    return getf(a) == getf(b);\n}\nint main()\n{\n    int t;\n    scanf(\"%d\", &t);\n    while (t--)\n    {\n        scanf(\"%d%d\", &n, &m);\n        init();\n        char s;\n        int a, b;\n        while (m--)\n        {\n            getchar();\n            scanf(\"%c%d%d\", &s, &a, &b);\n            if (s == 'D')\n            {\n                mer(a, b + n);\n                mer(b, a + n);\n            }\n            else\n            {\n                if (same(a, b))\n                {\n                    printf(\"In the same gang.\\n\");\n                    continue;\n                }\n                else if (same(a, b + n))\n                {\n                    printf(\"In different gangs.\\n\");\n                }\n                else\n                {\n                    printf(\"Not sure yet.\\n\");\n                }\n            }\n        }\n    }\n    return 0;\n}\n```\n","tags":["并查集再温"],"categories":["算法重温"]},{"title":"JavaSE篇-Day2笔记","url":"/2020/05/05/JavaSE-Day(2)学习笔记/","content":"\n# Java语言基础\n\n## Java基础语法\n\n### 1.关键字\n\n<!--more-->\n\n**关键字概述：**\n被Java语言赋予特定含义的单词。\n\n**关键字特点：**\n组成关键字的字母全部小写。\n\n**注意事项：**\ngoto和const是保留字，在一般的高级Java编译器中，针对关键字都有特殊的颜色标记。\n\n- **Java关键字**\n\n![Java关键字](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1588673781789&di=405fa28b84d8a8b0464f054e43655198&imgtype=0&src=http%3A%2F%2Fpic4.zhimg.com%2Fv2-b1d047a34f15efeabd5211fd54f73b0b_b.jpg)\n\n### 2.标识符\n\n**标识符概述：**\n就是给类，接口，方法，变量等起名字时使用的字符序列\n\n**组成规则：**\n\n- **英文大小写字母**\n- **数字字符**\n- **$和_**\n\n**注意事项：**\n\n- **不能以数字开头**\n- **不能是Java中的关键字**\n- **区分大小写**\n\n### 3.标识符的常见命名规则\n\n**注意事项：**\n见名知意\n\n- **举例：我要定义一个学生类**\n\n```\nclass Student {}\n```\n\n**包：**\n其实就是文件夹，用于把相同的类名进行区分，全部小写\n\n- **单级：liuyi**\n- **多级：cn.itcast**\n\n**类或者接口：**\n\n- **一个单词：单词的首字母必须大写,举例：Student，Dog**\n- **多个单词：每个单词的首字母必须大写，举例：HelloWorld，StudentName**\n\n**方法或者变量：**\n\n- **一个单词：单词的首字母小写，举例：main，age**\n- **多个单词：从第二个单词开始，每个单词的首字母大写，举例：studentAge,showAllNames**\n\n**常量：**\n\n- **一个单词组成：全部大写，举例：PI**\n- **多个单词组成：每个字母都大写，用_隔开，举例：STUDENT_MAX_AGE**\n\n### 4.注释概述及其分类\n\n**注释概述：**\n用于解释说明的文字\n\n**Java中注释分类格式：**\n\n- **单行注释：格式：//注释文字**\n- **多行注释：格式：/星 注释文字 星/，注意：多行不可以嵌套使用，而单行是可以的**\n- **文档注释：格式：/星星 注释文字 星/**\n\n### 5.HelloWorld案例加入注释\n\n```\n/*\n 需求：我准备写一个java程序，把\"HelloWorld\"这句话输出在控制台\n\n分析：\nA:要写一个Java程序，必须定义类\nB:把数据能够输出，说明我们的程序是可以独立运行的，而程序要独立运行，必须定义main方法\nC:把数据输出在控制台，必须使用输出语句\n实现：\nA:java语言提供了一个关键字：class用来定义类，后面跟的是类名\nB:main方法的格式是固定的：\npublic static void main(String[] args) {\n\n}\nC:输出语句的格式是固定的：\nSystem.out.println(\"HelloWorld\");\n\"HelloWorld\"这个内容是可以改变的\n*/\n\n//这是我的HelloWorld案例\nclass HelloWorld {\n/*\n为了程序能够独立运行，定义main方法\nmain方法是程序的入口\n被jvm自动调用\n*/\npublic static void main(String[] args) {\n  //为了把数据显示在控制台，我们就使用了输出语句\n System.out.println(\"HelloWorld\");\n  }\n}\n```\n\n### 6.注释的作用\n\n略过，在Eclipse Jee 2018-12程序中编写Java代码时，有错误的话，编译器会提示。\n\n### 7.常量的概述和使用\n\n**常量概述：**\n在程序执行的过程中其值不可以发生改变\n\n```\n/*\n    常量：\n        在程序执行过程中，其值不发生改变的量。\n\n    分类：\n        A:字面值常量\n        B:自定义常量(后面讲)\n\n    字面值常量\n        A:字符串常量  用双引号括起来的内容。\n            举例：\"hello\",\"world\",\"HelloWorld\"\n        B:整数常量   所有的整数\n            举例：100,200\n        C:小数常量   所有的小数\n            举例：10.23,110.11\n\t\tD:字符常量\t用单引号括起来的内容\n\t\t\t举例：'a','A','0'\n\t\t\t错误的：'ab'\n\t\tE:布尔常量\t比较特殊\n\t\t\t举例：true,false\n\t\tF:空常量\t后面讲\n\t\t\t举例：null\n*/\nclass ConstantDemo {\n\tpublic static void main(String[] args) {\n\t\t//字符串常量的输出\n\t\tSystem.out.println(\"hello\");\n\t\t\n\t\t//整数常量的输出\n\t\tSystem.out.println(100);\n\t\t\n\t\t//小数常量的输出\n\t\tSystem.out.println(100.10);\n\t\t\n\t\t//字符常量的输出\n\t\tSystem.out.println('a');\n\t\tSystem.out.println('A');\n\t\tSystem.out.println('0');\n\t\t//这个是有问题的\n\t\t//System.out.println('ab');\n\t\t\n\t\t//布尔常量的输出\n\t\tSystem.out.println(true);\n\t\tSystem.out.println(false);\n\t}\n}\n```\n\n### 8.进制概述以及二进制、八进制、十六进制图解\n\n![进制](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1588680207620&di=5dc7fbed0760175d40d1bbb10baa7b8d&imgtype=0&src=http%3A%2F%2Fgss0.baidu.com%2F9fo3dSag_xI4khGko9WTAnF6hhy%2Fzhidao%2Fpic%2Fitem%2Fd439b6003af33a87736ff400c45c10385343b5ae.jpg)\n\n**二进制->八进制：**\n把二进制的数据，从右开始，每三位一组合，最左边不够的时候，补0。然后，分别计算出对应的十进制数值，最后，再把每个十进制的数据组合起来，就是一个八进制数据。\n\n**二进制->十六进制：**\n把二进制的数据，从右开始，每四位一组合，最左边不够的时候，补0。然后，分别计算出对应的十进制数值，最后，再把每个十进制的数据组合起来，就是一个十六进制数据。\n\n**规则：进制越大，表现形式越短**\n\n### 9.不同进制数据的表现形式\n\n```\n/*\n\t不同进制的数据表现：\n\t\t二进制：由0，1组成。以0b开头。\n\t\t八进制：由0,1,...7组成。以0开头。\n\t\t十进制：由0,1,...9组成。默认整数是十进制。\n\t\t十六进制：由0,1,...9,a,b,c,d,e,f(大小写均可)组成。以0x开头。\n*/\nclass JinZhiDemo {\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(100); //十进制\n\t\t\n\t\tSystem.out.println(0b100); //二进制\n\t\tSystem.out.println(0100); //八进制\n\t\tSystem.out.println(0x100); //十六进制\n\t}\n}\n```\n\n### 10.任意进制到十进制的转换\n\n![转换](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1588680802524&di=c3fd9ec5b2d6bae9fefda7479f3c2742&imgtype=0&src=http%3A%2F%2Fwww.myexception.cn%2Fimg%2F2015%2F07%2F11%2F060509721.png)\n\n**系数：每一个位上的数据值本身就是系数。**\n\n**基数：x进制的基数就是x。**\n\n**权：我们针对每一个位上的数据进行编号，从右边，并且是从0开始编号，这个编号就是该位上数据的权值。**\n\n**PS：每一个位上的系数x基数^权次幂相加。**\n\n### 11.十进制到任意进制的转换\n\n**方法：这个数对基数依次取余，将余数倒序输出，在倒序输出余数之前正序输出最后一次的商。（这个方法是很简单的一种方式，可以大大的节省时间）。**\n\n**将十进制转成八进制：**\n579 / 8 = 72　．．．3\n72 / 8 =9　．．．0\n9 / 8 =1　．．．1\n\n先输出最后一次计算的商，然后倒序从下到上输出余数\n八进制的 576 为　1103\n\n### 12.快速的进制转换法\n\n**8421码**\n\n![8421](https://img-blog.csdnimg.cn/20181213115022126.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjUxODA2Mg==,size_16,color_FFFFFF,t_70)\n\n### 13.原码、反码、补码的讲解\n\n**在探求为何机器要使用补码之前, 让我们先了解原码, 反码和补码的概念.对于一个数, 计算机要使用一定的编码方式进行存储. 原码, 反码, 补码是机器存储一个具体数字的编码方式。**\n\n**原码：**\n原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:\n\n[+1]原 = 0000 0001\n\n[-1]原 = 1000 0001\n\n第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是:[1111 1111 , 0111 1111]即[-127 , 127]，原码是人脑最容易理解和计算的表示方式。\n\n**反码：**\n反码的表示方法是:正数的反码是其本身；负数的反码是在其原码的基础上, 符号位不变，其余各个位取反。\n\n[+1] = [00000001]原 = [00000001]反\n\n[-1] = [10000001]原 = [11111110]反\n\n可见如果一个反码表示的是负数, 人脑无法直观的看出来它的数值. 通常要将其转换成原码再计算。\n\n**补码：**\n补码的表示方法是:正数的补码就是其本身；负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)。\n\n[+1] = [00000001]原 = [00000001]反 = [00000001]补\n\n[-1] = [10000001]原 = [11111110]反 = [11111111]补\n\n对于负数, 补码表示方式也是人脑无法直观看出其数值的. 通常也需要转换成原码在计算其数值。\n\n### 14.变量的概述及格式\n\n**变量的概念：**\n\n- **在程序执行的过程中，在某个范围内其值可以发生改变的量**\n\n- **从本质上讲，变量其实是内存中的一小块区域，使用变量名来访问这块区域，因此，每一个变量使用前必须要先申请（声明），然后必须进行赋值（填充内容），才能使用。**\n\n**变量定义格式：**\n\n- **数据类型 变量名 = 初始化值;**\n\n注意：格式是固定的，记住格式，以不变应万变\n\n### 15.数据类型的概述和分类和定义不同数据类型的变量\n\n```\n/*\n\t数据类型：Java是一种强类型的语言，针对每一种数据都定义了明确的数据类型。\n\t\n\t数据类型分类：\n\t\tA:基本数据类型\n\t\tB:引用数据类型(类,接口,数值)\n\t\t\n\t基本数据类型:4类8种\n\t\tA:整数\t\t\t占用字节数\n\t\t\tbyte\t\t\t1\n\t\t\tshort\t\t\t2\n\t\t\tint\t\t\t\t4\n\t\t\tlong\t\t\t8\n\t\t\t\n\t\tB:浮点数\n\t\t\tfloat \t\t\t4\n\t\t\tdouble \t\t\t8\n\t\t\t\n\t\tC:字符\n\t\t\tchar\t\t\t2\n\t\tD:布尔\n\t\t\tboolean\t\t\t1\n\t\t\n\t\t注意：\n\t\t\t整数默认是int类型\n\t\t\t浮点数默认是double类型。\n\t\t\t\n\t\t\t长整型后缀用L或者l标记。建议使用L。\n\t\t\t单精度浮点数用F或者f标记。建议使用F。\n*/\nclass DataTypeDemo {\n\tpublic static void main(String[] args) {\n\t\t//定义变量的格式：\n\t\t//数据类型 变量名 = 初始化值;\n\t\t\n\t\t//定义一个字节变量\n\t\tbyte b = 10;\n\t\tSystem.out.println(10);\n\t\tSystem.out.println(b);\n\t\t\n\t\t//定义一个短整型变量\n\t\tshort s = 100;\n\t\tSystem.out.println(s);\n\t\t\n\t\t//定义一个整型变量\n\t\tint i = 1000;\n\t\tSystem.out.println(i);\n\t\t\n\t\t//超过了int的范围\n\t\t//int j = 1000000000000;\n\t\tlong j = 1000000000000L;\n\t\t//long j = 100L;\n\t\tSystem.out.println(j);\n\t\t\n\t\t//定义浮点数据变量\n\t\tfloat f = 12.345F;\n\t\tSystem.out.println(f);\n\t\t\n\t\tdouble d = 12.345;\n\t\tSystem.out.println(d);\n\t\t\n\t\t//定义字符变量\n\t\tchar ch = 'a';\n\t\tSystem.out.println(ch);\n\t\t\n\t\t//定义布尔变量\n\t\tboolean flag = true;\n\t\tSystem.out.println(flag);\n\t}\n}\n```\n\n### 16.使用变量的注意事项\n\n```\n/*\n\t使用变量的时候要注意的问题：\n\t\tA:作用域\n\t\t\t变量定义在哪个大括号内，它就在这个大括号内有效。\n\t\t\t并且，在同一个大括号内不能同时定义同名的变量。\n\t\t\t\n\t\tB:初始化值\n\t\t\t没有初始化值的变量不能直接使用。\n\t\t\t你只要在使用前给值就行，不一定非要在定义的时候立即给值。\n\t\t\t推荐在定义的时候给值。\n\t\t\t\n\t\t\t定义变量的格式：\n\t\t\t\ta:数据类型 变量名 = 初始化值;\n\t\t\t\tb:数据类型 变量名;\n\t\t\t\t  变量名 = 初始化值;\n\t\t\n\t\tC:在一行上建议只定义一个变量\n\t\t\t可以定义多个，但是不建议\n*/\nclass DataTypeDemo2 {\n\tpublic static void main(String[] args) {\n\t\t//定义变量\n\t\tint x = 100;\n\t\t\n\t\t//错误，不能有同名的\n\t\t//int x = 200;\n\t\t\n\t\t//定义变量必须给值\n\t\t//int y;\n\t\t//System.out.println(y);\n\t\t\n\t\tint z;\n\t\tz = 100;\n\t\tSystem.out.println(z);\n\t\t\n\t\t//在一行上定义多个变量\n\t\t//int a = 10; int b = 20; int c  = 30;\n\t\t//上面的写法可以，但是不建议。\n\t\tint a = 10;\n\t\tint b = 20;\n\t\tint c  = 30;\n\t\t\n\t\t//int d, e;\n\t\t//d = 40;\n\t\t//e = 50;\n\t\t\n\t\t//int f,int g; //错误\n\t\t//int h; int i; //正确\n\t}\n}\n```\n\n### 17.数据类型转换默认转换\n\n```\n/*\n\t+是一个运算符(我们等会讲解)。做加法运算的。\n\t\n\t一般来说，我们在运算的时候，要求参与运算的数据类型必须一致。\n\t\n\t注意：\n\t\tboolean类型不能转换为其他的数据类型\n\n\t默认转换(从小到大的转换)\n\t\tA:byte,short,char—int—long—float—double\n\t\tB:byte,short,char相互之间不转换，他们参与运算首先转换为int类型\n*/\nclass DataTypeDemo3 {\n\tpublic static void main(String[] args) {\n\t\t//直接输出的方式做加法\n\t\t//System.out.println(3 + 4);\n\t\n\t\t//两个int类型做加法\n\t\tint x = 3;\n\t\tint y = 4;\n\t\tint z = x + y;\n\t\tSystem.out.println(z);\n\t\t\n\t\t//定义一个byte类型，一个int类型，做加法\n\t\tbyte a = 3;\n\t\tint b = 4;\n\t\tSystem.out.println(a + b);\n\t\t\n\t\t//可能损失精度\n\t\t//byte c =  a + b;\n\t\tint c = a + b;\n\t\tSystem.out.println(c);\n\t}\n}\n```\n\n### 18.数据类型转换强制转换\n\n```\n/*\n\t强制转换：\n\t\t从大的数据类型到小的数据类型。\n\t\t\n\t\t格式：\n\t\t\t目标数据类型 变量 = (目标数据类型) (被转换的数据);\n\t\t\t\n\t\t注意：\n\t\t\t不要随意的去使用强制转换，因为它隐含了精度损失问题。\n*/\nclass DataTypeDemo4 {\n\tpublic static void main(String[] args) {\n\t\tbyte a = 3;\n\t\tint b = 4;\n\t\t\n\t\t//这个肯定没有问题\n\t\t//int c = a + b;\n\t\t\n\t\t//byte c = 7;\n\t\t//这个是有问题的\n\t\t//byte c = a + b; \n\t\t//用强制类型转换改进\n\t\tbyte c = (byte) (a + b);\n\t\tSystem.out.println(c);\n\t}\n}\n```\n\n### 19.强制转换的思考题\n\n```\n/*\n\t思考题1：请问下面这个有没有问题\n\t\tdouble d = 12.345;\n\t\tfloat f = d;\n\t\t\n\t思考题2：看看下面两个定义有没有区别呢?\n\t\tfloat f1 = (float)12.345;\n\t\tfloat f2 = 12.345f;\n\t\t\n\t\tf1其实是通过一个double类型转换过来的。\n\t\t而f2本身就是一个float类型。\n*/\nclass DataTypeDemo5 {\n\tpublic static void main(String[] args) {\n\t\t//把double赋值给float，加了强制类型转换\n\t\tdouble d = 12.345;\n\t\tfloat f = (float)d;\n\t\t\n\t\t//看看下面两个定义有没有区别呢?\n\t\tfloat f1 = (float)12.345;\n\t\tfloat f2 = 12.345F;\n\t}\n}\n```\n\n### 20.变量相加和常量相加的面试题\n\n```\n/*\n\t面试题：\n\t\tbyte b1=3,b2=4,b;\n\t\tb=b1+b2;\n\t\tb=3+4;\n\t\t哪句是编译失败的呢？为什么呢？\n\t\tb = b1 + b2;是有问题的。\n\t\t因为变量相加，会首先看类型问题，最终把结果赋值的也会考虑类型问题。\n\t\t常量相加，首先做加法，然后看结果是否在赋值的数据类型范围内，如果不是，才报错。\n*/\nclass DataTypeDemo6 {\n\tpublic static void main(String[] args) {\n\t\t//定义了三个byte类型的变量，b1，b2，b3\n\t\t//b1的值是3，b2的值是4，b没有值\n\t\tbyte b1 = 3,b2 = 4,b;\n\t\t\n\t\t//b = b1 + b2; //这个是类型提升，所以有问题\n\t\t\n\t\tb = 3 + 4; //常量，先把结果计算出来，然后看是否在byte的范围内，如果在就不报错。\n\t}\n}\n```\n\n### 21.强制转换数据溢出后的结果怎么算\n\n```\n/*\n\tbyte b = 130;有没有问题?如果我想让赋值正确，可以怎么做?结果是多少呢?\n\t\n\t练习：byte b = (byte)300;\n*/\nclass DataTypeDemo7 {\n\tpublic static void main(String[] args) {\n\t\t//因为byte的范围是：-128到127。\n\t\t//而130不在此范围内，所以报错。\n\t\t//byte b = 130; \n\t\t\n\t\t//我们可以使用强制类型转换\n\t\tbyte b = (byte) 130;\n\t\t\n\t\t//结果是多少呢?\n\t\tSystem.out.println(b);\n\t}\n}\n/*\n\t分析过程：\n\t\t我们要想知道结果是什么，就应该知道是如何进行计算的。\n\t\t而我们又知道计算机中数据的运算都是补码进行的。\n\t\t而要得到补码，首先要计算出数据的二进制。\n\t\t\n\t\tA:获取130这个数据的二进制。\n\t\t\t00000000 00000000 00000000 10000010\n\t\t\t这是130的原码，也是反码，还是补码。\n\t\tB:做截取操作，截成byte类型的了。\n\t\t\t10000010 \n\t\t\t这个结果是补码。\n\t\tC:已知补码求原码。\n\t\t\t\t\t符号位\t\t数值位\n\t\t\t补码：\t1\t\t\t0000010\n\t\t\t\n\t\t\t反码：\t1\t\t\t0000001\n\t\t\t\n\t\t\t原码：\t1\t\t\t1111110\n*/\n```\n\n### 22.字符数据参与运算\n\n**常用字符与ASCII代码对照表**\n\n![ACSII](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1588762945712&di=15da2d4da03c11464b6f7ef905bd8194&imgtype=0&src=http%3A%2F%2Faliyunzixunbucket.oss-cn-beijing.aliyuncs.com%2Fjpg%2F5802ba54ea55b831c41d5a4b5b13e641.jpg%3Fx-oss-process%3Dimage%2Fresize%2Cp_100%2Fauto-orient%2C1%2Fquality%2Cq_90%2Fformat%2Cjpg%2Fwatermark%2Cimage_eXVuY2VzaGk%3D%2Ct_100)\n\n### 23.字符串参与运算\n\n```\n/*\n\t看程序写结果\n\t\t字符串数据和其他数据做+，结果是字符串类型。\n\t\t这里的+不是加法运算，而是字符串连接符。\n*/\nclass DataTypeDemo9 {\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(\"hello\"+'a'+1); //helloa1，因为有优先级\n\t\tSystem.out.println('a'+1+\"hello\"); //98hello\n\t\t\n\t\tSystem.out.println(\"5+5=\"+5+5); //5+5=55\n\t\tSystem.out.println(5+5+\"=5+5\"); //10=5+5\n\t}\n}\n```\n\n**运算符优先级**\n\n![运算符优先级](https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=807700448,2127105133&fm=26&gp=0.jpg)","tags":["Java系统学习"],"categories":["Java系统学习-JavaSE篇"]},{"title":"JavaSE篇-Day1笔记","url":"/2020/05/04/JavaSE-Day(1)学习笔记/","content":"\n## 一、计算机基础\n\n### 1.计算机概述\n\n  **计算机全称为：电子计算机，俗称电脑**\n\n<!--more-->\n\n### 2.计算机硬件和软件概述\n\n- **计算机硬件是指计算机系统中由电子，机械和光电元件等组成的各种物理装置的总称。**\n- **计算机软件是指使用计算机过程中必不可少的东西，计算机软件可以使家算计按照事先预定好的顺序完成特定的功能，计算机软件按照其功能划分为系统软件和应用软件。**\n  \n### 3.软件开发和计算机语言概述\n\n- **软件开发：借助开发工具与计算机语言制作软件。**\n- **计算机语言：人与计算机之间进行信息交流沟通的一种特殊语言。**\n- **常见的计算机语言如C，C++，C#，JAVA，python。**\n\n### 4.人机交互\n\n   **交互方式：**\n\n- **图形化界面：这种方式简单直观，使用者易于接受，容易操作上手。**\n- **命令性方式：需要一个控制台，输入特定的指令，让计算机完成一些操作。较为麻烦。需要记录住一些命令。**\n\n### 5.键盘功能键和快捷键\n\n   **应该记住一些简单的功能键和快捷键**\n\n- **Tab 缩进空格**\n- **Enter 回车**\n- **Window键**\n- **Ctrl+A全选 Ctrl+C 复制 Ctrl+V 粘贴 Ctrl+X剪切 Ctrl+Z 撤销 Ctrl+S 保存**\n\n### 6.如何打开DOS控制台\n\n   **Windows+R -> cmd -> 回车**\n\n### 7.常见的DOS讲解\n\n- **d: +回车   盘符切换**\n- **dir(directory):   列出当前目录下的文件以及文件夹**\n- **md(make directory):    创建目录**\n- **rd(remove directory):   删除目录**\n- **cd(change directory):   改变指定目录（进入指定目录）**\n- **cd..:     退回上级目录**\n- **cd\\:     退回根目录**\n- **exit:     推出dos命令行**\n- **cls(clear screen):    清屏**\n- **del(delete):   删除文件，删除一堆后缀名一样的文件，例如.txt**\n\n## 二、Java语言基础\n\n### 1.Java语言概述\n\n**Java语言由詹姆斯.高斯林发明**\n\n### 2.Java语言跨平台原理\n\n**Java是面向对象的语言，其重点特点是开源和跨平台**\n\n![Java语言的跨平台性](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=52291647,1781400255&fm=15&gp=0.jpg)\n\n### 3.JDK与JRE的概述\n\n**JRE -> Java运行环境**\n\n**JDK -> Java开发工具包，其中包含了JRE**\n\n**简单而言：使用JDK开发完成的java程序，交给JRE去运行**\n\n### 4.JDK的下载、安装和卸载\n\n**详情请看：https://blog.csdn.net/nuoyanli/article/details/86513950**\n\n### 5.Java环境变量的配置\n\n**详情请看：https://blog.csdn.net/nuoyanli/article/details/86513950**\n\n### 6.第一个Java案例的编写和运行\n\n**视频里老师用的是记事本进行编写和运行，而我用的是Eclipse Jee 2018-12**\n\n```\nimport java.util.*;\nimport java.math.*;\nimport java.io.*;\npublic class Main {\n\n public static void main(String[] args) {\n  // TODO Auto-generated method stub\n        System.out.println(\"Hello world\");\n }\n}\n```\n","tags":["Java系统学习"],"categories":["Java系统学习-JavaSE篇"]},{"title":"Java系统学习规划(1)——JavaSE篇","url":"/2020/05/04/Java系统学习规划(1)—JavaSE篇/","content":"\n## 写在前面\n\n**关于为什么要在现在系统的学习Java，是因为我觉得去年暑假学习的一些Java知识基本都忘记了(~~其实是因为今年疫情影响，很大概率原地退役，所以也算为以后做做准备~~)**\n\n<!--more-->\n\n## Java系统学习规划(1)\n\n### 一、\n\n**选择什么课程：这里的话我是选择了刘意老师的深入浅出精华版为主，毕向东老师的Java基础教程为辅来进行学习。**\n\n这里给出刘意老师视频的B站地址：https://www.bilibili.com/video/BV1Jt411w7fR?from=search&seid=5273427619493979344\n\n这里给出毕向东老师视频的B站地址：https://www.bilibili.com/video/BV1pt41127na?from=search&seid=9126689322584219690\n\n### 二、\n\n**学习重点参考** \n\n初学者也容易想走捷径。我相信很多人都会有这个想法：能不能只学工作上要用的？根本原因是知识点真的太多了。以刘意老师视频为例，面向对象（封装，继承，多态），异常，多线程，集合框架，IO，网络编程都挺难的。其中面向对象是JavaSE的重中之重，里面的知识点个人认为是最难的。后面的知识点都是建立在这之上展开的，没学好面向对象，后面就会稀里糊涂。当然，也不是真的一点都不能跳，但最好完整地学下来。按照后面JavaWeb的学习来看，我的建议是：\n\n- **面向对象是基石，JavaSE中最重要的一是集合，二是IO，** 希望大家学习这两个知识点时认真对待，多敲代码，多思考。\n- **常用API里，String及其相关类StringBuilder, StringBuffer** 等必须熟悉，后面会不断用到。不学好的话，后面怎么死都不知道！\n- **泛型一般只出现在集合中** ，个人觉得如果一时无法掌握，那么**暂时会在集合中使用泛型就行了。**\n- 反射对于初学者来说是**非常抽象的！！** 但它又无比重要。它虽然不是JavaSE的重点，但是**它是JavaWeb很多难点的底层支撑，不懂反射，寸步难行。**\n\n**重点**\n\n- 面向对象☆☆☆☆☆\n- 集合☆☆☆☆☆\n- IO ☆☆☆☆☆\n- String/StringBuffer/StringBuilder ☆☆☆☆☆\n- 反射☆☆☆☆☆\n- 泛型☆☆☆☆\n\n**熟悉**\n\n- 异常\n- 多线程\n\n**先过一遍**\n\n- 网络编程\n- 正则表达式\n\n### 补充\n\n**这里给出刘意老师视频的配套资料**\n\n2015年版本刘意Java基础配套资料：https://pan.baidu.com/s/13slfA9U23PiXca_ROPC0ww   提取码：rmkv\n","tags":["Java系统学习"],"categories":["Java系统学习-JavaSE篇"]},{"title":"我的第一篇博客","url":"/2020/04/30/我的第一篇博客/","content":"## Hexo的一些语法\n\n### 常见命令\n\n```、\n**hexo new \"postName\" #新建文章\nhexo new page \"pageName\" #新建页面\nhexo generate #生成静态页面至public目录\nhexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）\nhexo deploy #部署到GitHub\nhexo help  # 查看帮助\nhexo version  #查看Hexo的版本**\nhexo clean  #清除缓存文件和静态文件\n```\n<!--more-->\n\n### 缩写\n\n```、\nhexo n == hexo new\nhexo g == hexo generate\nhexo s == hexo server\nhexo d == hexo deploy\n```\n\n### 组合命令\n\n```、\nhexo s -g #生成并本地预览\nhexo d -g #生成并上传\n```\n\n### 在生成一篇新的博客的一些操作\n\n**首先：hexo new/n + 博客标题(标题需加双引号)\n然后：运行后会自动生成markdown格式的文章\n然后：按创建成功后的提示信息（路径）进入到该文件所在的目录中，将md后缀的文件在Visual Studio Code中打开，可以在Visual Studio Code中下载一个markdownlint插件进行编辑。\n最后：编辑完成后返回主目录blog(cd … 返回上一层目录)\n运行 hexo clean 清除缓存文件和静态文件（非必要）\n运行 hexo generate/g 生成静态博客文件\n运行 hexo server/s 启动博客**\n\n### 如何把个人博客部署到远端\n\n**在blog目录下运行命令 hexo deploy/d 将本地博客部署到github\n部署过程中按要求输入 github 的账号和密码\n完成后就可直接通过该仓库名（username.github.io）访问博客了**\n","tags":["Hexo的一些基本用法和编写博客的一些注意事项"]},{"title":"Hello Stephencurry6666","url":"/2020/04/30/hello-world/","content":"\n### 科学公式 TeX(KaTeX)\n\n$$E=mc^2$$\n\n行内的公式$$E=mc^2$$行内的公式，行内的$$E=mc^2$$公式。\n\n$$x > y$$\n\n$$(\\sqrt{3x-1}+(1+x)^2)$$\n\n$$\\sin(\\alpha)^{\\theta}=\\sum_{i=0}^{n}(x^i + \\cos(f))$$\n\n$$\\iint_{a}^{b}\\frac{\\mathrm{3} }{\\mathrm{3} x}$$\n\n<!--more-->\n\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n<!--more-->\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]