[{"title":"Codeforces 625(Div.2)","url":"/2020/05/11/Codeforces 625(Div.2)/","content":"\n**A题**\n\n题意：输入两组数，为1表示有该任务，0表示没有，现在由你定义每个任务的分数，使得最高分最小的情况下，第一个人的总分大于第二个人，如果无法满足，输出-1。\n\n<!--more-->\n\n思路：这道题的话，先处理两个人的特有任务，如果第一个人特有的任务第二个人都有，那么一定无法满足，因为两个人任务的分数是相同的，第二个人特有的任务按照题目要求，应当为1分，第一个人的特有任务，按照第二个人特有任务的数量，平均分配即可。\n\nAC代码：\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxx = 100010;\nconst int inf = 0x3f3f3f3f;\nusing namespace std;\nint a[maxx];\nint b[maxx];\nint main()\n{\n    int n;\n    while (cin >> n)\n    {\n        for (int i = 1; i <= n; i++)\n            cin >> a[i];\n        for (int i = 1; i <= n; i++)\n            cin >> b[i];\n        int ans1 = 0, ans2 = 0;\n        for (int i = 1; i <= n; i++)\n        {\n            if (a[i] + b[i] == 1)\n            {\n                ans1 += a[i];\n                ans2 += b[i];\n            }\n        }\n        if (ans1 == 0)\n            cout << \"-1\" << endl;\n        else\n            cout << (ans1 + ans2) / ans1 << endl;\n    }\n    return 0;\n}\n```\n\n**B题**\n\n题意 ：有n个数，对于Ai和Aj这两个数，如果满足Ai-Aj=i-j，那么两个数就可以求和，输出整个数组能够求和的最大值。\n\n思路：这道题的话，因为每个城市有beauty值b，可以相互连通的城市i和j之间 i-j==b[i]-b[j]，所以i-b[i]==j-b[j]，所以可以连通的所有城市i-b[i]都是相等的，所以我们记录可以给到每一个差值的beauty值之和再取max就可以了。\n\nAC代码：\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxx = 200010;\nconst int inf = 0x3f3f3f3f;\nusing namespace std;\nunordered_map<ll, ll> mp;\nint main()\n{\n    int n;\n    cin >> n;\n    ll a;\n    ll ans = -1;\n    for (ll i = 1; i <= n; i++)\n    {\n        cin >> a;\n        mp[a - i] += a;\n        ans = max(ans, mp[a - i]);\n    }\n    cout << ans << endl;\n    return 0;\n}\n```\n\n**C题**\n\n题意：一个字符串，如果与某个位置相邻的字母，至少有一个比该位置的字母小1，那么该位置的字母就可以删掉，剩下的字母接上来，输出对于整个字符串，最多可以删多少个字母。\n\n思路：这道题的话，直接暴力，不难想到先删字母大的，然后再删小的可以保证删的最多，所以就从 'z' 遍历到 'a'， 一个一个删，当前字母不能删就往前循环。\n\nAC代码：\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxx = 200010;\nconst int inf = 0x3f3f3f3f;\nusing namespace std;\nstring s;\nint main()\n{\n    int n;\n    while (cin >> n >> s)\n    {\n        for (char i = 'z'; i >= 'b'; i--)\n        {\n            if (s.size() == 1)\n                break;\n            while (1)\n            {\n                if (s.size() == 1)\n                    break;\n                int flag = 1;\n                for (int j = 0; j < s.size(); j++)\n                {\n                    if (s[j] != i)\n                        continue;\n                    if (j == 0)\n                    {\n                        if (s[j + 1] == i - 1)\n                        {\n                            flag = 0;\n                            s.erase(s.begin() + j, s.begin() + j + 1);\n                            break;\n                        }\n                    }\n                    else if (j == s.size() - 1)\n                    {\n                        if (s[j - 1] == i - 1)\n                        {\n                            flag = 0;\n                            s.erase(s.begin() + j, s.begin() + j + 1);\n                            break;\n                        }\n                    }\n                    else\n                    {\n                        if (s[j - 1] == i - 1 || s[j + 1] == i - 1)\n                        {\n                            flag = 0;\n                            s.erase(s.begin() + j, s.begin() + j + 1);\n                            break;\n                        }\n                    }\n                }\n                if (flag)\n                    break;\n            }\n        }\n        cout << n - s.size() << endl;\n    }\n    return 0;\n}\n```\n","tags":["CF"],"categories":["CF"]},{"title":"再次温习并查集的一些思路","url":"/2020/05/08/再次温习并查集的一些思路/","content":"\n## 写在前面\n\n因为之前4月份打了将近一个月的个人赛，有些以前学习过的算法已经忘了，所以重新再温习一遍。\n\n<!--more-->\n\n## 普通并查集\n\n**并查集（Union Find）是一种树型的数据结构，用于处理一些不相交集合（Disjoint Sets）的合并及查询问题。在一些有N个元素的集合应用问题中，我们通常是在开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中。**\n\n**对于并查集的理解**\n\n首先并查集是一种树型结构，树型结构，顾名思义就是存在着子节点和父节点。\n\n所以我们先设一个数组pre[]，这个数组里面存放每个元素的父节点。然后这里借鉴大佬的例子来解释并查集的作用。\n\n例：话说江湖上散落着各式各样的大侠，有上千个之多。他们没有什么正当职业，整天背着剑在外面走来走去，碰到和自己不是一路人的，就免不了要打一架。但大侠们有一个优点就是讲义气，绝对不打自己的朋友。而且他们信奉“朋友的朋友就是我的朋友”，只要是能通过朋友关系串联起来的，不管拐了多少个弯，都认为是自己人。这样一来，江湖上就形成了一个一个的帮派，通过两两之间的朋友关系串联起来。而不在同一个帮派的人，无论如何都无法通过朋友关系连起来，于是就可以放心往死了打。但是两个原本互不相识的人，如何判断是否属于一个朋友圈呢？\n\n我们可以在每个朋友圈内推举出一个比较有名望的人，作为该圈子的代表人物。这样，每个圈子就可以这样命名“中国同胞队”美国同胞队”……两人只要互相对一下自己的队长是不是同一个人，就可以确定敌友关系了。\n\n但是还有问题啊，大侠们只知道自己直接的朋友是谁，很多人压根就不认识队长要判断自己的队长是谁，只能漫无目的的通过朋友的朋友关系问下去：“你是不是队长？你是不是队长？”这样，想打一架得先问个几十年，饿都饿死了，受不了。这样一来，队长面子上也挂不住了，不仅效率太低，还有可能陷入无限循环中。于是队长下令，重新组队。队内所有人实行分等级制度，形成树状结构，我队长就是根节点，下面分别是二级队员、三级队员。每个人只要记住自己的上级是谁就行了。遇到判断敌友的时候，只要一层层向上问，直到最高层，就可以在短时间内确定队长是谁了。由于我们关心的只是两个人之间是否是一个帮派的，至于他们是如何通过朋友关系相关联的，以及每个圈子内部的结构是怎样的，甚至队长是谁，都不重要了。所以我们可以放任队长随意重新组队，只要不搞错敌友关系就好了。于是，门派产生了。\n\n![bcj](https://img-blog.csdnimg.cn/20190301210948491.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg0NjEzOQ==,size_16,color_FFFFFF,t_70)\n\n下面我们来看并查集的实现。 int pre[1000]; 这个数组，记录了每个大侠的上级是谁。大侠们从1或者0开始编号（依据题意而定），pre[15]=3就表示15号大侠的上级是3号大侠。如果一个人的上级就是他自己，那说明他就是掌门人了，查找到此为止。也有孤家寡人自成一派的，比如欧阳锋，那么他的上级就是他自己。每个人都只认自己的上级。比如胡青牛同学只知道自己的上级是杨左使。张无忌是谁？不认识！要想知道自己的掌门是谁，只能一级级查上去。\ngetf这个函数就是找掌门用的，意义再清楚不过了（路径压缩算法先不论，后面再说）。\n\n```\nint getf(int a)//查找根节点\n{\n    if (pre[a] == a)//我的上级不是掌门\n        return a;\n    int tmp = getf(pre[a]);//我就找他的上级，直到掌门出现\n    return pre[a] = tmp;//掌门出现\n}\n```\n\n再来看看mer函数，就是在两个点之间连一条线，这样一来，原先它们所在的两个板块的所有点就都可以互通了。这在图上很好办，画条线就行了。但我们现在是用并查集来描述武林中的状况的，一共只有一个pre[]数组，该如何实现呢？ 还是举江湖的例子，假设现在武林中的形势如图所示。虚竹帅锅与周芷若MM是我非常喜欢的两个人物，他们的终极boss分别是玄慈方丈和灭绝师太，那明显就是两个阵营了。我不希望他们互相打架，就对他俩说：“你们两位拉拉勾，做好朋友吧。”他们看在我的面子上，同意了。这一同意可非同小可，整个少林和峨眉派的人就不能打架了。这么重大的变化，可如何实现呀，要改动多少地方？其实非常简单，我对玄慈方丈说：“大师，麻烦你把你的上级改为灭绝师太吧。这样一来，两派原先的所有人员的终极boss都是师太，那还打个球啊！反正我们关心的只是连通性，门派内部的结构不要紧的。”玄慈一听肯定火大了：“我靠，凭什么是我变成她手下呀，怎么不反过来？我抗议！”于是，两人相约一战，杀的是天昏地暗，风云为之变色啊，但是啊，这场战争终究会有胜负，胜者为王。弱者就被吞并了。反正谁加入谁效果是一样的，门派就由两个变成一个了。这段函数的意思明白了吧？\n\n```\nvoid mer(int a, int b)//虚竹和周芷若做朋友\n{\n    int fa = getf(a);//我老大是玄慈\n    int fb = getf(b);//我老大是灭绝\n    if (fa != fb)\n        pre[fa] = fb;//打一仗，谁赢就当对方老大\n}\n```\n\n再来看看路径压缩算法。建立门派的过程是用mer函数两个人两个人地连接起来的，谁当谁的手下完全随机。最后的树状结构会变成什么样，我也无法预知，一字长蛇阵也有可能。这样查找的效率就会比较低下。最理想的情况就是所有人的直接上级都是掌门，一共就两级结构，只要找一次就找到掌门了。哪怕不能完全做到，也最好尽量接近。这样就产生了路径压缩算法。\n设想这样一个场景：两个互不相识的大侠碰面了，想知道能不能干一场。 于是赶紧打电话问自己的上级：“你是不是掌门？” 上级说：“我不是呀，我的上级是谁谁谁，你问问他看看。” 一路问下去，原来两人的最终boss都是东厂曹公公。 “哎呀呀，原来是自己人，有礼有礼，在下三营六组白面葫芦娃!” “幸会幸会，在下九营十八组仙子狗尾巴花！” 两人高高兴兴地手拉手喝酒去了。 “等等等等，两位大侠请留步，还有事情没完成呢！”我叫住他俩。 “哦，对了，还要做路径压缩。”两人醒悟。 白面葫芦娃打电话给他的上级六组长：“组长啊，我查过了，其实偶们的掌门是曹公公。不如偶们一起结拜在曹公公手下吧，省得级别太低，以后查找掌门麻烦。” “唔，有道理。” 白面葫芦娃接着打电话给刚才拜访过的三营长……仙子狗尾巴花也做了同样的事情。 这样，查询中所有涉及到的人物都聚集在曹公公的直接领导下。每次查询都做了优化处理，所以整个门派树的层数都会维持在比较低的水平上。路径压缩的代码，看得懂很好，看不懂可以自己模拟一下，很简单的一个递归而已。总之它所实现的功能就是这么个意思。\n\n![aa](https://img-blog.csdnimg.cn/20190301211224963.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg0NjEzOQ==,size_16,color_FFFFFF,t_70)\n\n```\nint tmp = getf(pre[a]);//路径压缩\n    return pre[a] = tmp;\n```\n\n**要实现这个例子的代码：**\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxx = 10010;\nconst int inf = 0x3f3f3f3f;\nusing namespace std;\nint pre[maxx];\nint n, m, ans;\nvoid init()\n{\n    for (int i = 0; i <= n; i++)\n        pre[i] = i;\n}\nint getf(int a)\n{\n    if (a == pre[a])\n        return a;\n    return pre[a] = getf(pre[a]);\n}\nint mer(int a, int b)\n{\n    int fa = getf(a);\n    int fb = getf(b);\n    if (fa != fb)\n    {\n        pre[fa] = fb;\n        ans--;\n    }\n}\nint main()\n{\n    while (~scanf(\"%d%d\", &n, &m), n)\n    {\n        init();\n        int a, b;\n        ans = n - 1;\n        for (int i = 0; i < m; i++)\n        {\n            scanf(\"%d%d\", &a, &b);\n            mer(a, b);\n        }\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}\n```\n\n## 带权并查集\n\n**就像名字一样，带权并查集就是要多维护一个权值数组;和普通的并查集大同小异,用pre[]数组存父节点，v存当前结点到父亲结点的权值。**\n\n首先是初始化：\n\n```\nvoid init()\n{\n    for (int i = 0; i <= n; i++)\n    {\n        pre[i] = i;\n        v[i] = 0;\n    }\n}\n```\n\n![tu](https://img-blog.csdnimg.cn/20191012205623707.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MDc3NDU1,size_16,color_FFFFFF,t_70)\n\n没有进行状态压缩的时候可以知道，pre[3]=2,pre[2]=1,pre[1]=1;v[3]=4;v[2]=3;v[1]=0;\n\n![tu](https://img-blog.csdnimg.cn/20191012205953664.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MDc3NDU1,size_16,color_FFFFFF,t_70)\n\n状态压缩后，pre[3]=1;v[3]=7;其他不变;所以可以得出代码如下\n\n```\nint getf(int a)\n{\n    if(pre[a]==a)\n        return a;\n    int tmp=getf(pre[a]);  //这里不能够没有，因为在递归的过程中pre[a]的值会被改变，会影响v[a]的更新\n    v[a]=v[a]+v[pre[a]];\n    return pre[a]=tmp;\n}\n```\n\n而对于合并两个集合，是将元素间关系看成向量\n我们可以列出向量图:\n\n![tu](https://img-blog.csdnimg.cn/20191012211424881.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MDc3NDU1,size_16,color_FFFFFF,t_70)\n\n我们假设上图中2->1表示1比2大3，同理得其他的，一开始1，2处于一个集合,3,处于另一个集合，现在要将这两个集合合并,那么1->4得权值就可以得出，根据平行四边形法则,v[1]=(-v[2]+v+v[3])=8(其中v表示3比2大多少有，也就是2->3)，就是说4比1大8，由此我们便得到了如何将两个带权集合合并。\n\n```\nvoid mer(int a, int b, int s)\n{\n    int fa = getf(a);\n    int fb = getf(b);\n    if (fa != fb)\n    {\n        pre[fa] = fb;\n        v[fa] = -v[a] + s + v[b];\n    }\n}\n```\n\n**例题一：HihoCoder-1515**\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxx = 100010;\nconst int inf = 0x3f3f3f3f;\nusing namespace std;\nint pre[maxx], v[maxx];\nint n, m, q;\nint x, y, s;\nint ans;\nvoid init()\n{\n    for (int i = 0; i <= n; i++)\n    {\n        pre[i] = i;\n        v[i] = 0;\n    }\n}\nint getf(int a)\n{\n    if (pre[a] == a)\n        return a;\n    int tmp = getf(pre[a]);\n    v[a] = v[a] + v[pre[a]];\n    return pre[a] = tmp;\n}\nvoid mer(int a, int b, int s)\n{\n    int fa = getf(a);\n    int fb = getf(b);\n    if (fa != fb)\n    {\n        pre[fa] = fb;\n        v[fa] = -v[a] + s + v[b];\n    }\n}\ntemplate <class T>\ninline void read(T &res) //快速读入模板\n{\n    char c;\n    T flag = 1;\n    while ((c = getchar()) < '0' || c > '9')\n        if (c == '-')\n            flag = -1;\n    res = c - '0';\n    while ((c = getchar()) >= '0' && c <= '9')\n        res = res * 10 + c - '0';\n    res *= flag;\n}\nint main()\n{\n    read(n), read(m), read(q);\n    init();\n    while (m--)\n    {\n        read(x), read(y), read(s);\n        mer(x, y, s);\n    }\n    while (q--)\n    {\n        read(x), read(y);\n        if (getf(x) == getf(y))\n            printf(\"%d\\n\", v[x] - v[y]);\n        else\n            printf(\"-1\\n\");\n    }\n    return 0;\n}\n```\n\n**例题二：HDU-3038**\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxx = 200010;\nconst int inf = 0x3f3f3f3f;\nusing namespace std;\nint pre[maxx], v[maxx];\nint n, m;\nint x, y, s;\nvoid init()\n{\n    for (int i = 0; i <= n; i++)\n    {\n        pre[i] = i;\n        v[i] = 0;\n    }\n}\nint getf(int a)\n{\n    if (pre[a] == a)\n        return a;\n    int tmp = getf(pre[a]);\n    v[a] = v[a] + v[pre[a]];\n    return pre[a] = tmp;\n}\nint mer(int a, int b, int s)\n{\n    int fa = getf(a);\n    int fb = getf(b);\n    if (fa == fb)\n        return v[a] != v[b] + s;\n    else\n    {\n        pre[fa] = fb;\n        v[fa] = -v[a] + v[b] + s;\n        return 0;\n    }\n}\nint main()\n{\n    while (~scanf(\"%d%d\", &n, &m))\n    {\n        init();\n        int ans = 0;\n        while (m--)\n        {\n            scanf(\"%d%d%d\", &x, &y, &s);\n            y++;\n            if (mer(x, y, s))\n                ans++;\n        }\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}\n```\n\n## 种类并查集\n\n**种类并查集，顾名思义，在所给数据中或多或少会带有种类的区别。**\n\n种类并查集延用了带权并查集的特性,还是相当于维护了一个权值，只不过这个权值带有一定的意义，拿例题“食物链”来说，我们指定x->y表示与y是x的父节点，即pre[x]=y;我们用rela[i]来表示节点i和它的父节点之间的关系，规定rela[x]=0表示x,y是同类，rela[x]=1表示y吃x，rela[x]=2表示x吃y，那么我们可以根据这些权值推断出两个结点之间实际的关系。\n\n![tu](https://img-blog.csdnimg.cn/20191022194850194.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MDc3NDU1,size_16,color_FFFFFF,t_70)\n\n比如现在告诉你3->1的值为1（1吃3），而2->1的值为2（2吃1），那么我们根据题意就可以得出3吃2，即2->3为1,也就得到了上图的关系。假设现在再来一句话说2吃3那么就是错的。问题是如何得到这样的关系。对于给定的x,y和它们之间的关系,我们分两种情况\n1.假设pre[x]==pre[y]，就是说它们是一个集合的，现在的任务就是把它们推出它们之间的关系，也就是上图的情况，1为父节点，先开始的条件有3->1的为1,2->1=2，如何得到2->3=1呢？同样我们可以用向量的方法：2->3=2->1 - 1->3(添负号，箭头反向)=2-1=1；这样我们得到了2->3的值为1（这里在想一下，如果我们想得到假设之前我们已经建立了2->1的关系，现在又给出2->1的关系，如何得到到给出的关系对不对呢；我们只需要把上图的3换成1就可以了，同时3->1=1就变成了1->1=0同样的方法）\n2.假设pre[x]!=pre[y]，x,y不在同一个集合也就是要联合x,y两个集合,已知y->x=1,x->fx=1,y->fy=0\n\n![tu](https://img-blog.csdnimg.cn/20191022200751469.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MDc3NDU1,size_16,color_FFFFFF,t_70)\n\n同样的用向量就可以了fy->fx=-(y->fy)+y->x+x->fx=1+1=2;(已知fx吃x，x吃y，y和fy是同类，所以由题意可知fy吃fx),这样我们就可以将两个集合联合在一起并且维护好关系。\n值得注意的是，这些操作对向量方向的要求很高，不能弄错方向，比如联合两个集合的时候,我们求的是fy->fx，也就是fy是儿子，fx是父亲,那么我们就应该pre[fy]=fx；而不是pre[fx]=fy;同样我们求的关系是rela[fy]的值，而不是rela[fx]，如果箭头反向，这些操作都要变.\n\n**给出食物链这题的代码(POJ-1182)：**\n\n```\n#include <stdio.h>\n#include <string>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <map>\ntypedef long long ll;\nconst int maxx = 100010;\nconst int inf = 0x3f3f3f3f;\nusing namespace std;\nint pre[maxx], rela[maxx];\nint n, k;\nvoid init()\n{\n    for (int i = 0; i <= n; i++)\n    {\n        pre[i] = i;\n        rela[i] = 0;\n    }\n}\nint getf(int a)\n{\n    if (pre[a] == a)\n        return a;\n    int tmp = getf(pre[a]);\n    rela[a] = (rela[a] + rela[pre[a]] + 3) % 3;\n    return pre[a] = tmp;\n}\nint mer(int c, int a, int b)\n{\n    int fa = getf(a);\n    int fb = getf(b);\n    if (fa == fb)\n    {\n        if (c == 1 && rela[a] == rela[b])\n            return 1;\n        else if (c == 2 && (rela[a] - rela[b] + 3) % 3 == c - 1)\n            return 1;\n        else\n            return 0;\n    }\n    else\n    {\n        pre[fb] = fa;\n        rela[fb] = (-rela[b] + rela[a] - c + 1 + 3) % 3;\n        return 1;\n    }\n}\nint main()\n{\n    scanf(\"%d%d\", &n, &k);\n    init();\n    int d, x, y;\n    int sum = 0;\n    while (k--)\n    {\n        scanf(\"%d%d%d\", &d, &x, &y);\n        if (x > n || y > n)\n            sum++;\n        else if (d == 2 && x == y)\n            sum++;\n        else\n        {\n            if (!mer(d, x, y))\n                sum++;\n        }\n    }\n    printf(\"%d\\n\", sum);\n    return 0;\n}\n```\n\n**例题二：POJ-1703**\n\n```\n#include <stdio.h>\n#include <string>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <map>\ntypedef long long ll;\nconst int maxx = 100010;\nconst int inf = 0x3f3f3f3f;\nusing namespace std;\nint pre[maxx * 2];\nint n, m;\nvoid init()\n{\n    for (int i = 0; i <= 2 * n; i++)\n    {\n        pre[i] = i;\n    }\n}\nint getf(int a)\n{\n    if (pre[a] == a)\n        return a;\n    int tmp = getf(pre[a]);\n    return pre[a] = tmp;\n}\nvoid mer(int a, int b)\n{\n    int fa = getf(a);\n    int fb = getf(b);\n    if (fa != fb)\n        pre[fa] = fb;\n}\nint same(int a, int b)\n{\n    return getf(a) == getf(b);\n}\nint main()\n{\n    int t;\n    scanf(\"%d\", &t);\n    while (t--)\n    {\n        scanf(\"%d%d\", &n, &m);\n        init();\n        char s;\n        int a, b;\n        while (m--)\n        {\n            getchar();\n            scanf(\"%c%d%d\", &s, &a, &b);\n            if (s == 'D')\n            {\n                mer(a, b + n);\n                mer(b, a + n);\n            }\n            else\n            {\n                if (same(a, b))\n                {\n                    printf(\"In the same gang.\\n\");\n                    continue;\n                }\n                else if (same(a, b + n))\n                {\n                    printf(\"In different gangs.\\n\");\n                }\n                else\n                {\n                    printf(\"Not sure yet.\\n\");\n                }\n            }\n        }\n    }\n    return 0;\n}\n```\n","tags":["并查集再温"],"categories":["算法重温"]},{"title":"JavaSE篇-Day2笔记","url":"/2020/05/05/JavaSE-Day(2)学习笔记/","content":"\n# Java语言基础\n\n## Java基础语法\n\n### 1.关键字\n\n<!--more-->\n\n**关键字概述：**\n被Java语言赋予特定含义的单词。\n\n**关键字特点：**\n组成关键字的字母全部小写。\n\n**注意事项：**\ngoto和const是保留字，在一般的高级Java编译器中，针对关键字都有特殊的颜色标记。\n\n- **Java关键字**\n\n![Java关键字](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1588673781789&di=405fa28b84d8a8b0464f054e43655198&imgtype=0&src=http%3A%2F%2Fpic4.zhimg.com%2Fv2-b1d047a34f15efeabd5211fd54f73b0b_b.jpg)\n\n### 2.标识符\n\n**标识符概述：**\n就是给类，接口，方法，变量等起名字时使用的字符序列\n\n**组成规则：**\n\n- **英文大小写字母**\n- **数字字符**\n- **$和_**\n\n**注意事项：**\n\n- **不能以数字开头**\n- **不能是Java中的关键字**\n- **区分大小写**\n\n### 3.标识符的常见命名规则\n\n**注意事项：**\n见名知意\n\n- **举例：我要定义一个学生类**\n\n```\nclass Student {}\n```\n\n**包：**\n其实就是文件夹，用于把相同的类名进行区分，全部小写\n\n- **单级：liuyi**\n- **多级：cn.itcast**\n\n**类或者接口：**\n\n- **一个单词：单词的首字母必须大写,举例：Student，Dog**\n- **多个单词：每个单词的首字母必须大写，举例：HelloWorld，StudentName**\n\n**方法或者变量：**\n\n- **一个单词：单词的首字母小写，举例：main，age**\n- **多个单词：从第二个单词开始，每个单词的首字母大写，举例：studentAge,showAllNames**\n\n**常量：**\n\n- **一个单词组成：全部大写，举例：PI**\n- **多个单词组成：每个字母都大写，用_隔开，举例：STUDENT_MAX_AGE**\n\n### 4.注释概述及其分类\n\n**注释概述：**\n用于解释说明的文字\n\n**Java中注释分类格式：**\n\n- **单行注释：格式：//注释文字**\n- **多行注释：格式：/星 注释文字 星/，注意：多行不可以嵌套使用，而单行是可以的**\n- **文档注释：格式：/星星 注释文字 星/**\n\n### 5.HelloWorld案例加入注释\n\n```\n/*\n 需求：我准备写一个java程序，把\"HelloWorld\"这句话输出在控制台\n\n分析：\nA:要写一个Java程序，必须定义类\nB:把数据能够输出，说明我们的程序是可以独立运行的，而程序要独立运行，必须定义main方法\nC:把数据输出在控制台，必须使用输出语句\n实现：\nA:java语言提供了一个关键字：class用来定义类，后面跟的是类名\nB:main方法的格式是固定的：\npublic static void main(String[] args) {\n\n}\nC:输出语句的格式是固定的：\nSystem.out.println(\"HelloWorld\");\n\"HelloWorld\"这个内容是可以改变的\n*/\n\n//这是我的HelloWorld案例\nclass HelloWorld {\n/*\n为了程序能够独立运行，定义main方法\nmain方法是程序的入口\n被jvm自动调用\n*/\npublic static void main(String[] args) {\n  //为了把数据显示在控制台，我们就使用了输出语句\n System.out.println(\"HelloWorld\");\n  }\n}\n```\n\n### 6.注释的作用\n\n略过，在Eclipse Jee 2018-12程序中编写Java代码时，有错误的话，编译器会提示。\n\n### 7.常量的概述和使用\n\n**常量概述：**\n在程序执行的过程中其值不可以发生改变\n\n```\n/*\n    常量：\n        在程序执行过程中，其值不发生改变的量。\n\n    分类：\n        A:字面值常量\n        B:自定义常量(后面讲)\n\n    字面值常量\n        A:字符串常量  用双引号括起来的内容。\n            举例：\"hello\",\"world\",\"HelloWorld\"\n        B:整数常量   所有的整数\n            举例：100,200\n        C:小数常量   所有的小数\n            举例：10.23,110.11\n\t\tD:字符常量\t用单引号括起来的内容\n\t\t\t举例：'a','A','0'\n\t\t\t错误的：'ab'\n\t\tE:布尔常量\t比较特殊\n\t\t\t举例：true,false\n\t\tF:空常量\t后面讲\n\t\t\t举例：null\n*/\nclass ConstantDemo {\n\tpublic static void main(String[] args) {\n\t\t//字符串常量的输出\n\t\tSystem.out.println(\"hello\");\n\t\t\n\t\t//整数常量的输出\n\t\tSystem.out.println(100);\n\t\t\n\t\t//小数常量的输出\n\t\tSystem.out.println(100.10);\n\t\t\n\t\t//字符常量的输出\n\t\tSystem.out.println('a');\n\t\tSystem.out.println('A');\n\t\tSystem.out.println('0');\n\t\t//这个是有问题的\n\t\t//System.out.println('ab');\n\t\t\n\t\t//布尔常量的输出\n\t\tSystem.out.println(true);\n\t\tSystem.out.println(false);\n\t}\n}\n```\n\n### 8.进制概述以及二进制、八进制、十六进制图解\n\n![进制](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1588680207620&di=5dc7fbed0760175d40d1bbb10baa7b8d&imgtype=0&src=http%3A%2F%2Fgss0.baidu.com%2F9fo3dSag_xI4khGko9WTAnF6hhy%2Fzhidao%2Fpic%2Fitem%2Fd439b6003af33a87736ff400c45c10385343b5ae.jpg)\n\n**二进制->八进制：**\n把二进制的数据，从右开始，每三位一组合，最左边不够的时候，补0。然后，分别计算出对应的十进制数值，最后，再把每个十进制的数据组合起来，就是一个八进制数据。\n\n**二进制->十六进制：**\n把二进制的数据，从右开始，每四位一组合，最左边不够的时候，补0。然后，分别计算出对应的十进制数值，最后，再把每个十进制的数据组合起来，就是一个十六进制数据。\n\n**规则：进制越大，表现形式越短**\n\n### 9.不同进制数据的表现形式\n\n```\n/*\n\t不同进制的数据表现：\n\t\t二进制：由0，1组成。以0b开头。\n\t\t八进制：由0,1,...7组成。以0开头。\n\t\t十进制：由0,1,...9组成。默认整数是十进制。\n\t\t十六进制：由0,1,...9,a,b,c,d,e,f(大小写均可)组成。以0x开头。\n*/\nclass JinZhiDemo {\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(100); //十进制\n\t\t\n\t\tSystem.out.println(0b100); //二进制\n\t\tSystem.out.println(0100); //八进制\n\t\tSystem.out.println(0x100); //十六进制\n\t}\n}\n```\n\n### 10.任意进制到十进制的转换\n\n![转换](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1588680802524&di=c3fd9ec5b2d6bae9fefda7479f3c2742&imgtype=0&src=http%3A%2F%2Fwww.myexception.cn%2Fimg%2F2015%2F07%2F11%2F060509721.png)\n\n**系数：每一个位上的数据值本身就是系数。**\n\n**基数：x进制的基数就是x。**\n\n**权：我们针对每一个位上的数据进行编号，从右边，并且是从0开始编号，这个编号就是该位上数据的权值。**\n\n**PS：每一个位上的系数x基数^权次幂相加。**\n\n### 11.十进制到任意进制的转换\n\n**方法：这个数对基数依次取余，将余数倒序输出，在倒序输出余数之前正序输出最后一次的商。（这个方法是很简单的一种方式，可以大大的节省时间）。**\n\n**将十进制转成八进制：**\n579 / 8 = 72　．．．3\n72 / 8 =9　．．．0\n9 / 8 =1　．．．1\n\n先输出最后一次计算的商，然后倒序从下到上输出余数\n八进制的 576 为　1103\n\n### 12.快速的进制转换法\n\n**8421码**\n\n![8421](https://img-blog.csdnimg.cn/20181213115022126.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjUxODA2Mg==,size_16,color_FFFFFF,t_70)\n\n### 13.原码、反码、补码的讲解\n\n**在探求为何机器要使用补码之前, 让我们先了解原码, 反码和补码的概念.对于一个数, 计算机要使用一定的编码方式进行存储. 原码, 反码, 补码是机器存储一个具体数字的编码方式。**\n\n**原码：**\n原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:\n\n[+1]原 = 0000 0001\n\n[-1]原 = 1000 0001\n\n第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是:[1111 1111 , 0111 1111]即[-127 , 127]，原码是人脑最容易理解和计算的表示方式。\n\n**反码：**\n反码的表示方法是:正数的反码是其本身；负数的反码是在其原码的基础上, 符号位不变，其余各个位取反。\n\n[+1] = [00000001]原 = [00000001]反\n\n[-1] = [10000001]原 = [11111110]反\n\n可见如果一个反码表示的是负数, 人脑无法直观的看出来它的数值. 通常要将其转换成原码再计算。\n\n**补码：**\n补码的表示方法是:正数的补码就是其本身；负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)。\n\n[+1] = [00000001]原 = [00000001]反 = [00000001]补\n\n[-1] = [10000001]原 = [11111110]反 = [11111111]补\n\n对于负数, 补码表示方式也是人脑无法直观看出其数值的. 通常也需要转换成原码在计算其数值。\n\n### 14.变量的概述及格式\n\n**变量的概念：**\n\n- **在程序执行的过程中，在某个范围内其值可以发生改变的量**\n\n- **从本质上讲，变量其实是内存中的一小块区域，使用变量名来访问这块区域，因此，每一个变量使用前必须要先申请（声明），然后必须进行赋值（填充内容），才能使用。**\n\n**变量定义格式：**\n\n- **数据类型 变量名 = 初始化值;**\n\n注意：格式是固定的，记住格式，以不变应万变\n\n### 15.数据类型的概述和分类和定义不同数据类型的变量\n\n```\n/*\n\t数据类型：Java是一种强类型的语言，针对每一种数据都定义了明确的数据类型。\n\t\n\t数据类型分类：\n\t\tA:基本数据类型\n\t\tB:引用数据类型(类,接口,数值)\n\t\t\n\t基本数据类型:4类8种\n\t\tA:整数\t\t\t占用字节数\n\t\t\tbyte\t\t\t1\n\t\t\tshort\t\t\t2\n\t\t\tint\t\t\t\t4\n\t\t\tlong\t\t\t8\n\t\t\t\n\t\tB:浮点数\n\t\t\tfloat \t\t\t4\n\t\t\tdouble \t\t\t8\n\t\t\t\n\t\tC:字符\n\t\t\tchar\t\t\t2\n\t\tD:布尔\n\t\t\tboolean\t\t\t1\n\t\t\n\t\t注意：\n\t\t\t整数默认是int类型\n\t\t\t浮点数默认是double类型。\n\t\t\t\n\t\t\t长整型后缀用L或者l标记。建议使用L。\n\t\t\t单精度浮点数用F或者f标记。建议使用F。\n*/\nclass DataTypeDemo {\n\tpublic static void main(String[] args) {\n\t\t//定义变量的格式：\n\t\t//数据类型 变量名 = 初始化值;\n\t\t\n\t\t//定义一个字节变量\n\t\tbyte b = 10;\n\t\tSystem.out.println(10);\n\t\tSystem.out.println(b);\n\t\t\n\t\t//定义一个短整型变量\n\t\tshort s = 100;\n\t\tSystem.out.println(s);\n\t\t\n\t\t//定义一个整型变量\n\t\tint i = 1000;\n\t\tSystem.out.println(i);\n\t\t\n\t\t//超过了int的范围\n\t\t//int j = 1000000000000;\n\t\tlong j = 1000000000000L;\n\t\t//long j = 100L;\n\t\tSystem.out.println(j);\n\t\t\n\t\t//定义浮点数据变量\n\t\tfloat f = 12.345F;\n\t\tSystem.out.println(f);\n\t\t\n\t\tdouble d = 12.345;\n\t\tSystem.out.println(d);\n\t\t\n\t\t//定义字符变量\n\t\tchar ch = 'a';\n\t\tSystem.out.println(ch);\n\t\t\n\t\t//定义布尔变量\n\t\tboolean flag = true;\n\t\tSystem.out.println(flag);\n\t}\n}\n```\n\n### 16.使用变量的注意事项\n\n```\n/*\n\t使用变量的时候要注意的问题：\n\t\tA:作用域\n\t\t\t变量定义在哪个大括号内，它就在这个大括号内有效。\n\t\t\t并且，在同一个大括号内不能同时定义同名的变量。\n\t\t\t\n\t\tB:初始化值\n\t\t\t没有初始化值的变量不能直接使用。\n\t\t\t你只要在使用前给值就行，不一定非要在定义的时候立即给值。\n\t\t\t推荐在定义的时候给值。\n\t\t\t\n\t\t\t定义变量的格式：\n\t\t\t\ta:数据类型 变量名 = 初始化值;\n\t\t\t\tb:数据类型 变量名;\n\t\t\t\t  变量名 = 初始化值;\n\t\t\n\t\tC:在一行上建议只定义一个变量\n\t\t\t可以定义多个，但是不建议\n*/\nclass DataTypeDemo2 {\n\tpublic static void main(String[] args) {\n\t\t//定义变量\n\t\tint x = 100;\n\t\t\n\t\t//错误，不能有同名的\n\t\t//int x = 200;\n\t\t\n\t\t//定义变量必须给值\n\t\t//int y;\n\t\t//System.out.println(y);\n\t\t\n\t\tint z;\n\t\tz = 100;\n\t\tSystem.out.println(z);\n\t\t\n\t\t//在一行上定义多个变量\n\t\t//int a = 10; int b = 20; int c  = 30;\n\t\t//上面的写法可以，但是不建议。\n\t\tint a = 10;\n\t\tint b = 20;\n\t\tint c  = 30;\n\t\t\n\t\t//int d, e;\n\t\t//d = 40;\n\t\t//e = 50;\n\t\t\n\t\t//int f,int g; //错误\n\t\t//int h; int i; //正确\n\t}\n}\n```\n\n### 17.数据类型转换默认转换\n\n```\n/*\n\t+是一个运算符(我们等会讲解)。做加法运算的。\n\t\n\t一般来说，我们在运算的时候，要求参与运算的数据类型必须一致。\n\t\n\t注意：\n\t\tboolean类型不能转换为其他的数据类型\n\n\t默认转换(从小到大的转换)\n\t\tA:byte,short,char—int—long—float—double\n\t\tB:byte,short,char相互之间不转换，他们参与运算首先转换为int类型\n*/\nclass DataTypeDemo3 {\n\tpublic static void main(String[] args) {\n\t\t//直接输出的方式做加法\n\t\t//System.out.println(3 + 4);\n\t\n\t\t//两个int类型做加法\n\t\tint x = 3;\n\t\tint y = 4;\n\t\tint z = x + y;\n\t\tSystem.out.println(z);\n\t\t\n\t\t//定义一个byte类型，一个int类型，做加法\n\t\tbyte a = 3;\n\t\tint b = 4;\n\t\tSystem.out.println(a + b);\n\t\t\n\t\t//可能损失精度\n\t\t//byte c =  a + b;\n\t\tint c = a + b;\n\t\tSystem.out.println(c);\n\t}\n}\n```\n\n### 18.数据类型转换强制转换\n\n```\n/*\n\t强制转换：\n\t\t从大的数据类型到小的数据类型。\n\t\t\n\t\t格式：\n\t\t\t目标数据类型 变量 = (目标数据类型) (被转换的数据);\n\t\t\t\n\t\t注意：\n\t\t\t不要随意的去使用强制转换，因为它隐含了精度损失问题。\n*/\nclass DataTypeDemo4 {\n\tpublic static void main(String[] args) {\n\t\tbyte a = 3;\n\t\tint b = 4;\n\t\t\n\t\t//这个肯定没有问题\n\t\t//int c = a + b;\n\t\t\n\t\t//byte c = 7;\n\t\t//这个是有问题的\n\t\t//byte c = a + b; \n\t\t//用强制类型转换改进\n\t\tbyte c = (byte) (a + b);\n\t\tSystem.out.println(c);\n\t}\n}\n```\n\n### 19.强制转换的思考题\n\n```\n/*\n\t思考题1：请问下面这个有没有问题\n\t\tdouble d = 12.345;\n\t\tfloat f = d;\n\t\t\n\t思考题2：看看下面两个定义有没有区别呢?\n\t\tfloat f1 = (float)12.345;\n\t\tfloat f2 = 12.345f;\n\t\t\n\t\tf1其实是通过一个double类型转换过来的。\n\t\t而f2本身就是一个float类型。\n*/\nclass DataTypeDemo5 {\n\tpublic static void main(String[] args) {\n\t\t//把double赋值给float，加了强制类型转换\n\t\tdouble d = 12.345;\n\t\tfloat f = (float)d;\n\t\t\n\t\t//看看下面两个定义有没有区别呢?\n\t\tfloat f1 = (float)12.345;\n\t\tfloat f2 = 12.345F;\n\t}\n}\n```\n\n### 20.变量相加和常量相加的面试题\n\n```\n/*\n\t面试题：\n\t\tbyte b1=3,b2=4,b;\n\t\tb=b1+b2;\n\t\tb=3+4;\n\t\t哪句是编译失败的呢？为什么呢？\n\t\tb = b1 + b2;是有问题的。\n\t\t因为变量相加，会首先看类型问题，最终把结果赋值的也会考虑类型问题。\n\t\t常量相加，首先做加法，然后看结果是否在赋值的数据类型范围内，如果不是，才报错。\n*/\nclass DataTypeDemo6 {\n\tpublic static void main(String[] args) {\n\t\t//定义了三个byte类型的变量，b1，b2，b3\n\t\t//b1的值是3，b2的值是4，b没有值\n\t\tbyte b1 = 3,b2 = 4,b;\n\t\t\n\t\t//b = b1 + b2; //这个是类型提升，所以有问题\n\t\t\n\t\tb = 3 + 4; //常量，先把结果计算出来，然后看是否在byte的范围内，如果在就不报错。\n\t}\n}\n```\n\n### 21.强制转换数据溢出后的结果怎么算\n\n```\n/*\n\tbyte b = 130;有没有问题?如果我想让赋值正确，可以怎么做?结果是多少呢?\n\t\n\t练习：byte b = (byte)300;\n*/\nclass DataTypeDemo7 {\n\tpublic static void main(String[] args) {\n\t\t//因为byte的范围是：-128到127。\n\t\t//而130不在此范围内，所以报错。\n\t\t//byte b = 130; \n\t\t\n\t\t//我们可以使用强制类型转换\n\t\tbyte b = (byte) 130;\n\t\t\n\t\t//结果是多少呢?\n\t\tSystem.out.println(b);\n\t}\n}\n/*\n\t分析过程：\n\t\t我们要想知道结果是什么，就应该知道是如何进行计算的。\n\t\t而我们又知道计算机中数据的运算都是补码进行的。\n\t\t而要得到补码，首先要计算出数据的二进制。\n\t\t\n\t\tA:获取130这个数据的二进制。\n\t\t\t00000000 00000000 00000000 10000010\n\t\t\t这是130的原码，也是反码，还是补码。\n\t\tB:做截取操作，截成byte类型的了。\n\t\t\t10000010 \n\t\t\t这个结果是补码。\n\t\tC:已知补码求原码。\n\t\t\t\t\t符号位\t\t数值位\n\t\t\t补码：\t1\t\t\t0000010\n\t\t\t\n\t\t\t反码：\t1\t\t\t0000001\n\t\t\t\n\t\t\t原码：\t1\t\t\t1111110\n*/\n```\n\n### 22.字符数据参与运算\n\n**常用字符与ASCII代码对照表**\n\n![ACSII](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1588762945712&di=15da2d4da03c11464b6f7ef905bd8194&imgtype=0&src=http%3A%2F%2Faliyunzixunbucket.oss-cn-beijing.aliyuncs.com%2Fjpg%2F5802ba54ea55b831c41d5a4b5b13e641.jpg%3Fx-oss-process%3Dimage%2Fresize%2Cp_100%2Fauto-orient%2C1%2Fquality%2Cq_90%2Fformat%2Cjpg%2Fwatermark%2Cimage_eXVuY2VzaGk%3D%2Ct_100)\n\n### 23.字符串参与运算\n\n```\n/*\n\t看程序写结果\n\t\t字符串数据和其他数据做+，结果是字符串类型。\n\t\t这里的+不是加法运算，而是字符串连接符。\n*/\nclass DataTypeDemo9 {\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(\"hello\"+'a'+1); //helloa1，因为有优先级\n\t\tSystem.out.println('a'+1+\"hello\"); //98hello\n\t\t\n\t\tSystem.out.println(\"5+5=\"+5+5); //5+5=55\n\t\tSystem.out.println(5+5+\"=5+5\"); //10=5+5\n\t}\n}\n```\n\n**运算符优先级**\n\n![运算符优先级](https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=807700448,2127105133&fm=26&gp=0.jpg)","tags":["Java系统学习"],"categories":["Java系统学习-JavaSE篇"]},{"title":"JavaSE篇-Day1笔记","url":"/2020/05/04/JavaSE-Day(1)学习笔记/","content":"\n## 一、计算机基础\n\n### 1.计算机概述\n\n  **计算机全称为：电子计算机，俗称电脑**\n\n<!--more-->\n\n### 2.计算机硬件和软件概述\n\n- **计算机硬件是指计算机系统中由电子，机械和光电元件等组成的各种物理装置的总称。**\n- **计算机软件是指使用计算机过程中必不可少的东西，计算机软件可以使家算计按照事先预定好的顺序完成特定的功能，计算机软件按照其功能划分为系统软件和应用软件。**\n  \n### 3.软件开发和计算机语言概述\n\n- **软件开发：借助开发工具与计算机语言制作软件。**\n- **计算机语言：人与计算机之间进行信息交流沟通的一种特殊语言。**\n- **常见的计算机语言如C，C++，C#，JAVA，python。**\n\n### 4.人机交互\n\n   **交互方式：**\n\n- **图形化界面：这种方式简单直观，使用者易于接受，容易操作上手。**\n- **命令性方式：需要一个控制台，输入特定的指令，让计算机完成一些操作。较为麻烦。需要记录住一些命令。**\n\n### 5.键盘功能键和快捷键\n\n   **应该记住一些简单的功能键和快捷键**\n\n- **Tab 缩进空格**\n- **Enter 回车**\n- **Window键**\n- **Ctrl+A全选 Ctrl+C 复制 Ctrl+V 粘贴 Ctrl+X剪切 Ctrl+Z 撤销 Ctrl+S 保存**\n\n### 6.如何打开DOS控制台\n\n   **Windows+R -> cmd -> 回车**\n\n### 7.常见的DOS讲解\n\n- **d: +回车   盘符切换**\n- **dir(directory):   列出当前目录下的文件以及文件夹**\n- **md(make directory):    创建目录**\n- **rd(remove directory):   删除目录**\n- **cd(change directory):   改变指定目录（进入指定目录）**\n- **cd..:     退回上级目录**\n- **cd\\:     退回根目录**\n- **exit:     推出dos命令行**\n- **cls(clear screen):    清屏**\n- **del(delete):   删除文件，删除一堆后缀名一样的文件，例如.txt**\n\n## 二、Java语言基础\n\n### 1.Java语言概述\n\n**Java语言由詹姆斯.高斯林发明**\n\n### 2.Java语言跨平台原理\n\n**Java是面向对象的语言，其重点特点是开源和跨平台**\n\n![Java语言的跨平台性](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=52291647,1781400255&fm=15&gp=0.jpg)\n\n### 3.JDK与JRE的概述\n\n**JRE -> Java运行环境**\n\n**JDK -> Java开发工具包，其中包含了JRE**\n\n**简单而言：使用JDK开发完成的java程序，交给JRE去运行**\n\n### 4.JDK的下载、安装和卸载\n\n**详情请看：https://blog.csdn.net/nuoyanli/article/details/86513950**\n\n### 5.Java环境变量的配置\n\n**详情请看：https://blog.csdn.net/nuoyanli/article/details/86513950**\n\n### 6.第一个Java案例的编写和运行\n\n**视频里老师用的是记事本进行编写和运行，而我用的是Eclipse Jee 2018-12**\n\n```\nimport java.util.*;\nimport java.math.*;\nimport java.io.*;\npublic class Main {\n\n public static void main(String[] args) {\n  // TODO Auto-generated method stub\n        System.out.println(\"Hello world\");\n }\n}\n```\n","tags":["Java系统学习"],"categories":["Java系统学习-JavaSE篇"]},{"title":"Java系统学习规划(1)——JavaSE篇","url":"/2020/05/04/Java系统学习规划(1)—JavaSE篇/","content":"\n## 写在前面\n\n**关于为什么要在现在系统的学习Java，是因为我觉得去年暑假学习的一些Java知识基本都忘记了(~~其实是因为今年疫情影响，很大概率原地退役，所以也算为以后做做准备~~)**\n\n<!--more-->\n\n## Java系统学习规划(1)\n\n### 一、\n\n**选择什么课程：这里的话我是选择了刘意老师的深入浅出精华版为主，毕向东老师的Java基础教程为辅来进行学习。**\n\n这里给出刘意老师视频的B站地址：https://www.bilibili.com/video/BV1Jt411w7fR?from=search&seid=5273427619493979344\n\n这里给出毕向东老师视频的B站地址：https://www.bilibili.com/video/BV1pt41127na?from=search&seid=9126689322584219690\n\n### 二、\n\n**学习重点参考** \n\n初学者也容易想走捷径。我相信很多人都会有这个想法：能不能只学工作上要用的？根本原因是知识点真的太多了。以刘意老师视频为例，面向对象（封装，继承，多态），异常，多线程，集合框架，IO，网络编程都挺难的。其中面向对象是JavaSE的重中之重，里面的知识点个人认为是最难的。后面的知识点都是建立在这之上展开的，没学好面向对象，后面就会稀里糊涂。当然，也不是真的一点都不能跳，但最好完整地学下来。按照后面JavaWeb的学习来看，我的建议是：\n\n- **面向对象是基石，JavaSE中最重要的一是集合，二是IO，** 希望大家学习这两个知识点时认真对待，多敲代码，多思考。\n- **常用API里，String及其相关类StringBuilder, StringBuffer** 等必须熟悉，后面会不断用到。不学好的话，后面怎么死都不知道！\n- **泛型一般只出现在集合中** ，个人觉得如果一时无法掌握，那么**暂时会在集合中使用泛型就行了。**\n- 反射对于初学者来说是**非常抽象的！！** 但它又无比重要。它虽然不是JavaSE的重点，但是**它是JavaWeb很多难点的底层支撑，不懂反射，寸步难行。**\n\n**重点**\n\n- 面向对象☆☆☆☆☆\n- 集合☆☆☆☆☆\n- IO ☆☆☆☆☆\n- String/StringBuffer/StringBuilder ☆☆☆☆☆\n- 反射☆☆☆☆☆\n- 泛型☆☆☆☆\n\n**熟悉**\n\n- 异常\n- 多线程\n\n**先过一遍**\n\n- 网络编程\n- 正则表达式\n\n### 补充\n\n**这里给出刘意老师视频的配套资料**\n\n2015年版本刘意Java基础配套资料：https://pan.baidu.com/s/13slfA9U23PiXca_ROPC0ww   提取码：rmkv\n","tags":["Java系统学习"],"categories":["Java系统学习-JavaSE篇"]},{"title":"我的第一篇博客","url":"/2020/04/30/我的第一篇博客/","content":"## Hexo的一些语法\n\n### 常见命令\n\n```、\n**hexo new \"postName\" #新建文章\nhexo new page \"pageName\" #新建页面\nhexo generate #生成静态页面至public目录\nhexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）\nhexo deploy #部署到GitHub\nhexo help  # 查看帮助\nhexo version  #查看Hexo的版本**\nhexo clean  #清除缓存文件和静态文件\n```\n<!--more-->\n\n### 缩写\n\n```、\nhexo n == hexo new\nhexo g == hexo generate\nhexo s == hexo server\nhexo d == hexo deploy\n```\n\n### 组合命令\n\n```、\nhexo s -g #生成并本地预览\nhexo d -g #生成并上传\n```\n\n### 在生成一篇新的博客的一些操作\n\n**首先：hexo new/n + 博客标题(标题需加双引号)\n然后：运行后会自动生成markdown格式的文章\n然后：按创建成功后的提示信息（路径）进入到该文件所在的目录中，将md后缀的文件在Visual Studio Code中打开，可以在Visual Studio Code中下载一个markdownlint插件进行编辑。\n最后：编辑完成后返回主目录blog(cd … 返回上一层目录)\n运行 hexo clean 清除缓存文件和静态文件（非必要）\n运行 hexo generate/g 生成静态博客文件\n运行 hexo server/s 启动博客**\n\n### 如何把个人博客部署到远端\n\n**在blog目录下运行命令 hexo deploy/d 将本地博客部署到github\n部署过程中按要求输入 github 的账号和密码\n完成后就可直接通过该仓库名（username.github.io）访问博客了**\n","tags":["Hexo的一些基本用法和编写博客的一些注意事项"]},{"title":"Hello Stephencurry6666","url":"/2020/04/30/hello-world/","content":"\n### 科学公式 TeX(KaTeX)\n\n$$E=mc^2$$\n\n行内的公式$$E=mc^2$$行内的公式，行内的$$E=mc^2$$公式。\n\n$$x > y$$\n\n$$(\\sqrt{3x-1}+(1+x)^2)$$\n\n$$\\sin(\\alpha)^{\\theta}=\\sum_{i=0}^{n}(x^i + \\cos(f))$$\n\n$$\\iint_{a}^{b}\\frac{\\mathrm{3} }{\\mathrm{3} x}$$\n\n<!--more-->\n\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n<!--more-->\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]