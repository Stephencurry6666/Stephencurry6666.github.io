[{"title":"牛客算法周周练6","url":"/2020/05/13/牛客算法周周练6/","content":"\n### A题\n\n大小各不相同的一队青蛙站在河左岸的石墩（记为A）上，要过到对岸的石墩(记为D)上去。河心有几片菏叶(分别记为Y1…Ym)和几个石墩(分别记为S1…Sn)。图示如下：\n\n<!--more-->\n\n![tupian](https://uploadfiles.nowcoder.com/images/20180701/305473_1530409311818_55A3FDD5552A97D657101D27CE6E2F90)\n\n青蛙的站队和移动方法规则如下：\n\n1． 每只青蛙只能站在荷叶、石墩，或者仅比它大一号的青蛙背上（统称为合法的落脚点）；\n\n2． 一只青蛙只有背上没有其它青蛙的时候才能够从一个落脚点跳到另一个落脚点；\n\n3． 青蛙允许从左岸A直接跳到河心的石墩、荷叶和右岸的石墩D上，允许从河心的石墩和荷叶跳到右岸的石墩D上；\n\n4． 青蛙在河心的石墩之间、荷叶之间以及石墩和荷叶之间可以来回跳动；\n\n5． 青蛙在离开左岸石墩后，不能再返回左岸；到达右岸后，不能再跳回；\n\n6． 假定石墩承重能力很大，允许无论多少只青蛙都可呆在上面。但是，由于石墩的面积不大，至多只能有一只青蛙直接站在上面，而其他的青蛙只能依规则1落在比它大一号的青蛙的背上。\n7． 荷叶不仅面积不大，而且负重能力也有限，至多只能有一只青蛙站在上面。\n\n8． 每一步只能移动一只青蛙，并且移动后需要满足站队规则；\n\n9． 在一开始的时候，青蛙均站在A上，最大的一只青蛙直接站在石墩上，而其它的青蛙依规则6站在比其大一号的青蛙的背上。\n\n青蛙希望最终能够全部移动到D上，并完成站队。\n\n设河心有m片荷叶和n个石墩，请求出这队青蛙至多有多少只，在满足站队和移动规则的前提下，能从A过到D。\n\n例如，在m=1且n=1时，河心有一片荷叶（Y1）和一个石墩（S1），此时至多有4只青蛙能够过河（由小到大称为1、2、3、4），过河的一种方法为：\n\n![tupian2](https://uploadfiles.nowcoder.com/images/20180701/305473_1530409345048_6028F142230141307F51778CA0C5A02F)\n\n输入描述:\n仅有两行，每一行仅包含一个整数和一个换行/回车符。第一行的数字为河心的石墩数n(0 ≤ N ≤ 25)，第二行为荷叶数m(0 ≤ M ≤ 25)。\n\n输出描述:\n仅包含一个数字和一个换行/回车符。该数字为在河心有n个石墩和m片荷叶时，最多能够过河的青蛙的只数。\n\n输入\n\n1\n\n1\n\n输出\n\n4\n\n**题意：**\n中文题，不过多叙述题意。\n\n**思路：**\n这道题的话，看起来像汉诺塔，但是汉诺塔可以随意移动，虽然也有一定前提。但是对这个题目来说最要命的约束条件就是到了对面就不能动了。所以我们可以知道一定是重的青蛙先跳去对面。所以我们从几个极端来看。\n如果给出莲叶数是m，石头数目是n。\n\n如果n是0，那么最多可以允许m+1个青蛙，m个青蛙填满莲叶，最后一个青蛙跳过去。\n如果n是1，那么最多允许m+1个青蛙先填满莲叶，在去石头上面过渡，另外的m+1个青蛙根据m=0的情况跳。所以一共 （m + 1）*2。所以我们得出结论：$ans=2^{n}*(m+1)$\n\n**AC代码：**\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxx = 100010;\nconst int inf = 0x3f3f3f3f;\nusing namespace std;\nint main()\n{\n    int n, m;\n    cin >> n >> m;\n    cout << (1 << n) * (m + 1) << endl;\n    return 0;\n}\n```\n\n### B题\n\n**题意：**\n月月给华华出了一道题，先给你一个式子：$F_{1}=A,F_{2}=B,F_{i}=F_{i-1}+F_{i-2}(i>2)$，然后求$gcd(F_{N},F_{N+1})$。\n\n**思路：**\n这道题的话，考察裴蜀定理,裴蜀定理具体如下：裴蜀定理（或贝祖定理）得名于法国数学家艾蒂安·裴蜀，说明了对任何整数a、b和它们的最大公约数d，关于未知数x和y的线性不定方程（称为裴蜀等式）：若a,b是整数,且$gcd(a,b)=d$，那么对于任意的整数x,y,ax+by都一定是d的倍数，特别地，一定存在整数x,y，使$ax+by=d$成立。由裴蜀定理可知，要求$gcd(F_{N},F_{N+1})$,只要求出$gcd(A,B)$就可以了，这两者是相等的。并且C++函数库中已经封装了_$gcd(a,b)$用来求a与b之间的最大公约数，我们只需要套用就可以了。\n\n**AC代码：**\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxx = 100010;\nconst int inf = 0x3f3f3f3f;\nusing namespace std;\nint main()\n{\n    ll a, b, n;\n    cin >> a >> b >> n;\n    cout << __gcd(a, b) << endl;\n    return 0;\n}\n```\n\n### C题\n\n**题意：**\nNancy喜欢博弈！\nJohnson和Nancy得到了一个神奇的多重集合，仅包含一个正整数n，两个人轮流进行操作。\n一次操作可以将集合中一个数字分解为它的任意两个非1的因数，并加入集合中。\n他们想知道，在Johnson和Nancy绝顶聪明的情况下，如果Nancy先手进行操作，最后谁没有办法继续操作了呢？\n\n**思路：**\n这道题的话，每次操作可以将集合中的一个数字分解为它的任意两个非1的因数, 集合中的数字个数+1。因为质因数是无法再被分解的,所以最后集合中的数全为 n 的质因数。因此只需要看题目给定的n有多少个质因数。假设n有p个质因数，那么这场游戏将进行p-1次操作（每次操作后集合中的数字个数+1），如果p-1为奇数那么后手便无法再进行操作，如果p-1为偶数则先手再无法进行操作。所以我们只要筛一下素数就行了。最后$n==1$的情况要判断一下。\n\n**AC代码：**\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxx = 100010;\nconst int inf = 0x3f3f3f3f;\nusing namespace std;\nint main()\n{\n    int n;\n    cin >> n;\n    if (n == 1)\n    {\n        cout << \"Nancy\" << endl;\n        return 0;\n    }\n    int ans = 0;\n    for (int i = 2; i <= n; i++)\n    {\n        while (n % i == 0)\n        {\n            n /= i;\n            ans++;\n        }\n    }\n    if (ans % 2 != 0)\n        cout << \"Nancy\" << endl;\n    else\n        cout << \"Johnson\" << endl;\n    return 0;\n}\n```\n\n### D题\n\n**题意：**\n胡队长带领HA实验的战士们玩真人CS，真人CS的地图由一些据点组成，现在胡队长已经占领了n个据点，为了方便，将他们编号为1~n，为了隐蔽，胡队长命令战士们在每个据点出挖一个坑，让战士们躲在坑里。由于需要在任意两个点之间传递信息，两个坑之间必须挖出至少一条通路，而挖沟是一件很麻烦的差事，所以胡队长希望挖出数量尽可能少的沟，使得任意两个据点之间有至少一条通路，顺便，尽可能的$\\sum d[i][j]$使最小（其中$d[i][j]$为据点i到j的距离）。\n\n**思路：**\n这道题的话，就是一道裸的最小生成树，直接做就可以了。\n\n**AC代码：**\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxx = 100010;\nconst int inf = 0x3f3f3f3f;\nusing namespace std;\nstruct node\n{\n    int s;\n    int e;\n    int v;\n} edge[maxx*5];\nbool cmp(node a, node b)\n{\n    return a.v < b.v;\n}\nint pre[maxx];\nint n, m;\nvoid init()\n{\n    for (int i = 0; i <= n; i++)\n        pre[i] = i;\n}\nint getf(int a)\n{\n    if (pre[a] == a)\n        return a;\n    int tmp = getf(pre[a]);\n    return pre[a] = tmp;\n}\nint Kruskal(int a, int b)\n{\n    int fa = getf(a);\n    int fb = getf(b);\n    if (fa != fb)\n    {\n        pre[fa] = fb;\n        return 1;\n    }\n    else\n        return 0;\n}\nint main()\n{\n    while (cin >> n >> m)\n    {\n        init();\n        for (int i = 1; i <= m; i++)\n            cin >> edge[i].s >> edge[i].e >> edge[i].v;\n        sort(edge + 1, edge + m + 1, cmp);\n        int ans = 0;\n        for (int i = 1; i <= m; i++)\n        {\n            if (Kruskal(edge[i].s, edge[i].e))\n                ans += edge[i].v;\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n```\n\n### E题\n\n**题意：**\n这道题给你了一些代码，让你补全。\n\n**思路：**\n这道题的话，看完代码后不难看出是求的线段树，所以我们按要求补全即可。\n\n**AC代码：**\n\n```\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <climits>\n#include <cstdio>\n#include <vector>\n#include <cstdlib>\n#include <ctime>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#define fi first\n#define lc (x << 1)\n#define se second\n#define U unsigned\n#define rc (x << 1 | 1)\n#define Re register\n#define LL long long\n#define MP std::make_pair\n#define CLR(i, a) memset(i, a, sizeof(i))\n#define FOR(i, a, b) for (Re int i = a; i <= b; ++i)\n#define ROF(i, a, b) for (Re int i = a; i >= b; --i)\n#define SFOR(i, a, b, c) for (Re int i = a; i <= b; i += c)\n#define SROF(i, a, b, c) for (Re int i = a; i >= b; i -= c)\n#define DEBUG(x) std::cerr << #x << '=' << x << std::endl\nconst int MAXN = 1000000 + 5;\nint N, maxL;\nstd::set<std::pair<int, int>> L;\nint a[MAXN];\ninline int calc()\n{\n    // 返回 set 中所有线段的并长度。(每个 pair 表示一个线段[first,second]\n    int ans = 0;\n    for (int i = 1; i <= maxL; i++)\n    {\n        if (a[i])\n            ans++;\n    }\n    return ans;\n}\nint main()\n{\n    scanf(\"%d%d\", &N, &maxL);\n    while (N--)\n    {\n        int opt, x, y;\n        scanf(\"%d%d%d\", &opt, &x, &y);\n        if (opt == 1)\n        {\n            if (L.find(MP(x, y)) != L.end())\n                continue;\n            L.insert(MP(x, y));\n            for (int i = x; i <= y; i++)\n                a[i]++;\n        }\n        if (opt == 2)\n        {\n            if (L.find(MP(x, y)) == L.end())\n                continue;\n            L.erase(MP(x, y));\n            for (int i = x; i <= y; i++)\n                a[i]--;\n        }\n        if (opt == 3)\n        {\n            printf(\"%d\\n\", calc());\n        }\n    }\n    return 0;\n}\n```\n","tags":["牛客题解"],"categories":["牛客题解"]},{"title":"JavaSE-Day(3)学习笔记","url":"/2020/05/12/JavaSE-Day(3)学习笔记/","content":"\n## 数据类型中补充的几个小问题\n\n<!--more-->\n\n```\n1:在定义Long或者Float类型变量的时候，要加L或者f。\n  整数默认是int类型，浮点数默认是double。\n  \n  byte，short在定义的时候，他们接收的其实是一个int类型的值。\n  这个是自己做了一个数据检测的，如果不再它们的范围内，就报错。\n  \n2:byte值的问题\n\tbyte b1 = 127;\n\tbyte b2 = (byte)128; //-128\n\tbyte b3 = (byte)129; //-127\n\tbyte b4 = (byte)130; //-126\n\t\n\tbyte的范围：-128 ~ 127\n\t\n\t128：10000000\n\t-128：10000000 (这里的1即是符号位，也是数值位)\n\t\n3:数据类型转换之默认转换\n\tbyte,short,char -- int -- long -- float -- double\n\t\n\tlong: 8个字节\n\tfloat：4个字节\n\t\n\tA:它们底层的存储结构不同。\n\tB:float表示的数据范围比long的范围要大\n\t\tlong：2^63-1\n\t\tfloat：3.4*10^38 > 2*10^38 > 2*8^38 = 2*2^3^38 = 2*2^114 > 2^63-1\n\n4:Java语言中的字符char可以存储一个中文汉字吗?为什么呢?\n\t可以。因为java语言中的字符占用两个字节。\n\t\n\tJava语言采用的是Unicode编码。\n```\n\n## 算术运算符的基本用法\n\n### 算术运算符\n\n```\n/*\n\t算术运算符：\n\t\t+,-,*,/,%,++,--\n\t\t\n\t注意事项：\n\t\tA:整数相除只能得到整数。如果想得到小数，必须把数据变化为浮点数类型\n\t\tB:/获取的是除法操作的商，%获取的是除法操作的余数\n*/\n\nclass OperatorDemo {\n\tpublic static void main(String[] args) {\n\t\t//定义变量\n\t\tint x = 3;  //把3赋值给int类型的变量x\n\t\tint y = 4;\n\t\t\n\t\tSystem.out.println(x+y);\n\t\tSystem.out.println(x-y);\n\t\tSystem.out.println(x*y);\n\t\tSystem.out.println(x/y); //整数相除只能得到整数\n\t\t\n\t\t//我就想得到小数，该肿么办呢?\n\t\t//只需要把操作的数据中任意的一个数据变为浮点数\n\t\tSystem.out.println(x*1.0/y);\n\t\t\n\t\t//%的应用\n\t\tSystem.out.println(x%y); //得到的是余数\n\t}\n}\n```\n\n### 算术运算符++和--的使用\n\n```\n/*\n\t++,--运算符的使用：\n\t\t单独使用：\n\t\t\t放在操作数的前面和后面效果一样。(这种用法是我们比较常见的)\n\t\t参与运算使用：\n\t\t\t放在操作数的前面，先自增或者自减，然后再参与运算。\n\t\t\t放在操作数的后面，先参与运算，再自增或者自减。\n\t\t\t\n\t作用：就是对变量进行自增1或者自减1。\n*/\nclass OperatorDemo2 {\n\t\tpublic static void main(String[] args) {\n\t\t\t//定义两个变量\n\t\t\tint x = 3;\n\t\t\tint y = 4;\n\t\t\t\n\t\t\t//字符串的拼接\n\t\t\t//System.out.println(\"x:\"+x);\n\t\t\t//System.out.println(\"y:\"+y);\n\t\t\t\n\t\t\tSystem.out.println(\"x:\"+x+\",y:\"+y);\n\t\t\t\n\t\t\t//单独使用\n\t\t\t//x++;\n\t\t\t//y--;\n\t\t\t++x;\n\t\t\t--y;\n\t\t\t//System.out.println(x);\n\t\t\tSystem.out.println(\"x:\"+x+\",y:\"+y);\n\t\t\t\n\t\t\t//意外的类型,常量是不可以这样做的\n\t\t\t//System.out.println(10++);\n\t\t\t\n\t\t\tSystem.out.println(\"-------------------\");\n\t\t\t//参与运算使用\n\t\t\tint a = 3;\n\t\t\tint b = 4;\n\t\t\t\n\t\t\t//int c = a++;\n\t\t\t//int d = b--;\n\t\t\t\n\t\t\tint c = ++a;\n\t\t\tint d = --b;\n\t\t\t\n\t\t\tSystem.out.println(\"a:\"+a); //4, 4\n\t\t\tSystem.out.println(\"b:\"+b); //3, 3\n\t\t\tSystem.out.println(\"c:\"+c); //3, 4\n\t\t\tSystem.out.println(\"d:\"+d); //4, 3\n\t\t}\n}\n```\n\n### 算术运算符+的多种用法\n\n```\n/*\n\t+的用法：\n\t\tA:加法\n\t\tB:正号\n\t\tC:字符串连接符\n*/\nclass OperatorDemo3 {\n\tpublic static void main(String[] args) {\n\t\t//加法\n\t\tSystem.out.println(3+4);\n\t\t\n\t\t//正号\n\t\tSystem.out.println(+4);\n\t\t\n\t\tSystem.out.println('a');\n\t\tSystem.out.println('a'+1); //这里是加法\n\t\t\n\t\t//字符串连接符\n\t\tSystem.out.println(\"hello\"+'a'+1);\n\t\tSystem.out.println('a'+1+\"hello\");\n\t}\n}\n```\n\n### 算术运算符++和--的练习\n\n```\n/*\n\t++,--的练习题\n\t\n\t第一题：\n\tint a = 10;\n\tint b = 10;\n\tint c = 10;\n\n\ta = b++;\n\tc = --a;\n\tb = ++a;\n\ta = c--;\n\t请分别计算出a,b,c的值\n\t\n\t第二题：\n\tint x = 4;\n\tint y = (x++)+(++x)+(x*10);\n\t请分别计算出x,y的值\n*/\nclass OperatorTest {\n\tpublic static void main(String[] args) {\n\t\tint a = 10;\n\t\tint b = 10;\n\t\tint c = 10;\n\n\t\ta = b++; //a=10,b=11,c=10\n\t\tc = --a; //a=9,b=11,c=9\n\t\tb = ++a; //a=10,b=10,c=9\n\t\ta = c--; //a=9,b=10,c=8\n\t\t\n\t\tSystem.out.println(\"a:\"+a);\n\t\tSystem.out.println(\"b:\"+b);\n\t\tSystem.out.println(\"c:\"+c);\n\t\tSystem.out.println(\"--------------\");\n\t\t\n\t\tint x = 4;\n\t\tint y = (x++)+(++x)+(x*10);\n\t\t//4+6+60\n\t\t//x=5,6\n\t\t\n\t\tSystem.out.println(\"x:\"+x);\n\t\tSystem.out.println(\"y:\"+y);\n\t}\n}\n```\n\n### 赋值运算符的基本用法\n\n```\n/*\n\t赋值运算符：\n\t\t基本的赋值运算符：=\n\t\t\t把=右边的数据赋值给左边。\n\t\t\t\n\t\t扩展的赋值运算符：+=,-=,*=,/=,%=\n\t\t\t+= 把左边和右边做加法，然后赋值给左边。\n*/\nclass OperatorDemo {\n\tpublic static void main(String[] args) {\n\t\t//定义一个变量\n\t\tint x = 10;\n\t\t\n\t\t//其他用法\n\t\tint a,b; \n\t\ta = b = 10;\n\t\tSystem.out.println(a); \n\t\tSystem.out.println(b);\n\t\tSystem.out.println(\"-----------\");\n\n\t\t//定义一个变量\n\t\tint y = 10;\n\t\t\n\t\ty += 20;\n\t\t\n\t\tSystem.out.println(y);\n\t\t\n\t}\n}\n```\n\n### 赋值运算符的面试题\n\n```\n/*\n\t面试题：\n\t\tshort s=1;s = s+1; \n\t\t\n\t\tshort s=1;s+=1;\n\t\t上面两个代码有没有问题，如果有，那里有问题。\n\t\t\n\t\t为什么第二个木有问题呢?\n\t\t\t扩展的赋值运算符其实隐含了一个强制类型转换。\n\t\t\t\n\t\t\ts += 1;\n\t\t\t不是等价于 s = s + 1;\n\t\t\t而是等价于 s = (s的数据类型)(s + 1);\n*/\nclass OperatorTest {\n\tpublic static void main(String[] args) {\n\t\t//short s = 1;\n\t\t//s = s + 1;\n\t\t//System.out.println(s);\n\t\t\n\t\tshort s = 1;\n\t\ts += 1; //好像是 s = s + 1;\n\t\tSystem.out.println(s);\n\t}\n}\n```\n\n### 比较运算符的基本用法及其注意事项\n\n```\n/*\n\t比较运算符：\n\t\t==,!=,>,>=,<,<=\n\t\t\n\t特点：\n\t\t无论你的操作是简单还是复杂，结果是boolean类型。\n\t\t\n\t注意事项：\n\t\t\"==\"不能写成\"=\"。\n*/\nclass OperatorDemo {\n\tpublic static void main(String[] args) {\n\t\tint x = 3;\n\t\tint y = 4;\n\t\tint z = 3;\n\t\n\t\tSystem.out.println(x == y);\n\t\tSystem.out.println(x == z);\n\t\tSystem.out.println((x+y) == (x+z));\n\t\tSystem.out.println(\"------------\");\n\t\t\n\t\tSystem.out.println(x != y);\n\t\tSystem.out.println(x > y);\n\t\tSystem.out.println(x >= y);\n\t\tSystem.out.println(x < y);\n\t\tSystem.out.println(x <= y);\n\t\tSystem.out.println(\"------------\");\n\t\t\n\t\tint a = 10;\n\t\tint b = 20;\n\t\t\n\t\t//boolean flag = (a == b);\n\t\t//boolean flag = (a = b); //这个是有问题的，不兼容的类型\n\t\t//System.out.println(flag);\n\t\t\n\t\tint c = (a = b); //把b赋值给a，然后把a留下来\n\t\tSystem.out.println(c);\n\t}\n}\n```\n\n### 逻辑运算符的基本用法\n\n```\n/*\n\t逻辑运算符：\n\t\t&,|,^,!\n\t\t&&,||\n\t\t\n\t特点：\n\t\t逻辑运算符一般用于连接boolean类型的表达式或者值。\n\t\t\t\n\t\t表达式：就是用运算符把常量或者变量连接起来的符合java语法的式子。\n\t\t\t算术表达式：a + b\n\t\t\t比较表达式：a == b\n\t\t\t\n\t结论：\n\t\t&逻辑与:有false则false。\n\t\t|逻辑或:有true则true。\n\t\t^逻辑异或:相同为false，不同为true。\n\t\t\t举例：情侣关系。男男,男女,女男,女女\n\t\t!逻辑非:非false则true，非true则false。\n\t\t\t特点：偶数个不改变本身。\n*/\nclass OperatorDemo {\n\tpublic static void main(String[] args) {\n\t\tint a = 3;\n\t\tint b = 4;\n\t\tint c = 5;\n\t\t\n\t\t//&逻辑与\n\t\tSystem.out.println((a > b) & (a > c)); //false & false = false\n\t\tSystem.out.println((a > b) & (a < c)); //false & true = false\n\t\tSystem.out.println((a < b) & (a > c)); //true & false = false\n\t\tSystem.out.println((a < b) & (a < c)); //true & true = true\n\t\tSystem.out.println(\"---------------\");\n\t\t\n\t\t//|逻辑或\n\t\tSystem.out.println((a > b) | (a > c)); //false | false = false\n\t\tSystem.out.println((a > b) | (a < c)); //false | true = true\n\t\tSystem.out.println((a < b) | (a > c)); //true | false = true\n\t\tSystem.out.println((a < b) | (a < c)); //true | true = true\n\t\tSystem.out.println(\"---------------\");\n\t\t\n\t\t//^逻辑异或\n\t\tSystem.out.println((a > b) ^ (a > c)); //false ^ false = false\n\t\tSystem.out.println((a > b) ^ (a < c)); //false ^ true = true\n\t\tSystem.out.println((a < b) ^ (a > c)); //true ^ false = true\n\t\tSystem.out.println((a < b) ^ (a < c)); //true ^ true = false\n\t\tSystem.out.println(\"---------------\");\n\t\t\n\t\t//!逻辑非\n\t\tSystem.out.println(!(a > b)); //!false = true\n\t\tSystem.out.println(!(a < b)); //!true = false\n\t\tSystem.out.println(!!(a > b)); //!!false = false\n\t\tSystem.out.println(!!!(a > b)); //!!false = true\n\t}\n}\n```\n\n### 逻辑运算符&&和&的区别\n\n```\n/*\n\t&&和&的区别? 同理||和|的区别?\n\t\tA:最终结果一样。\n\t\tB:&&具有短路效果。左边是false，右边不执行。\n\t\tC:||具有短路效果，左边是true，右边不执行。\n\t\t\n\t开发中常用的逻辑运算符：\n\t\t&&,||,!\n*/\nclass OperatorDemo2 {\n\tpublic static void main(String[] args) {\n\t\tint a = 3;\n\t\tint b = 4;\n\t\tint c = 5;\n\t\t\n\t\t//&&双与\n\t\tSystem.out.println((a > b) && (a > c)); //false && false = false\n\t\tSystem.out.println((a > b) && (a < c)); //false && true = false\n\t\tSystem.out.println((a < b) && (a > c)); //true && false = false\n\t\tSystem.out.println((a < b) && (a < c)); //true && true = true\n\t\tSystem.out.println(\"----------------\");\n\t\t\n\t\tint x = 3;\n\t\tint y = 4;\n\t\t\n\t\t//boolean b1 = ((x++ == 3) & (y++ == 4));\n\t\t//boolean b1 = ((x++ == 3) && (y++ == 4));\n\t\t//boolean b1 = ((++x == 3) & (y++ == 4));\n\t\tboolean b1 = ((++x == 3) && (y++ == 4));\n\t\tSystem.out.println(\"x:\"+x);\n\t\tSystem.out.println(\"y:\"+y);\n\t\tSystem.out.println(b1);\n\t}\n}\n```\n\n### 位运算的基本用法1\n\n```\n/*\n\t位运算符：\n\t\t&,|,^,~\n\t\t<<,>>,>>>\n\t\t\n\t注意：\n\t\t要做位运算，首先要把数据转换为二进制。\n*/\nclass OperatorDemo {\n\tpublic static void main(String[] args) {\n\t\t//&,|,^,~\n\t\t\n\t\tint a = 3;\n\t\tint b = 4;\n\t\t\n\t\tSystem.out.println(3 & 4);\n\t\tSystem.out.println(3 | 4);\n\t\tSystem.out.println(3 ^ 4);\n\t\tSystem.out.println(~3);\n\t}\n}\n/*\n\t分析：因为是位运算，所以我们必须先把数据换算成二进制。\n\t\n\t3的二进制：11\n\t\t00000000 00000000 00000000 00000011\n\t4的二进制：100\n\t\t00000000 00000000 00000000 00000100\n\t\n\t&位与运算：有0则0。\n\t\t00000000 00000000 00000000 00000011\n\t   &00000000 00000000 00000000 00000100\n\t\t-----------------------------------\n\t\t00000000 00000000 00000000 00000000\n\t\t结果是：0\n\t\t\n\t|位或运算：有1则1。\n\t\t00000000 00000000 00000000 00000011\n\t   |00000000 00000000 00000000 00000100\n\t\t-----------------------------------\n\t\t00000000 00000000 00000000 00000111\n\t\t结果是：7\n\t\t\n\t^位异或运算：相同则0，不同则1。\n\t\t00000000 00000000 00000000 00000011\n\t   &00000000 00000000 00000000 00000100\n\t\t-----------------------------------\n\t\t00000000 00000000 00000000 00000111\n\t\t结果是：7\n\t\t\n\t~按位取反运算符：0变1，1变0\n\t\t00000000 00000000 00000000 00000011\n\t   ~11111111 11111111 11111111 11111100 (补码)\n\t   \n\t   补码：11111111 11111111 11111111 11111100\n\t   反码：11111111 11111111 11111111 11111011\n\t   原码：10000000 00000000 00000000 00000100\n\t\t结果是：-4\n*/\n```\n\n### 位异或运算符的特点\n\n```\n/*\n\t^的特点：一个数据对另一个数据位异或两次，该数本身不变。\n*/\nclass OperatorDemo2 {\n\tpublic static void main(String[] args) {\n\t\tint a = 10;\n\t\tint b = 20;\n\t\t\n\t\tSystem.out.println(a ^ b ^ b); //10\n\t\tSystem.out.println(a ^ b ^ a); //20\n\t}\n}\n```\n\n### 位运算的面试题\n\n```\n/*\n\t面试题：\n\t\t请自己实现两个整数变量的交换\n\t\t注意：以后讲课的过程中，我没有明确指定数据的类型，默认int类型。\n*/\nclass OperatorTest {\n\tpublic static void main(String[] args) {\n\t\tint a = 10;\n\t\tint b = 20;\n\t\t\n\t\tSystem.out.println(\"a:\"+a+\",b:\"+b);\n\t\t\n\t\t//方式1：使用第三方变量(开发中用的)\n\t\t/*\n\t\tint c = a;\n\t\ta = b;\n\t\tb = c;\n\t\tSystem.out.println(\"a:\"+a+\",b:\"+b);\n\t\tSystem.out.println(\"------------\");\n\t\t*/\n\t\t\n\t\t//方式2：用位异或实现(面试用)\n\t\t//左边：a,b,a\n\t\t//右边：a ^ b\n\t\t/*\n\t\ta = a ^ b;\n\t\tb = a ^ b; //a ^ b ^ b = a\n\t\ta = a ^ b; //a ^ b ^ a = b\n\t\tSystem.out.println(\"a:\"+a+\",b:\"+b);\n\t\t*/\n\t\t\n\t\t//方式3：用变量相加的做法\n\t\t/*\n\t\ta = a + b; //a=30\n\t\tb = a - b; //b=10\n\t\ta = a - b; //a=20\n\t\tSystem.out.println(\"a:\"+a+\",b:\"+b);\n\t\t*/\n\t\t\n\t\t//方式4：一句话搞定\n\t\tb = (a+b) - (a=b); //b=30-20=10,a=20\n\t\tSystem.out.println(\"a:\"+a+\",b:\"+b);\n\t}\n}\n```\n\n### 位运算的基本用法2及面试题\n\n```\n/*\n\t<<:左移\t左边最高位丢弃，右边补齐0\n\t>>:右移\t最高位是0，左边补齐0；最高为是1，左边补齐1\n\t>>>:无符号右移 无论最高位是0还是1，左边补齐0\n\t\n\t面试题：\n\t\t请用最有效率的方式写出计算2乘以8的结果?\n\t\t\t2 * 8\n\t\t\t\n\t\t\t2 << 3\n\n*/\nclass OperatorDemo3 {\n\tpublic static void main(String[] args) {\n\t\t//<< 把<<左边的数据乘以2的移动次幂\n\t\tSystem.out.println(3 << 2); //3*2^2 = 3*4 = 12;\n\t\n\t\t//>> 把>>左边的数据除以2的移动次幂\n\t\tSystem.out.println(24 >> 2); //24 / 2^2 = 24 / 4 = 6\n\t\tSystem.out.println(24 >>> 2);\n\t\t\n\t\tSystem.out.println(-24 >> 2); \n\t\tSystem.out.println(-24 >>> 2);\n\t}\n}\n/*\n\t计算出3的二进制：11\n\t\t00000000 00000000 00000000 00000011\n\t(00)000000 00000000 00000000 0000001100\n\t\t\n\t>>的移动：\t\n\t计算出24的二进制：11000\n\t\t原码：10000000 00000000 00000000 00011000\n\t\t反码：11111111 11111111 11111111 11100111\n\t\t补码：11111111 11111111 11111111 11101000\n\t\t\n\t\t11111111 11111111 11111111 11101000\n\t\t1111111111 11111111 11111111 111010(00) 补码\n\t\t\n\t\t补码：1111111111 11111111 11111111 111010\n\t\t反码：1111111111 11111111 11111111 111001\n\t\t原码：1000000000 00000000 00000000 000110\n\t\t\n\t\t结果：-6\n\t\t\n\t>>>的移动：\n\t\t计算出24的二进制：11000\n\t\t原码：10000000 00000000 00000000 00011000\n\t\t反码：11111111 11111111 11111111 11100111\n\t\t补码：11111111 11111111 11111111 11101000\n\t\t\n\t\t11111111 11111111 11111111 11101000\n\t\t0011111111 11111111 11111111 111010(00)\n\t\t\n\t\t结果：\n*/\n```\n\n### 三元运算符的基本用法\n\n```\n/*\n\t单目运算符：~3\n\t双目运算符：3 + 4\n\n\t三目运算符：\n\t\t格式：比较表达式?表达式1:表达式2;\n\t\t\n\t\t比较表达式:结果是一个boolean类型。\n\t\t\n\t\t执行流程：\n\t\t\t根据比较表达式的计算返回一个true或者false。\n\t\t\t如果是true，就把表达式1作为结果。\n\t\t\t如果是false，就把表达式2作为结果。\n*/\nclass OperatorDemo {\n\tpublic static void main(String[] args) {\n\t\tint x = 100;\n\t\tint y = 200;\n\t\t\n\t\tint z = ((x > y)? x: y);\n\t\t\n\t\t//int z = ((x < y)? x: y);\n\t\t\n\t\t//int z = ((x == y)? x: y);\n\t\t\n\t\t//报错\n\t\t//int z = ((x = y)? x : y);\n\t\t\n\t\tSystem.out.println(\"z:\"+z);\n\t}\n}\n```\n\n### 三元运算符的练习\n\n```\n/*\n\t练习：\n\t\t获取两个整数中的最大值\n\t\t获取三个整数中的最大值\n\t\t比较两个整数是否相同\n*/\nclass OperatorTest {\n\tpublic static void main(String[] args) {\n\t\t//获取两个整数中的最大值\n\t\tint x = 100;\n\t\tint y = 200;\n\t\t\n\t\tint max = (x > y? x: y);\n\t\tSystem.out.println(\"max:\"+max);\n\t\tSystem.out.println(\"--------\");\n\t\t\n\t\t//获取三个整数中的最大值\n\t\tint a = 10;\n\t\tint b = 30;\n\t\tint c = 20;\n\t\t\n\t\t//分两步：\n\t\t//A:先比较a,b的最大值\n\t\t//B:拿a,b的最大值在和c进行比较\n\t\tint temp = ((a > b)? a: b);\n\t\t//System.out.println(temp);\n\t\tint max1 = (temp > c? temp: c);\n\t\tSystem.out.println(\"max1:\"+max1);\n\t\t\n\t\t//一步搞定\n\t\t//int max2 = (a > b)?((a > c)? a: c):((b > c)? b: c);\n\t\t//这种做法不推荐。\n\t\t//int max2 = a > b?a > c? a: c:b > c? b: c;\n\t\t//System.out.println(\"max2:\"+max2);\n\t\tSystem.out.println(\"--------\");\n\t\t\n\t\t//比较两个整数是否相同\n\t\tint m = 100;\n\t\tint n = 200;\n\t\t\n\t\t//boolean flag = (m == n)? true: false;\n\t\tboolean flag = (m == n);\n\t\tSystem.out.println(flag);\n\t}\n}\n```\n\n### 键盘录入的基本格式讲解\n\n```\n/*\n\t为了让程序的数据更符合开发的数据，我们就加入了键盘录入。\n\t让程序更灵活一下。\n\t\n\t那么，我们如何实现键盘数据的录入呢?\n\t\tA:导包\n\t\t\t格式：\n\t\t\t\timport java.util.Scanner; \n\t\t\t位置：\n\t\t\t\t在class上面。\n\t\tB:创建键盘录入对象\n\t\t\t格式：\n\t\t\t\tScanner sc = new Scanner(System.in);\n\t\tC:通过对象获取数据\t\n\t\t\t格式：\n\t\t\t\tint x = sc.nextInt();\n*/\nimport java.util.Scanner;\n\nclass ScannerDemo {\n\tpublic static void main(String[] args) {\n\t\t//创建键盘录入数据对象\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tSystem.out.println(\"请你输入一个数据：\");\n\t\tint x = sc.nextInt();\n\t\t\n\t\tSystem.out.println(\"你输入的数据是：\"+x);\n\t}\n}\n```\n\n### 键盘录入的练习1\n\n```\n/*\n\t键盘录入练习：\n\t\t键盘录入两个数据，并对这两个数据求和，输出其结果\n*/\nimport java.util.Scanner;\n\nclass ScannerTest {\n\tpublic static void main(String[] args) {\n\t\t//键盘录入两个数据，并对这两个数据求和，输出其结果\n\t\t//创建键盘录入对象\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tSystem.out.println(\"请输入第一个数据：\");\n\t\tint x = sc.nextInt();\n\t\t\n\t\tSystem.out.println(\"请输入第二个数据：\");\n\t\tint y = sc.nextInt();\n\t\t\n\t\t//把键盘录入的数据进行相加即可\n\t\tint sum = (x + y);\n\t\tSystem.out.println(\"sum:\"+sum);\n\t}\n}\n\n/*\n\t键盘录入练习：键盘录入两个数据，获取这两个数据中的最大值\n*/\n\nimport java.util.Scanner;\n\nclass ScannerTest2 {\n\tpublic static void main(String[] args) {\n\t\t//创建键盘录入对象\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tSystem.out.println(\"请输入第一个数据：\");\n\t\tint a = sc.nextInt();\n\t\t\n\t\tSystem.out.println(\"请输入第二个数据：\");\n\t\tint b = sc.nextInt();\n\t\t\n\t\t//获取这两个数据中的最大值\n\t\tint max = (a > b? a: b);\n\t\tSystem.out.println(\"max:\"+max);\n\t}\n}\n```\n\n### 键盘录入的练习2\n\n```\n/*\n\t练习：\n\t\t键盘录入三个数据，获取这三个数据中的最大值\n\t\t键盘录入两个数据，比较这两个数据是否相等\n*/\nimport java.util.Scanner;\n\nclass ScannerTest3 {\n\tpublic static void main(String[] args) {\n\t\t//键盘录入三个数据，获取这三个数据中的最大值\n\t\n\t\t//创建键盘录入对象\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tSystem.out.println(\"请输入第一个数据：\");\n\t\tint a = sc.nextInt();\n\t\t\n\t\tSystem.out.println(\"请输入第二个数据：\");\n\t\tint b = sc.nextInt();\n\t\t\n\t\tSystem.out.println(\"请输入第三个数据：\");\n\t\tint c = sc.nextInt();\n\t\t\n\t\t//获取这三个数据中的最大值\n\t\tint temp = ((a > b)? a: b);\n\t\tint max = (temp > c? temp : c);\n\t\tSystem.out.println(\"max:\"+max);\n\t\tSystem.out.println(\"------------------\");\n\t\t\n\t\t//键盘录入两个数据\n\t\tSystem.out.println(\"请输入第一个数据：\");\n\t\tint x = sc.nextInt();\n\t\t\n\t\tSystem.out.println(\"请输入第二个数据：\");\n\t\tint y = sc.nextInt();\n\t\t\n\t\t//比较这两个数据是否相等\n\t\tboolean flag = (x == y);\n\t\tSystem.out.println(\"flag:\"+flag);\n\t}\n}\n```\n\n### 顺序结构语句\n\n```\n/*\n\t流程控制语句：可以控制程序的执行流程。\n\t\n\t分类：\n\t\t顺序结构\n\t\t选择结构\n\t\t循环结构\n\t\t\n\t顺序结构：\n\t\t从上往下，依次执行。\n*/\nclass ShunXuJieGouDemo {\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(\"程序开始了\");\n\t\t\n\t\tSystem.out.println(\"我爱Java\");\n\t\t\n\t\tSystem.out.println(\"程序结束了\");\n\t}\n}\n```\n\n### 选择结构if语句格式1\n\n```\n/*\n\t选择结构：\n\t\tif语句\n\t\tswitch语句\n\t\t\n\tif语句：\n\t\t格式1\n\t\t格式2\n\t\t格式3\n\t\t\n\tif语句的格式：\n\t\tif(比较表达式) {\n\t\t\t语句体;\n\t\t}\n\t\t\n\t\t执行流程：\n\t\t\t先计算比较表达式的值，看其返回值是true还是false。\n\t\t\t如果是true，就执行语句体；\n\t\t\t如果是false，就不执行语句体；\n*/\nclass IfDemo {\n\tpublic static void main(String[] args) {\n\t\tint x = 10;\n\t\t\n\t\tif(x == 10) {\n\t\t\tSystem.out.println(\"x等于10\");\n\t\t}\n\t\t\n\t\tif(x == 20) {\n\t\t\tSystem.out.println(\"x等于20\");\n\t\t}\n\t\t\n\t\tSystem.out.println(\"over\");\n\t}\n}\n```\n\n### 选择结构if语句注意事项\n\n```\n/*\n\tif语句的注意事项：\n\t\tA:比较表达式无论简单还是复杂，结果必须是boolean类型\n\t\tB:if语句控制的语句体如果是一条语句，大括号可以省略；\n\t\t  如果是多条语句，就不能省略。建议永远不要省略。\n\t\tC:一般来说：有左大括号就没有分号，有分号就没有左大括号\n*/\nclass IfDemo2 {\n\tpublic static void main(String[] args) {\n\t\tint x = 10;\n\t\t\n\t\tif(x == 10) {\n\t\t\tSystem.out.println(\"x等于10\");\n\t\t}\n\t\t\n\t\tif((x > 5) || (x == 10)) {\n\t\t\tSystem.out.println(\"x大于或者等于10\");\n\t\t}\n\t\tSystem.out.println(\"-------------------\");\n\t\t\n\t\tint a = 100;\n\t\t\n\t\t/*\n\t\tif(a == 100) {\n\t\t\tSystem.out.println(\"a的值是100\");\n\t\t}\n\t\t*/\n\t\t\n\t\tif(a != 100) {\n\t\t\tSystem.out.println(\"a的值是100\");\n\t\t\tSystem.out.println(\"over\");\n\t\t}\n\t\tSystem.out.println(\"-------------------\");\n\t\t\n\t\tint b = 100;\n\t\tif(b != 100);  //这里其实是有语句体的，只不过是空语句体。\n\t\t\n\t\t//代码块\n\t\t{\n\t\t\tSystem.out.println(\"b的值是100\");\n\t\t\tSystem.out.println(\"over\");\n\t\t}\n\t}\n}\n```\n\n### 选择结构if语句格式2\n\n```\n/*\n\tif语句格式2：\n\t\tif(比较表达式) {\n\t\t\t语句体1;\n\t\t}else {\n\t\t\t语句体2;\n\t\t}\n\t执行流程：\n\t\t首先计算比较表达式的值，看其返回值是true还是false。\n\t\t如果是true，就执行语句体1；\n\t\t如果是false，就执行语句体2；\n\t\t\n\t注意：else后面是没有比较表达式的，只有if后面有。\n*/\nclass IfDemo3 {\n\tpublic static void main(String[] args) {\n\t\t//判断两个数据是否相等\n\t\t\n\t\tint a = 10;\n\t\tint b = 20;\n\t\t\n\t\tif(a == b) {\n\t\t\tSystem.out.println(\"a等于b\");\n\t\t}else {\n\t\t\tSystem.out.println(\"a不等于b\");\n\t\t}\n\t}\n}\n```\n\n### 选择结构if语句格式2的练习\n\n```\n/*\n\tif语句格式2的练习：\n\t\tA:获取两个数据中较大的值\n\t\tB:判断一个数据是奇数还是偶数,并输出是奇数还是偶数\n*/\nimport java.util.Scanner;\n\nclass IfTest {\n\tpublic static void main(String[] args) {\n\t\t//创建键盘录入对象\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\t//获取两个数据中较大的值\n\t\tSystem.out.println(\"请输入第一个数据：\");\n\t\tint a = sc.nextInt();\n\t\t\n\t\tSystem.out.println(\"请输入第二个数据：\");\n\t\tint b = sc.nextInt();\n\t\t\n\t\t//定义一个变量接收最大值\n\t\tint max;\n\t\t\n\t\tif(a > b) {\n\t\t\tmax = a;\n\t\t}else {\n\t\t\tmax = b;\n\t\t}\n\t\t\n\t\tSystem.out.println(\"max:\"+max);\n\t\tSystem.out.println(\"----------------\");\n\t\t\n\t\t//判断一个数据是奇数还是偶数\n\t\tSystem.out.println(\"请输入你要判断的数据：\");\n\t\tint x = sc.nextInt();\n\t\t\n\t\tif(x%2 == 0) {\n\t\t\tSystem.out.println(x+\"这个数据是偶数\");\n\t\t}else {\n\t\t\tSystem.out.println(x+\"这个数据是奇数\");\n\t\t}\n\t}\n}\n```\n\n### if语句的格式2和三元的相互转换问题\n\n```\n/*\n\t由于if语句的第二种格式刚才也完成了三元运算符可以完成的效果。\n\t所以，我们就认为他们可以完成一样的操作。\n\t但是，他们就一点区别没有吗?肯定不是。\n\t\n\t区别：\n\t\t三元运算符实现的，都可以采用if语句实现。反之不成立。\n\t\t\n\t\t什么时候if语句实现不能用三元改进呢?\n\t\t\t当if语句控制的操作是一个输出语句的时候就不能。\n\t\t\t为什么呢?因为三元运算符是一个运算符，运算符操作完毕就应该有一个结果，而不是一个输出。\n*/\nclass IfDemo4 {\n\tpublic static void main(String[] args) {\n\t\t//获取两个数据的最大值\n\t\tint a = 10;\n\t\tint b = 20;\n\t\t\n\t\t//用if语句实现\n\t\tint max1;\n\t\tif(a > b) {\n\t\t\tmax1 = a;\n\t\t}else {\n\t\t\tmax1 = b;\n\t\t}\n\t\tSystem.out.println(\"max1:\"+max1);\n\t\t\n\t\t//用三元改进\n\t\tint max2 = (a > b)? a: b;\n\t\tSystem.out.println(\"max2:\"+max2);\n\t\tSystem.out.println(\"----------\");\n\t\t\n\t\t//判断一个数据是奇数还是偶数,并输出是奇数还是偶数\n\t\tint x = 100;\n\t\t\n\t\tif(x%2 == 0) {\n\t\t\tSystem.out.println(\"100是一个偶数\");\n\t\t}else {\n\t\t\tSystem.out.println(\"100是一个奇数\");\n\t\t} \n\t\t\n\t\t//用三元改进\n\t\t//这种改进是错误的。\n\t\t//String s = (x%2 == 0)?System.out.println(\"100是一个偶数\");:System.out.println(\"100是一个奇数\");;\n\t}\n}\n```\n\n### 选择结构if语句格式3\n\n```\n/*\n\tif语句的格式3：\n\t\tif(比较表达式1) {\n\t\t\t语句体1;\n\t\t}else if(比较表达式2) {\n\t\t\t语句体2;\n\t\t}else if(比较表达式3) {\n\t\t\t语句体3;\n\t\t}\n\t\t...\n\t\telse {\n\t\t\t语句体n+1;\n\t\t}\n\t\t\n\t执行流程：\n\t\t首先计算比较表达式1看其返回值是true还是false，\n\t\t如果是true，就执行语句体1，if语句结束。\n\t\t如果是false，接着计算比较表达式2看其返回值是true还是false，\n\t\t\n\t\t如果是true，就执行语句体2，if语句结束。\n\t\t如果是false，接着计算比较表达式3看其返回值是true还是false，\n\t\t...\n\t\t\n\t\t如果都是false，就执行语句体n+1。\n*/\nimport java.util.Scanner;\n\nclass IfDemo5 {\n\tpublic static void main(String[] args) {\n\t\t//需求：键盘录入一个成绩，判断并输出成绩的等级。\n\t\t/*\n\t\t\t90-100 优秀\n\t\t\t80-90  好\n\t\t\t70-80  良\n\t\t\t60-70  及格\n\t\t\t0-60   不及格\n\t\t*/\n\t\t\n\t\t//创建键盘录入对象\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\t//录入数据\n\t\tSystem.out.println(\"请输入你的考试成绩：\");\n\t\tint score = sc.nextInt();\n\t\t\n\t\t/*\n\t\tif(score>=90 && score<=100) {\n\t\t\tSystem.out.println(\"优秀\");\n\t\t}else if(score>=80 && score<90) {\n\t\t\tSystem.out.println(\"好\");\n\t\t}else if(score>=70 && score<80) {\n\t\t\tSystem.out.println(\"良\");\n\t\t}else if(score>=60 && score<70) {\n\t\t\tSystem.out.println(\"及格\");\n\t\t}else {\n\t\t\tSystem.out.println(\"不及格\");\n\t\t}\n\t\t*/\n\t\t//这样写已经满足我的基本要求，但是可能别人在使用的时候，不会按照你要求的数据给出了。\n\t\t//在做一个程序的基本测试的时候，一定要考虑这样的几个问题：\n\t\t//正确数据，错误数据，边界数据。\n\t\t//而我们刚才写的程序并没有处理错误数据，所以这个程序不是很好，要改进\n\t\t/*\n\t\tif(score>=90 && score<=100) {\n\t\t\tSystem.out.println(\"优秀\");\n\t\t}else if(score>=80 && score<90) {\n\t\t\tSystem.out.println(\"好\");\n\t\t}else if(score>=70 && score<80) {\n\t\t\tSystem.out.println(\"良\");\n\t\t}else if(score>=60 && score<70) {\n\t\t\tSystem.out.println(\"及格\");\n\t\t}else if(score>=0 && score<60){\n\t\t\tSystem.out.println(\"不及格\");\n\t\t}else {\n\t\t\tSystem.out.println(\"你输入的成绩有误\");\n\t\t}\n\t\t*/\n\t\t\n\t\t//另一种判断改进\n\t\tif(score<0 || score>100) {\n\t\t\tSystem.out.println(\"你输入的成绩有误\");\n\t\t}else if(score>=90 && score<=100) {\n\t\t\tSystem.out.println(\"优秀\");\n\t\t}else if(score>=80 && score<90) {\n\t\t\tSystem.out.println(\"好\");\n\t\t}else if(score>=70 && score<80) {\n\t\t\tSystem.out.println(\"良\");\n\t\t}else if(score>=60 && score<70) {\n\t\t\tSystem.out.println(\"及格\");\n\t\t}else {\n\t\t\tSystem.out.println(\"不及格\");\n\t\t}\n\t}\n}\n```\n\n### 选择结构if语句格式3的练习\n\n```\n/*\n\t键盘录入月份的值，输出对应的季节。\n\t\n\t春\t3,4,5\n\t夏\t6,7,8\n\t秋\t9,10,11\n\t冬\t12,1,2\n\t\n\t分析：\n\t\tA:键盘录入月份的值，所以我们要使用Scanner。\n\t\tB:我们应该判断这个月份在那个季节，而这个判断情况较多，所以，用if语句格式3。\n\t\t\n\tif语句的使用场景：\n\t\tA:针对表达式是一个boolean类型的判断\n\t\tB:针对一个范围的判断\n*/\nimport java.util.Scanner;\n\nclass IfTest3 {\n\tpublic static void main(String[] args) {\n\t\t//创建键盘录入对象\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\t//录入数据\n\t\tSystem.out.println(\"请你输入一个月份:\");\n\t\tint month = sc.nextInt();\n\t\t\n\t\t//第三种格式实现即可\n\t\tif(month<1 || month>12) {\n\t\t\tSystem.out.println(\"你输入的月份有误\");\n\t\t}else if(month == 1) {\n\t\t\tSystem.out.println(\"冬季\");\n\t\t}else if(month == 2) {\n\t\t\tSystem.out.println(\"冬季\");\n\t\t}else if(month == 3) {\n\t\t\tSystem.out.println(\"春季\");\n\t\t}else if(month == 4) {\n\t\t\tSystem.out.println(\"春季\");\n\t\t}else if(month == 5) {\n\t\t\tSystem.out.println(\"春季\");\n\t\t}else if(month == 6) {\n\t\t\tSystem.out.println(\"夏季\");\n\t\t}else if(month == 7) {\n\t\t\tSystem.out.println(\"夏季\");\n\t\t}else if(month == 8) {\n\t\t\tSystem.out.println(\"夏季\");\n\t\t}else if(month == 9) {\n\t\t\tSystem.out.println(\"秋季\");\n\t\t}else if(month == 10) {\n\t\t\tSystem.out.println(\"秋季\");\n\t\t}else if(month == 11) {\n\t\t\tSystem.out.println(\"秋季\");\n\t\t}else {\n\t\t\tSystem.out.println(\"冬季\");\n\t\t}\n\t\tSystem.out.println(\"--------------\");\n\t\t\n\t\t//这个程序确实是符合了我们的需求，但是就是看起来比较麻烦\n\t\t//那么，我们能不能改进一下呢?\n\t\t//month == 3\n\t\t//month == 4\n\t\t//month == 5\n\t\t//我们发现，上面三个都是春季。\n\t\t//而他们本身每一个都是一个boolean表达式\n\t\t//所以，我们就可以考虑使用逻辑运算符给他们连接起来改进\n\t\tif(month<1 || month>12) {\n\t\t\tSystem.out.println(\"你输入的月份有误\");\n\t\t}else if(month==3 || month==4 || month==5) {\n\t\t\tSystem.out.println(\"春季\");\n\t\t}else if(month==6 || month==7 || month==8) {\n\t\t\tSystem.out.println(\"夏季\");\n\t\t}else if(month==9 || month==10 || month==11) {\n\t\t\tSystem.out.println(\"秋季\");\n\t\t}else {\n\t\t\tSystem.out.println(\"冬季\");\n\t\t}\n\t\tSystem.out.println(\"--------------\");\n\t\t\n\t\t//这个时候，程序代码以及可以了。\n\t\t//但是呢，假如我要求你输入一个月份，判断是上半年还是下半年。\n\t\t//这个时候，我们的判断条件连接就是6个boolean表达式\n\t\t//我们可能还有更多的连接\n\t\t//这个时候，其实我们还有另外的一种改进方案：\n\t\t//month == 3\n\t\t//month == 4\n\t\t//month == 5\n\t\t//month>=3 && month<=5\n\t\t//用范围也是可以改进的。\n\t\tif(month<1 || month>12) {\n\t\t\tSystem.out.println(\"你输入的月份有误\");\n\t\t}else if(month>=3 && month<=5) {\n\t\t\tSystem.out.println(\"春季\");\n\t\t}else if(month>=6 && month<=8) {\n\t\t\tSystem.out.println(\"夏季\");\n\t\t}else if(month>=9 && month<=11) {\n\t\t\tSystem.out.println(\"秋季\");\n\t\t}else {\n\t\t\tSystem.out.println(\"冬季\");\n\t\t}\n\t\tSystem.out.println(\"--------------\");\n\t}\n}\n```\n\n### 选择结构if语句的嵌套使用\n\n```\n/*\n\t获取三个数据中的最大值\n\t\n\t由此案例主要是为了讲解if语句是可以嵌套使用的。而且是可以任意的嵌套。\n*/\nclass IfTest4 {\n\tpublic static void main(String[] args) {\n\t\tint a = 10;\n\t\tint b = 30;\n\t\tint c = 20;\n\t\t\n\t\t//三元实现\n\t\t//int temp = (a>b)? a: b;\n\t\t//int max = (temp>c)? temp: c;\n\t\t//System.out.println(\"max:\"+max);\n\t\t//System.out.println(\"--------\");\n\t\t\n\t\t//用if语句实现\n\t\tint max;\n\t\tif(a > b) {\n\t\t\tif(a > c) {\n\t\t\t\tmax = a;\n\t\t\t}else {\n\t\t\t\tmax = c;\n\t\t\t}\n\t\t}else {\n\t\t\tif(b > c) {\n\t\t\t\tmax = b;\n\t\t\t}else {\n\t\t\t\tmax = c;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"max:\"+max);\n\t}\n}\n```\n","tags":["Java系统学习"],"categories":["Java系统学习-JavaSE篇"]},{"title":"Constructing Roads（POJ-2421）（最小生成树）","url":"/2020/05/12/Constructing Roads（POJ-2421）（最小生成树）/","content":"\nThere are N villages, which are numbered from 1 to N, and you should build some roads such that every two villages can connect to each other. We say two village A and B are connected, if and only if there is a road between A and B, or there exists a village C such that there is a road between A and C, and C and B are connected.\n\n<!--more-->\n\nWe know that there are already some roads between some villages and your job is the build some roads such that all the villages are connect and the length of all the roads built is minimum.\nInput\nThe first line is an integer N (3 <= N <= 100), which is the number of villages. Then come N lines, the i-th of which contains N integers, and the j-th of these N integers is the distance (the distance should be an integer within [1, 1000]) between village i and village j.\n\nThen there is an integer Q (0 <= Q <= N * (N + 1) / 2). Then come Q lines, each line contains two integers a and b (1 <= a < b <= N), which means the road between village a and village b has been built.\nOutput\nYou should output a line contains an integer, which is the length of all the roads to be built such that all the villages are connected, and this value is minimum.\nSample Input\n3\n0 990 692\n\n990 0 179\n\n692 179 0\n\n1\n\n1 2\n\nSample Output\n179\n\n**题意：**\n**要修公路，输入一个n，表示n个村庄。接着输入n*n的矩阵，该图的邻接矩阵，然后输入一个q 接下来的q行，每行包含两个数a，b，表示a、b这条边联通，就是已经有公路不用修了，要让所有村庄联通在一起问：修路最小代价是多少。**\n\n**思路：**\n**这道题的话，根据题目输入构造邻接矩阵，然后把已经联通的村庄的距离设置为0，表示不用在修这条公路。然后用Prim算法即可。**\n\n**AC代码：**\n\n```\n#include <stdio.h>\n#include <string>\n#include <string.h>\n#include <iostream>\n#include <algorithm>\n#include <math.h>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\ntypedef long long ll;\nconst int maxx = 10010;\nconst int mod = 10007;\nconst int inf = 0x3f3f3f3f;\nconst double eps = 1e-8;\nusing namespace std;\nint mapp[maxx][maxx];\nint dis[maxx];\nbool vis[maxx];\nint n;\nvoid Prim()\n{\n    int sum = 0;\n    int now;\n    for (int i = 1; i <= n; i++)\n    {\n        dis[i] = i;\n        vis[i] = false;\n    }\n    for (int i = 1; i <= n; i++)\n        dis[i] = mapp[1][i];\n    dis[1] = 0;\n    vis[1] = true;\n    for (int i = 1; i < n; i++)\n    {\n        now = inf;\n        int minn = inf;\n        for (int j = 1; j <= n; j++)\n        {\n            if (!vis[j] && dis[j] < minn)\n            {\n                now = j;\n                minn = dis[j];\n            }\n        }\n        if(now == inf)\n        break;\n        vis[now] = true;\n        sum += minn;\n        for (int j = 1; j <= n; j++)\n        {\n            if (!vis[j] && dis[j] > mapp[now][j])\n                dis[j] = mapp[now][j];\n        }\n    }\n    printf(\"%d\\n\", sum);\n}\nint main()\n{\n    while (~scanf(\"%d\", &n))\n    {\n        for (int i = 1; i <= n; i++)\n            for (int j = 1; j <= n; j++)\n                scanf(\"%d\", &mapp[i][j]);\n        int q, a, b;\n        scanf(\"%d\", &q);\n        for (int i = 1; i <= q; i++)\n        {\n            scanf(\"%d%d\", &a, &b);\n            mapp[a][b] = mapp[b][a] = 0;\n        }\n        Prim();\n    }\n    return 0;\n}\n```\n","tags":["最小生成树"],"categories":["最小生成树"]},{"title":"QS Network（ZOJ-1586）（最小生成树）","url":"/2020/05/12/QS Network（ZOJ-1586）（最小生成树）/","content":"\nSunny Cup 2003 - Preliminary Round\nApril 20th, 12:00 - 17:00\n\nProblem E: QS Network\n\n<!--more-->\n\nIn the planet w-503 of galaxy cgb, there is a kind of intelligent creature named QS. QScommunicate with each other via networks. If two QS want to get connected, they need to buy two network adapters (one for each QS) and a segment of network cable. Please be advised that ONE NETWORK ADAPTER CAN ONLY BE USED IN A SINGLE CONNECTION.(ie. if a QS want to setup four connections, it needs to buy four adapters). In the procedure of communication, a QS broadcasts its message to all the QS it is connected with, the group of QS who receive the message broadcast the message to all the QS they connected with, the procedure repeats until all the QS's have received the message.\n\nA sample is shown below:\n\n![tupian](https://vj.z180.cn/1120637f03c5c4bc9402775a6100caa8?v=1589071552)\n\nA sample QS network, and QS A want to send a message.\n\nStep 1. QS A sends message to QS B and QS C;\n\nStep 2. QS B sends message to QS A ; QS C sends message to QS A and QS D;\n\nStep 3. the procedure terminates because all the QS received the message.\n\nEach QS has its favorate brand of network adapters and always buys the brand in all of its connections. Also the distance between QS vary. Given the price of each QS's favorate brand of network adapters and the price of cable between each pair of QS, your task is to write a program to determine the minimum cost to setup a QS network.\n\n\nInput\n\nThe 1st line of the input contains an integer t which indicates the number of data sets.\n\nFrom the second line there are t data sets.\n\nIn a single data set,the 1st line contains an interger n which indicates the number of QS.\n\nThe 2nd line contains n integers, indicating the price of each QS's favorate network adapter.\n\nIn the 3rd line to the n+2th line contain a matrix indicating the price of cable between ecah pair of QS.\n\nConstrains:\n\nall the integers in the input are non-negative and not more than 1000.\n\n\nOutput\n\nfor each data set,output the minimum cost in a line. NO extra empty lines needed.\n\n\nSample Input\n\n1\n\n3\n\n10 20 30\n\n0 100 200\n\n100 0 300\n\n200 300 0\n\nSample Output\n\n370\n\n**题意：**\n**第一行给出T，代表有T组数据。每组数据第一行给出N，代表图有N个结点。接着一行给出N个数，代表每个结点的权值（就是接收器的费用），接着N行每行N个数，矩阵的形式给出各点之间边的权值（也就是连接接收器网线的费用）。最后实际权值就是边的权值加上两个点的权值，输出最小生成树的权值总和即可。**\n\n**思路：**\n**这道题的话，因为输入的是矩阵，我们用Prim算法更好一些，套下模板即可。**\n\n**AC代码：**\n\n```\n#include <stdio.h>\n#include <string>\n#include <string.h>\n#include <iostream>\n#include <algorithm>\n#include <math.h>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\ntypedef long long ll;\nconst int maxx = 10010;\nconst int mod = 10007;\nconst int inf = 0x3f3f3f3f;\nconst double eps = 1e-8;\nusing namespace std;\nint mapp[maxx][maxx];\nint dis[maxx];\nint val[maxx];\nbool vis[maxx];\nint n;\nvoid Prim()\n{\n    int sum = 0;\n    int now;\n    for (int i = 1; i <= n; i++)\n    {\n        dis[i] = i;\n        vis[i] = false;\n    }\n    for (int i = 1; i <= n; i++)\n        dis[i] = mapp[1][i];\n    dis[1] = 0;\n    vis[1] = true;\n    for (int i = 1; i < n; i++)\n    {\n        now = inf;\n        int minn = inf;\n        for (int j = 1; j <= n; j++)\n        {\n            if (!vis[j] && dis[j] < minn)\n            {\n                now = j;\n                minn = dis[j];\n            }\n        }\n        if (now == inf)\n            break;\n        vis[now] = true;\n        sum += minn;\n        for (int j = 1; j <= n; j++)\n        {\n            if (!vis[j] && dis[j] > mapp[now][j])\n                dis[j] = mapp[now][j];\n        }\n    }\n    printf(\"%d\\n\", sum);\n}\nint main()\n{\n    int t;\n    scanf(\"%d\", &t);\n    while (t--)\n    {\n        scanf(\"%d\", &n);\n        for (int i = 1; i <= n; i++)\n            scanf(\"%d\", &val[i]);\n        for (int i = 1; i <= n; i++)\n            for (int j = 1; j <= n; j++)\n            {\n                scanf(\"%d\", &mapp[i][j]);\n                mapp[i][j] += val[i] + val[j];\n            }\n        Prim();\n    }\n    return 0;\n}\n```\n","tags":["最小生成树"],"categories":["最小生成树"]},{"title":"再次温习最小生成树的一些思路","url":"/2020/05/12/再次温习最小生成树的一些思路/","content":"\n## 写在前面\n\n因为之前4月份打了将近一个月的个人赛，有些以前学习过的算法已经忘了，所以重新再温习一遍。\n\n<!--more-->\n\n## 关于最小生成树\n\n**最小生成树（minimum spanning tree）是由n个顶点，n-1条边，将一个连通图连接起来，且使权值最小的结构。\n最小生成树可以用Prim（普里姆）算法或kruskal（克鲁斯卡尔）算法求出。**\n\n## Kruskal算法详解及模板与例题\n\n### Kruskal算法简介\n\n**Kruskal算法是基于并查集算法而进行的，很简单的思路就是，对一张图，将所有的边都拆出来，然后对每条边的边权进行排序（从大到小，从小到大看题目需要），然后再将边连回去，连边的时候判断两个点是否被连通了，如果是连通的，那么就将该边扔了再看下一条边，如果没有被连通，那么就将该条边连上，然后用并查集合并即可。**\n\n**时间复杂度：O（NlogN）（N为边数）\nkruskal算法又称“加边法”，用于边数较少的稀疏图\n方法：每次找图中权值最小的边，将边连接的两个顶点加入最小生成树集合中\n注意：相同权值任选其中一个即可，但是不允许出现闭合回路的情况。**\n\n### Kruskal算法图解\n\n![tupian1](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwODIwMTE1NjM2MTE3?x-oss-process=image/format,png)\n\n![tupian2](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwODIwMTE1NjQ2MzA4?x-oss-process=image/format,png)\n\n![tupian3](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwODIwMTE1NjU4MzI0?x-oss-process=image/format,png)\n\n![tupian4](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwODIwMTE1NzExODQ1?x-oss-process=image/format,png)\n\n![tupian5](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwODIwMTE1NzIzMTg5?x-oss-process=image/format,png)\n\n![tupian6](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwODIwMTE1NzMyNjMy?x-oss-process=image/format,png)\n\n### Kruskal算法代码详解及模板\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxx = 200010;\nconst int inf = 0x3f3f3f3f;\nusing namespace std;\nint pre[maxx];\nint n;\nstruct node//存边权值\n{\n    int s;\n    int e;\n    int v;\n} edge[maxx];\nbool cmp(node a, node b)//看情况修改 优先级给小边权还是大边权\n{\n    return a.v < b.v;\n}\nvoid init()//初始化\n{\n    for (int i = 0; i <= n; i++)\n        pre[i] = i;\n}\nint getf(int a)//并查集 看两点是否在同一个图内\n{\n    if (pre[a] == a)\n        return a;\n    int tmp = getf(pre[a]);\n    return pre[a] = tmp;\n}\nint Kruskal(int a, int b) //并查集合并操作，看是否在同一个图内 如果在就跳过 不在就合并\n{\n    int fa = getf(a);\n    int fb = getf(b);\n    if (fa != fb)\n    {\n        pre[fa] = fb;\n        return 1;\n    }\n    else\n        return 0;\n}\nint main()\n{\n    while (~scanf(\"%d\", &n), n)\n    {\n        init();\n        int m = (n * (n - 1)) / 2;\n        for (int i = 1; i <= m; i++)\n            scanf(\"%d%d%d\", &edge[i].s, &edge[i].e, &edge[i].v);\n        sort(edge + 1, edge + m + 1, cmp);\n        int ans = 0;\n        for (int i = 1; i <= m; i++)\n        {\n            if (Kruskal(edge[i].s, edge[i].e))\n                ans += edge[i].v;\n        }\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}\n```\n\n### Kruskal算法例题\n\n**例题一：POJ-1287**\n\n```\n#include <stdio.h>\n#include <string>\n#include <string.h>\n#include <iostream>\n#include <algorithm>\n#include <math.h>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\ntypedef long long ll;\nconst int maxx = 10010;\nconst int mod = 10007;\nconst int inf = 0x3f3f3f3f;\nconst double eps = 1e-8;\nusing namespace std;\nstruct node\n{\n    int s;\n    int e;\n    int v;\n} edge[maxx];\nbool cmp(node a, node b)\n{\n    return a.v < b.v;\n}\nint pre[maxx];\nint n, r;\nvoid init()\n{\n    for (int i = 0; i <= n; i++)\n        pre[i] = i;\n}\nint getf(int a)\n{\n    if (pre[a] == a)\n        return a;\n    int tmp = getf(pre[a]);\n    return pre[a] = tmp;\n}\nint Kruskal(int a, int b)\n{\n    int fa = getf(a);\n    int fb = getf(b);\n    if (fa != fb)\n    {\n        pre[fa] = fb;\n        return 1;\n    }\n    else\n        return 0;\n}\nint main()\n{\n    while (~scanf(\"%d%d\", &n, &r), n)\n    {\n        init();\n        for (int i = 1; i <= r; i++)\n            scanf(\"%d%d%d\", &edge[i].s, &edge[i].e, &edge[i].v);\n        sort(edge + 1, edge + r + 1, cmp);\n        int ans = 0;\n        for (int i = 1; i <= r; i++)\n        {\n            if (Kruskal(edge[i].s, edge[i].e))\n                ans += edge[i].v;\n        }\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}\n```\n\n## Prim算法详解及模板与例题\n\n### Prim算法简介\n\n**时间复杂度：O（N^2）（N为顶点数）\nprim算法又称“加点法”，用于边数较多的带权无向连通图\n方法：每次找与之连线权值最小的顶点，将该点加入最小生成树集合中\n注意：相同权值任选其中一个即可，但是不允许出现闭合回路的情况。**\n\n### Prim算法图解\n\n![tupian1](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwODIwMTEzODU0ODA3?x-oss-process=image/format,png)\n\n![tupian2](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwODIwMTEzOTA1MTQ0?x-oss-process=image/format,png)\n\n![tupian3](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwODIwMTEzOTEzODk1?x-oss-process=image/format,png)\n\n![tupian4](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwODIwMTEzOTIxMDQ3?x-oss-process=image/format,png)\n\n![tupian5](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwODIwMTEzOTI5Mjcz?x-oss-process=image/format,png)\n\n![tupian6](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwODIwMTEzOTM4NDI0?x-oss-process=image/format,png)\n\n![tupian7](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwODIwMTEzOTQ2MTQx?x-oss-process=image/format,png)\n\n### Prim算法代码详解及模板\n\n```\n#include <stdio.h>\n#include <string>\n#include <string.h>\n#include <iostream>\n#include <algorithm>\n#include <math.h>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\ntypedef long long ll;\nconst int maxx = 210;\nconst int mod = 10007;\nconst int inf = 0x3f3f3f3f;\nconst double eps = 1e-8;\nusing namespace std;\nint mapp[maxx][maxx]; //存图\nint dis[maxx];        //记录任意一点到这个点的最近距离\nbool vis[maxx];       //用来标记0和1  表示这个点是否被选择过\nint n;\nvoid Prim()\n{\n    int sum = 0;\n    int now;\n    for (int i = 1; i <= n; i++) //初始化\n    {\n        dis[i] = inf;\n        vis[i] = false;\n    }\n    for (int i = 1; i <= n; i++) //选择1为起始点，初始化\n        dis[i] = mapp[1][i];\n    dis[1] = 0;                 //起点的上一个节点没有节点，所以为0\n    vis[1] = true;              //定义起点已经加入了最小生成树\n    for (int i = 1; i < n; i++) //循环找最小边，循环n-1次\n    {\n        now = inf;\n        int minn = inf;\n        for (int j = 1; j <= n; j++) //找dis最小的节点并加入最小生成树\n        {\n            if (!vis[j] && dis[j] < minn)\n            {\n                now = j;//找出最小的顶点\n                minn = dis[j];//找出权值最短的路径长度\n            }\n        }\n        if (now == inf)\n            break; //防止不成图\n        vis[now] = true;\n        sum += minn;//求和\n        for (int j = 1; j <= n; j++) //添入新点后更新最小距离\n        {\n            if (!vis[j] && dis[j] > mapp[now][j])\n                dis[j] = mapp[now][j];\n        }\n    }\n    printf(\"%d\\n\", sum);\n}\nint main()\n{\n    while (~scanf(\"%d\", &n), n)\n    {\n        for (int i = 1; i <= n; i++) //初始化邻接矩阵\n            for (int j = 1; j <= n; j++)\n            {\n                if (i == j)\n                    mapp[i][j] = 0;\n                else\n                    mapp[i][j] = inf;\n            }\n        int a,b,c;\n        for (int i = 1; i < n; i++)\n        {\n            scanf(\"%d%d%d\",&a,&b,&c);\n            mapp[a][b] = mapp[b][a] = c;\n        }\n        Prim();\n    }\n    return 0;\n}\n```\n\n### Prim算法例题\n\n**例题一：POJ-1251**\n\n```\n#include <stdio.h>\n#include <string>\n#include <string.h>\n#include <iostream>\n#include <algorithm>\n#include <math.h>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\ntypedef long long ll;\nconst int maxx = 210;\nconst int mod = 10007;\nconst int inf = 0x3f3f3f3f;\nconst double eps = 1e-8;\nusing namespace std;\nint mapp[maxx][maxx];\nint dis[maxx];\nbool vis[maxx];\nint n;\nvoid Prim()\n{\n    int sum = 0;\n    int now;\n    for (int i = 1; i <= n; i++)\n    {\n        dis[i] = inf;\n        vis[i] = false;\n    }\n    for (int i = 1; i <= n; i++)\n        dis[i] = mapp[1][i];\n    dis[1] = 0;\n    vis[1] = true;\n    for (int i = 1; i < n; i++)\n    {\n        now = inf;\n        int minn = inf;\n        for (int j = 1; j <= n; j++)\n        {\n            if (!vis[j] && dis[j] < minn)\n            {\n                now = j;\n                minn = dis[j];\n            }\n        }\n        if (now == inf)\n            break;\n        vis[now] = true;\n        sum += minn;\n        for (int j = 1; j <= n; j++)\n        {\n            if (!vis[j] && dis[j] > mapp[now][j])\n                dis[j] = mapp[now][j];\n        }\n    }\n    printf(\"%d\\n\", sum);\n}\nint main()\n{\n    char a, b;\n    int num1, num2;\n    int x, y;\n    while (~scanf(\"%d\", &n), n)\n    {\n        for (int i = 1; i <= n; i++)\n            for (int j = 1; j <= n; j++)\n            {\n                if (i == j)\n                    mapp[i][j] = 0;\n                else\n                    mapp[i][j] = inf;\n            }\n\n        for (int i = 1; i < n; i++)\n        {\n            cin >> a >> num1;\n            for (int j = 1; j <= num1; j++)\n            {\n                cin >> b >> num2;\n                x = a - 64;\n                y = b - 64;\n                mapp[x][y] = mapp[y][x] = num2;\n            }\n        }\n        Prim();\n    }\n    return 0;\n}\n```\n\n**例题二：Hihocoder-1097**\n\n```\n#include <stdio.h>\n#include <string>\n#include <string.h>\n#include <iostream>\n#include <algorithm>\n#include <math.h>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\ntypedef long long ll;\nconst int maxx = 10010;\nconst int mod = 10007;\nconst int inf = 0x3f3f3f3f;\nconst double eps = 1e-8;\nusing namespace std;\nint mapp[maxx][maxx];\nint dis[maxx];\nbool vis[maxx];\nint n;\nvoid Prim()\n{\n    int sum = 0;\n    int now;\n    for (int i = 1; i <= n; i++)\n    {\n        dis[i] = inf;\n        vis[i] = false;\n    }\n    for (int i = 1; i <= n; i++)\n        dis[i] = mapp[1][i];\n    dis[1] = 0;\n    vis[1] = true;\n    for (int i = 1; i < n; i++)\n    {\n        now = inf;\n        int minn = inf;\n        for (int j = 1; j <= n; j++)\n        {\n            if (!vis[j] && dis[j] < minn)\n            {\n                now = j;\n                minn = dis[j];\n            }\n        }\n        if (now == inf)\n            break;\n        vis[now] = true;\n        sum += minn;\n        for (int j = 1; j <= n; j++)\n        {\n            if (!vis[j] && dis[j] > mapp[now][j])\n                dis[j] = mapp[now][j];\n        }\n    }\n    printf(\"%d\\n\", sum);\n}\nint main()\n{\n    while (~scanf(\"%d\", &n))\n    {\n        for (int i = 1; i <= n; i++)\n            for (int j = 1; j <= n; j++)\n            {\n                if (i == j)\n                    mapp[i][j] = 0;\n                else\n                    mapp[i][j] = inf;\n            }\n        int a;\n        for (int i = 1; i <= n; i++)\n            for (int j = 1; j <= n; j++)\n            {\n                scanf(\"%d\", &a);\n                if (a < mapp[i][j])\n                    mapp[i][j] = mapp[j][i] = a;\n            }\n        Prim();\n    }\n    return 0;\n}\n```\n","tags":["最小生成树再温"],"categories":["算法重温"]},{"title":"Codeforces 625(Div.2)","url":"/2020/05/11/Codeforces 625(Div.2)/","content":"\n**A题**\n\n题意：输入两组数，为1表示有该任务，0表示没有，现在由你定义每个任务的分数，使得最高分最小的情况下，第一个人的总分大于第二个人，如果无法满足，输出-1。\n\n<!--more-->\n\n思路：这道题的话，先处理两个人的特有任务，如果第一个人特有的任务第二个人都有，那么一定无法满足，因为两个人任务的分数是相同的，第二个人特有的任务按照题目要求，应当为1分，第一个人的特有任务，按照第二个人特有任务的数量，平均分配即可。\n\nAC代码：\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxx = 100010;\nconst int inf = 0x3f3f3f3f;\nusing namespace std;\nint a[maxx];\nint b[maxx];\nint main()\n{\n    int n;\n    while (cin >> n)\n    {\n        for (int i = 1; i <= n; i++)\n            cin >> a[i];\n        for (int i = 1; i <= n; i++)\n            cin >> b[i];\n        int ans1 = 0, ans2 = 0;\n        for (int i = 1; i <= n; i++)\n        {\n            if (a[i] + b[i] == 1)\n            {\n                ans1 += a[i];\n                ans2 += b[i];\n            }\n        }\n        if (ans1 == 0)\n            cout << \"-1\" << endl;\n        else\n            cout << (ans1 + ans2) / ans1 << endl;\n    }\n    return 0;\n}\n```\n\n**B题**\n\n题意 ：有n个数，对于Ai和Aj这两个数，如果满足Ai-Aj=i-j，那么两个数就可以求和，输出整个数组能够求和的最大值。\n\n思路：这道题的话，因为每个城市有beauty值b，可以相互连通的城市i和j之间 i-j==b[i]-b[j]，所以i-b[i]==j-b[j]，所以可以连通的所有城市i-b[i]都是相等的，所以我们记录可以给到每一个差值的beauty值之和再取max就可以了。\n\nAC代码：\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxx = 200010;\nconst int inf = 0x3f3f3f3f;\nusing namespace std;\nunordered_map<ll, ll> mp;\nint main()\n{\n    int n;\n    cin >> n;\n    ll a;\n    ll ans = -1;\n    for (ll i = 1; i <= n; i++)\n    {\n        cin >> a;\n        mp[a - i] += a;\n        ans = max(ans, mp[a - i]);\n    }\n    cout << ans << endl;\n    return 0;\n}\n```\n\n**C题**\n\n题意：一个字符串，如果与某个位置相邻的字母，至少有一个比该位置的字母小1，那么该位置的字母就可以删掉，剩下的字母接上来，输出对于整个字符串，最多可以删多少个字母。\n\n思路：这道题的话，直接暴力，不难想到先删字母大的，然后再删小的可以保证删的最多，所以就从 'z' 遍历到 'a'， 一个一个删，当前字母不能删就往前循环。\n\nAC代码：\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxx = 200010;\nconst int inf = 0x3f3f3f3f;\nusing namespace std;\nstring s;\nint main()\n{\n    int n;\n    while (cin >> n >> s)\n    {\n        for (char i = 'z'; i >= 'b'; i--)\n        {\n            if (s.size() == 1)\n                break;\n            while (1)\n            {\n                if (s.size() == 1)\n                    break;\n                int flag = 1;\n                for (int j = 0; j < s.size(); j++)\n                {\n                    if (s[j] != i)\n                        continue;\n                    if (j == 0)\n                    {\n                        if (s[j + 1] == i - 1)\n                        {\n                            flag = 0;\n                            s.erase(s.begin() + j, s.begin() + j + 1);\n                            break;\n                        }\n                    }\n                    else if (j == s.size() - 1)\n                    {\n                        if (s[j - 1] == i - 1)\n                        {\n                            flag = 0;\n                            s.erase(s.begin() + j, s.begin() + j + 1);\n                            break;\n                        }\n                    }\n                    else\n                    {\n                        if (s[j - 1] == i - 1 || s[j + 1] == i - 1)\n                        {\n                            flag = 0;\n                            s.erase(s.begin() + j, s.begin() + j + 1);\n                            break;\n                        }\n                    }\n                }\n                if (flag)\n                    break;\n            }\n        }\n        cout << n - s.size() << endl;\n    }\n    return 0;\n}\n```\n","tags":["CF"],"categories":["CF"]},{"title":"再次温习并查集的一些思路","url":"/2020/05/08/再次温习并查集的一些思路/","content":"\n## 写在前面\n\n因为之前4月份打了将近一个月的个人赛，有些以前学习过的算法已经忘了，所以重新再温习一遍。\n\n<!--more-->\n\n## 普通并查集\n\n**并查集（Union Find）是一种树型的数据结构，用于处理一些不相交集合（Disjoint Sets）的合并及查询问题。在一些有N个元素的集合应用问题中，我们通常是在开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中。**\n\n**对于并查集的理解**\n\n首先并查集是一种树型结构，树型结构，顾名思义就是存在着子节点和父节点。\n\n所以我们先设一个数组pre[]，这个数组里面存放每个元素的父节点。然后这里借鉴大佬的例子来解释并查集的作用。\n\n例：话说江湖上散落着各式各样的大侠，有上千个之多。他们没有什么正当职业，整天背着剑在外面走来走去，碰到和自己不是一路人的，就免不了要打一架。但大侠们有一个优点就是讲义气，绝对不打自己的朋友。而且他们信奉“朋友的朋友就是我的朋友”，只要是能通过朋友关系串联起来的，不管拐了多少个弯，都认为是自己人。这样一来，江湖上就形成了一个一个的帮派，通过两两之间的朋友关系串联起来。而不在同一个帮派的人，无论如何都无法通过朋友关系连起来，于是就可以放心往死了打。但是两个原本互不相识的人，如何判断是否属于一个朋友圈呢？\n\n我们可以在每个朋友圈内推举出一个比较有名望的人，作为该圈子的代表人物。这样，每个圈子就可以这样命名“中国同胞队”美国同胞队”……两人只要互相对一下自己的队长是不是同一个人，就可以确定敌友关系了。\n\n但是还有问题啊，大侠们只知道自己直接的朋友是谁，很多人压根就不认识队长要判断自己的队长是谁，只能漫无目的的通过朋友的朋友关系问下去：“你是不是队长？你是不是队长？”这样，想打一架得先问个几十年，饿都饿死了，受不了。这样一来，队长面子上也挂不住了，不仅效率太低，还有可能陷入无限循环中。于是队长下令，重新组队。队内所有人实行分等级制度，形成树状结构，我队长就是根节点，下面分别是二级队员、三级队员。每个人只要记住自己的上级是谁就行了。遇到判断敌友的时候，只要一层层向上问，直到最高层，就可以在短时间内确定队长是谁了。由于我们关心的只是两个人之间是否是一个帮派的，至于他们是如何通过朋友关系相关联的，以及每个圈子内部的结构是怎样的，甚至队长是谁，都不重要了。所以我们可以放任队长随意重新组队，只要不搞错敌友关系就好了。于是，门派产生了。\n\n![bcj](https://img-blog.csdnimg.cn/20190301210948491.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg0NjEzOQ==,size_16,color_FFFFFF,t_70)\n\n下面我们来看并查集的实现。 int pre[1000]; 这个数组，记录了每个大侠的上级是谁。大侠们从1或者0开始编号（依据题意而定），pre[15]=3就表示15号大侠的上级是3号大侠。如果一个人的上级就是他自己，那说明他就是掌门人了，查找到此为止。也有孤家寡人自成一派的，比如欧阳锋，那么他的上级就是他自己。每个人都只认自己的上级。比如胡青牛同学只知道自己的上级是杨左使。张无忌是谁？不认识！要想知道自己的掌门是谁，只能一级级查上去。\ngetf这个函数就是找掌门用的，意义再清楚不过了（路径压缩算法先不论，后面再说）。\n\n```\nint getf(int a)//查找根节点\n{\n    if (pre[a] == a)//我的上级不是掌门\n        return a;\n    int tmp = getf(pre[a]);//我就找他的上级，直到掌门出现\n    return pre[a] = tmp;//掌门出现\n}\n```\n\n再来看看mer函数，就是在两个点之间连一条线，这样一来，原先它们所在的两个板块的所有点就都可以互通了。这在图上很好办，画条线就行了。但我们现在是用并查集来描述武林中的状况的，一共只有一个pre[]数组，该如何实现呢？ 还是举江湖的例子，假设现在武林中的形势如图所示。虚竹帅锅与周芷若MM是我非常喜欢的两个人物，他们的终极boss分别是玄慈方丈和灭绝师太，那明显就是两个阵营了。我不希望他们互相打架，就对他俩说：“你们两位拉拉勾，做好朋友吧。”他们看在我的面子上，同意了。这一同意可非同小可，整个少林和峨眉派的人就不能打架了。这么重大的变化，可如何实现呀，要改动多少地方？其实非常简单，我对玄慈方丈说：“大师，麻烦你把你的上级改为灭绝师太吧。这样一来，两派原先的所有人员的终极boss都是师太，那还打个球啊！反正我们关心的只是连通性，门派内部的结构不要紧的。”玄慈一听肯定火大了：“我靠，凭什么是我变成她手下呀，怎么不反过来？我抗议！”于是，两人相约一战，杀的是天昏地暗，风云为之变色啊，但是啊，这场战争终究会有胜负，胜者为王。弱者就被吞并了。反正谁加入谁效果是一样的，门派就由两个变成一个了。这段函数的意思明白了吧？\n\n```\nvoid mer(int a, int b)//虚竹和周芷若做朋友\n{\n    int fa = getf(a);//我老大是玄慈\n    int fb = getf(b);//我老大是灭绝\n    if (fa != fb)\n        pre[fa] = fb;//打一仗，谁赢就当对方老大\n}\n```\n\n再来看看路径压缩算法。建立门派的过程是用mer函数两个人两个人地连接起来的，谁当谁的手下完全随机。最后的树状结构会变成什么样，我也无法预知，一字长蛇阵也有可能。这样查找的效率就会比较低下。最理想的情况就是所有人的直接上级都是掌门，一共就两级结构，只要找一次就找到掌门了。哪怕不能完全做到，也最好尽量接近。这样就产生了路径压缩算法。\n设想这样一个场景：两个互不相识的大侠碰面了，想知道能不能干一场。 于是赶紧打电话问自己的上级：“你是不是掌门？” 上级说：“我不是呀，我的上级是谁谁谁，你问问他看看。” 一路问下去，原来两人的最终boss都是东厂曹公公。 “哎呀呀，原来是自己人，有礼有礼，在下三营六组白面葫芦娃!” “幸会幸会，在下九营十八组仙子狗尾巴花！” 两人高高兴兴地手拉手喝酒去了。 “等等等等，两位大侠请留步，还有事情没完成呢！”我叫住他俩。 “哦，对了，还要做路径压缩。”两人醒悟。 白面葫芦娃打电话给他的上级六组长：“组长啊，我查过了，其实偶们的掌门是曹公公。不如偶们一起结拜在曹公公手下吧，省得级别太低，以后查找掌门麻烦。” “唔，有道理。” 白面葫芦娃接着打电话给刚才拜访过的三营长……仙子狗尾巴花也做了同样的事情。 这样，查询中所有涉及到的人物都聚集在曹公公的直接领导下。每次查询都做了优化处理，所以整个门派树的层数都会维持在比较低的水平上。路径压缩的代码，看得懂很好，看不懂可以自己模拟一下，很简单的一个递归而已。总之它所实现的功能就是这么个意思。\n\n![aa](https://img-blog.csdnimg.cn/20190301211224963.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg0NjEzOQ==,size_16,color_FFFFFF,t_70)\n\n```\nint tmp = getf(pre[a]);//路径压缩\n    return pre[a] = tmp;\n```\n\n**要实现这个例子的代码：**\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxx = 10010;\nconst int inf = 0x3f3f3f3f;\nusing namespace std;\nint pre[maxx];\nint n, m, ans;\nvoid init()\n{\n    for (int i = 0; i <= n; i++)\n        pre[i] = i;\n}\nint getf(int a)\n{\n    if (a == pre[a])\n        return a;\n    return pre[a] = getf(pre[a]);\n}\nint mer(int a, int b)\n{\n    int fa = getf(a);\n    int fb = getf(b);\n    if (fa != fb)\n    {\n        pre[fa] = fb;\n        ans--;\n    }\n}\nint main()\n{\n    while (~scanf(\"%d%d\", &n, &m), n)\n    {\n        init();\n        int a, b;\n        ans = n - 1;\n        for (int i = 0; i < m; i++)\n        {\n            scanf(\"%d%d\", &a, &b);\n            mer(a, b);\n        }\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}\n```\n\n## 带权并查集\n\n**就像名字一样，带权并查集就是要多维护一个权值数组;和普通的并查集大同小异,用pre[]数组存父节点，v存当前结点到父亲结点的权值。**\n\n首先是初始化：\n\n```\nvoid init()\n{\n    for (int i = 0; i <= n; i++)\n    {\n        pre[i] = i;\n        v[i] = 0;\n    }\n}\n```\n\n![tu](https://img-blog.csdnimg.cn/20191012205623707.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MDc3NDU1,size_16,color_FFFFFF,t_70)\n\n没有进行状态压缩的时候可以知道，pre[3]=2,pre[2]=1,pre[1]=1;v[3]=4;v[2]=3;v[1]=0;\n\n![tu](https://img-blog.csdnimg.cn/20191012205953664.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MDc3NDU1,size_16,color_FFFFFF,t_70)\n\n状态压缩后，pre[3]=1;v[3]=7;其他不变;所以可以得出代码如下\n\n```\nint getf(int a)\n{\n    if(pre[a]==a)\n        return a;\n    int tmp=getf(pre[a]);  //这里不能够没有，因为在递归的过程中pre[a]的值会被改变，会影响v[a]的更新\n    v[a]=v[a]+v[pre[a]];\n    return pre[a]=tmp;\n}\n```\n\n而对于合并两个集合，是将元素间关系看成向量\n我们可以列出向量图:\n\n![tu](https://img-blog.csdnimg.cn/20191012211424881.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MDc3NDU1,size_16,color_FFFFFF,t_70)\n\n我们假设上图中2->1表示1比2大3，同理得其他的，一开始1，2处于一个集合,3,处于另一个集合，现在要将这两个集合合并,那么1->4得权值就可以得出，根据平行四边形法则,v[1]=(-v[2]+v+v[3])=8(其中v表示3比2大多少有，也就是2->3)，就是说4比1大8，由此我们便得到了如何将两个带权集合合并。\n\n```\nvoid mer(int a, int b, int s)\n{\n    int fa = getf(a);\n    int fb = getf(b);\n    if (fa != fb)\n    {\n        pre[fa] = fb;\n        v[fa] = -v[a] + s + v[b];\n    }\n}\n```\n\n**例题一：HihoCoder-1515**\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxx = 100010;\nconst int inf = 0x3f3f3f3f;\nusing namespace std;\nint pre[maxx], v[maxx];\nint n, m, q;\nint x, y, s;\nint ans;\nvoid init()\n{\n    for (int i = 0; i <= n; i++)\n    {\n        pre[i] = i;\n        v[i] = 0;\n    }\n}\nint getf(int a)\n{\n    if (pre[a] == a)\n        return a;\n    int tmp = getf(pre[a]);\n    v[a] = v[a] + v[pre[a]];\n    return pre[a] = tmp;\n}\nvoid mer(int a, int b, int s)\n{\n    int fa = getf(a);\n    int fb = getf(b);\n    if (fa != fb)\n    {\n        pre[fa] = fb;\n        v[fa] = -v[a] + s + v[b];\n    }\n}\ntemplate <class T>\ninline void read(T &res) //快速读入模板\n{\n    char c;\n    T flag = 1;\n    while ((c = getchar()) < '0' || c > '9')\n        if (c == '-')\n            flag = -1;\n    res = c - '0';\n    while ((c = getchar()) >= '0' && c <= '9')\n        res = res * 10 + c - '0';\n    res *= flag;\n}\nint main()\n{\n    read(n), read(m), read(q);\n    init();\n    while (m--)\n    {\n        read(x), read(y), read(s);\n        mer(x, y, s);\n    }\n    while (q--)\n    {\n        read(x), read(y);\n        if (getf(x) == getf(y))\n            printf(\"%d\\n\", v[x] - v[y]);\n        else\n            printf(\"-1\\n\");\n    }\n    return 0;\n}\n```\n\n**例题二：HDU-3038**\n\n```\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int maxx = 200010;\nconst int inf = 0x3f3f3f3f;\nusing namespace std;\nint pre[maxx], v[maxx];\nint n, m;\nint x, y, s;\nvoid init()\n{\n    for (int i = 0; i <= n; i++)\n    {\n        pre[i] = i;\n        v[i] = 0;\n    }\n}\nint getf(int a)\n{\n    if (pre[a] == a)\n        return a;\n    int tmp = getf(pre[a]);\n    v[a] = v[a] + v[pre[a]];\n    return pre[a] = tmp;\n}\nint mer(int a, int b, int s)\n{\n    int fa = getf(a);\n    int fb = getf(b);\n    if (fa == fb)\n        return v[a] != v[b] + s;\n    else\n    {\n        pre[fa] = fb;\n        v[fa] = -v[a] + v[b] + s;\n        return 0;\n    }\n}\nint main()\n{\n    while (~scanf(\"%d%d\", &n, &m))\n    {\n        init();\n        int ans = 0;\n        while (m--)\n        {\n            scanf(\"%d%d%d\", &x, &y, &s);\n            y++;\n            if (mer(x, y, s))\n                ans++;\n        }\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}\n```\n\n## 种类并查集\n\n**种类并查集，顾名思义，在所给数据中或多或少会带有种类的区别。**\n\n种类并查集延用了带权并查集的特性,还是相当于维护了一个权值，只不过这个权值带有一定的意义，拿例题“食物链”来说，我们指定x->y表示与y是x的父节点，即pre[x]=y;我们用rela[i]来表示节点i和它的父节点之间的关系，规定rela[x]=0表示x,y是同类，rela[x]=1表示y吃x，rela[x]=2表示x吃y，那么我们可以根据这些权值推断出两个结点之间实际的关系。\n\n![tu](https://img-blog.csdnimg.cn/20191022194850194.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MDc3NDU1,size_16,color_FFFFFF,t_70)\n\n比如现在告诉你3->1的值为1（1吃3），而2->1的值为2（2吃1），那么我们根据题意就可以得出3吃2，即2->3为1,也就得到了上图的关系。假设现在再来一句话说2吃3那么就是错的。问题是如何得到这样的关系。对于给定的x,y和它们之间的关系,我们分两种情况\n1.假设pre[x]==pre[y]，就是说它们是一个集合的，现在的任务就是把它们推出它们之间的关系，也就是上图的情况，1为父节点，先开始的条件有3->1的为1,2->1=2，如何得到2->3=1呢？同样我们可以用向量的方法：2->3=2->1 - 1->3(添负号，箭头反向)=2-1=1；这样我们得到了2->3的值为1（这里在想一下，如果我们想得到假设之前我们已经建立了2->1的关系，现在又给出2->1的关系，如何得到到给出的关系对不对呢；我们只需要把上图的3换成1就可以了，同时3->1=1就变成了1->1=0同样的方法）\n2.假设pre[x]!=pre[y]，x,y不在同一个集合也就是要联合x,y两个集合,已知y->x=1,x->fx=1,y->fy=0\n\n![tu](https://img-blog.csdnimg.cn/20191022200751469.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MDc3NDU1,size_16,color_FFFFFF,t_70)\n\n同样的用向量就可以了fy->fx=-(y->fy)+y->x+x->fx=1+1=2;(已知fx吃x，x吃y，y和fy是同类，所以由题意可知fy吃fx),这样我们就可以将两个集合联合在一起并且维护好关系。\n值得注意的是，这些操作对向量方向的要求很高，不能弄错方向，比如联合两个集合的时候,我们求的是fy->fx，也就是fy是儿子，fx是父亲,那么我们就应该pre[fy]=fx；而不是pre[fx]=fy;同样我们求的关系是rela[fy]的值，而不是rela[fx]，如果箭头反向，这些操作都要变.\n\n**给出食物链这题的代码(POJ-1182)：**\n\n```\n#include <stdio.h>\n#include <string>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <map>\ntypedef long long ll;\nconst int maxx = 100010;\nconst int inf = 0x3f3f3f3f;\nusing namespace std;\nint pre[maxx], rela[maxx];\nint n, k;\nvoid init()\n{\n    for (int i = 0; i <= n; i++)\n    {\n        pre[i] = i;\n        rela[i] = 0;\n    }\n}\nint getf(int a)\n{\n    if (pre[a] == a)\n        return a;\n    int tmp = getf(pre[a]);\n    rela[a] = (rela[a] + rela[pre[a]] + 3) % 3;\n    return pre[a] = tmp;\n}\nint mer(int c, int a, int b)\n{\n    int fa = getf(a);\n    int fb = getf(b);\n    if (fa == fb)\n    {\n        if (c == 1 && rela[a] == rela[b])\n            return 1;\n        else if (c == 2 && (rela[a] - rela[b] + 3) % 3 == c - 1)\n            return 1;\n        else\n            return 0;\n    }\n    else\n    {\n        pre[fb] = fa;\n        rela[fb] = (-rela[b] + rela[a] - c + 1 + 3) % 3;\n        return 1;\n    }\n}\nint main()\n{\n    scanf(\"%d%d\", &n, &k);\n    init();\n    int d, x, y;\n    int sum = 0;\n    while (k--)\n    {\n        scanf(\"%d%d%d\", &d, &x, &y);\n        if (x > n || y > n)\n            sum++;\n        else if (d == 2 && x == y)\n            sum++;\n        else\n        {\n            if (!mer(d, x, y))\n                sum++;\n        }\n    }\n    printf(\"%d\\n\", sum);\n    return 0;\n}\n```\n\n**例题二：POJ-1703**\n\n```\n#include <stdio.h>\n#include <string>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <map>\ntypedef long long ll;\nconst int maxx = 100010;\nconst int inf = 0x3f3f3f3f;\nusing namespace std;\nint pre[maxx * 2];\nint n, m;\nvoid init()\n{\n    for (int i = 0; i <= 2 * n; i++)\n    {\n        pre[i] = i;\n    }\n}\nint getf(int a)\n{\n    if (pre[a] == a)\n        return a;\n    int tmp = getf(pre[a]);\n    return pre[a] = tmp;\n}\nvoid mer(int a, int b)\n{\n    int fa = getf(a);\n    int fb = getf(b);\n    if (fa != fb)\n        pre[fa] = fb;\n}\nint same(int a, int b)\n{\n    return getf(a) == getf(b);\n}\nint main()\n{\n    int t;\n    scanf(\"%d\", &t);\n    while (t--)\n    {\n        scanf(\"%d%d\", &n, &m);\n        init();\n        char s;\n        int a, b;\n        while (m--)\n        {\n            getchar();\n            scanf(\"%c%d%d\", &s, &a, &b);\n            if (s == 'D')\n            {\n                mer(a, b + n);\n                mer(b, a + n);\n            }\n            else\n            {\n                if (same(a, b))\n                {\n                    printf(\"In the same gang.\\n\");\n                    continue;\n                }\n                else if (same(a, b + n))\n                {\n                    printf(\"In different gangs.\\n\");\n                }\n                else\n                {\n                    printf(\"Not sure yet.\\n\");\n                }\n            }\n        }\n    }\n    return 0;\n}\n```\n","tags":["并查集再温"],"categories":["算法重温"]},{"title":"JavaSE篇-Day2笔记","url":"/2020/05/05/JavaSE-Day(2)学习笔记/","content":"\n# Java语言基础\n\n## Java基础语法\n\n### 1.关键字\n\n<!--more-->\n\n**关键字概述：**\n被Java语言赋予特定含义的单词。\n\n**关键字特点：**\n组成关键字的字母全部小写。\n\n**注意事项：**\ngoto和const是保留字，在一般的高级Java编译器中，针对关键字都有特殊的颜色标记。\n\n- **Java关键字**\n\n![Java关键字](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1588673781789&di=405fa28b84d8a8b0464f054e43655198&imgtype=0&src=http%3A%2F%2Fpic4.zhimg.com%2Fv2-b1d047a34f15efeabd5211fd54f73b0b_b.jpg)\n\n### 2.标识符\n\n**标识符概述：**\n就是给类，接口，方法，变量等起名字时使用的字符序列\n\n**组成规则：**\n\n- **英文大小写字母**\n- **数字字符**\n- **$和_**\n\n**注意事项：**\n\n- **不能以数字开头**\n- **不能是Java中的关键字**\n- **区分大小写**\n\n### 3.标识符的常见命名规则\n\n**注意事项：**\n见名知意\n\n- **举例：我要定义一个学生类**\n\n```\nclass Student {}\n```\n\n**包：**\n其实就是文件夹，用于把相同的类名进行区分，全部小写\n\n- **单级：liuyi**\n- **多级：cn.itcast**\n\n**类或者接口：**\n\n- **一个单词：单词的首字母必须大写,举例：Student，Dog**\n- **多个单词：每个单词的首字母必须大写，举例：HelloWorld，StudentName**\n\n**方法或者变量：**\n\n- **一个单词：单词的首字母小写，举例：main，age**\n- **多个单词：从第二个单词开始，每个单词的首字母大写，举例：studentAge,showAllNames**\n\n**常量：**\n\n- **一个单词组成：全部大写，举例：PI**\n- **多个单词组成：每个字母都大写，用_隔开，举例：STUDENT_MAX_AGE**\n\n### 4.注释概述及其分类\n\n**注释概述：**\n用于解释说明的文字\n\n**Java中注释分类格式：**\n\n- **单行注释：格式：//注释文字**\n- **多行注释：格式：/星 注释文字 星/，注意：多行不可以嵌套使用，而单行是可以的**\n- **文档注释：格式：/星星 注释文字 星/**\n\n### 5.HelloWorld案例加入注释\n\n```\n/*\n 需求：我准备写一个java程序，把\"HelloWorld\"这句话输出在控制台\n\n分析：\nA:要写一个Java程序，必须定义类\nB:把数据能够输出，说明我们的程序是可以独立运行的，而程序要独立运行，必须定义main方法\nC:把数据输出在控制台，必须使用输出语句\n实现：\nA:java语言提供了一个关键字：class用来定义类，后面跟的是类名\nB:main方法的格式是固定的：\npublic static void main(String[] args) {\n\n}\nC:输出语句的格式是固定的：\nSystem.out.println(\"HelloWorld\");\n\"HelloWorld\"这个内容是可以改变的\n*/\n\n//这是我的HelloWorld案例\nclass HelloWorld {\n/*\n为了程序能够独立运行，定义main方法\nmain方法是程序的入口\n被jvm自动调用\n*/\npublic static void main(String[] args) {\n  //为了把数据显示在控制台，我们就使用了输出语句\n System.out.println(\"HelloWorld\");\n  }\n}\n```\n\n### 6.注释的作用\n\n略过，在Eclipse Jee 2018-12程序中编写Java代码时，有错误的话，编译器会提示。\n\n### 7.常量的概述和使用\n\n**常量概述：**\n在程序执行的过程中其值不可以发生改变\n\n```\n/*\n    常量：\n        在程序执行过程中，其值不发生改变的量。\n\n    分类：\n        A:字面值常量\n        B:自定义常量(后面讲)\n\n    字面值常量\n        A:字符串常量  用双引号括起来的内容。\n            举例：\"hello\",\"world\",\"HelloWorld\"\n        B:整数常量   所有的整数\n            举例：100,200\n        C:小数常量   所有的小数\n            举例：10.23,110.11\n\t\tD:字符常量\t用单引号括起来的内容\n\t\t\t举例：'a','A','0'\n\t\t\t错误的：'ab'\n\t\tE:布尔常量\t比较特殊\n\t\t\t举例：true,false\n\t\tF:空常量\t后面讲\n\t\t\t举例：null\n*/\nclass ConstantDemo {\n\tpublic static void main(String[] args) {\n\t\t//字符串常量的输出\n\t\tSystem.out.println(\"hello\");\n\t\t\n\t\t//整数常量的输出\n\t\tSystem.out.println(100);\n\t\t\n\t\t//小数常量的输出\n\t\tSystem.out.println(100.10);\n\t\t\n\t\t//字符常量的输出\n\t\tSystem.out.println('a');\n\t\tSystem.out.println('A');\n\t\tSystem.out.println('0');\n\t\t//这个是有问题的\n\t\t//System.out.println('ab');\n\t\t\n\t\t//布尔常量的输出\n\t\tSystem.out.println(true);\n\t\tSystem.out.println(false);\n\t}\n}\n```\n\n### 8.进制概述以及二进制、八进制、十六进制图解\n\n![进制](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1588680207620&di=5dc7fbed0760175d40d1bbb10baa7b8d&imgtype=0&src=http%3A%2F%2Fgss0.baidu.com%2F9fo3dSag_xI4khGko9WTAnF6hhy%2Fzhidao%2Fpic%2Fitem%2Fd439b6003af33a87736ff400c45c10385343b5ae.jpg)\n\n**二进制->八进制：**\n把二进制的数据，从右开始，每三位一组合，最左边不够的时候，补0。然后，分别计算出对应的十进制数值，最后，再把每个十进制的数据组合起来，就是一个八进制数据。\n\n**二进制->十六进制：**\n把二进制的数据，从右开始，每四位一组合，最左边不够的时候，补0。然后，分别计算出对应的十进制数值，最后，再把每个十进制的数据组合起来，就是一个十六进制数据。\n\n**规则：进制越大，表现形式越短**\n\n### 9.不同进制数据的表现形式\n\n```\n/*\n\t不同进制的数据表现：\n\t\t二进制：由0，1组成。以0b开头。\n\t\t八进制：由0,1,...7组成。以0开头。\n\t\t十进制：由0,1,...9组成。默认整数是十进制。\n\t\t十六进制：由0,1,...9,a,b,c,d,e,f(大小写均可)组成。以0x开头。\n*/\nclass JinZhiDemo {\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(100); //十进制\n\t\t\n\t\tSystem.out.println(0b100); //二进制\n\t\tSystem.out.println(0100); //八进制\n\t\tSystem.out.println(0x100); //十六进制\n\t}\n}\n```\n\n### 10.任意进制到十进制的转换\n\n![转换](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1588680802524&di=c3fd9ec5b2d6bae9fefda7479f3c2742&imgtype=0&src=http%3A%2F%2Fwww.myexception.cn%2Fimg%2F2015%2F07%2F11%2F060509721.png)\n\n**系数：每一个位上的数据值本身就是系数。**\n\n**基数：x进制的基数就是x。**\n\n**权：我们针对每一个位上的数据进行编号，从右边，并且是从0开始编号，这个编号就是该位上数据的权值。**\n\n**PS：每一个位上的系数x基数^权次幂相加。**\n\n### 11.十进制到任意进制的转换\n\n**方法：这个数对基数依次取余，将余数倒序输出，在倒序输出余数之前正序输出最后一次的商。（这个方法是很简单的一种方式，可以大大的节省时间）。**\n\n**将十进制转成八进制：**\n579 / 8 = 72　．．．3\n72 / 8 =9　．．．0\n9 / 8 =1　．．．1\n\n先输出最后一次计算的商，然后倒序从下到上输出余数\n八进制的 576 为　1103\n\n### 12.快速的进制转换法\n\n**8421码**\n\n![8421](https://img-blog.csdnimg.cn/20181213115022126.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjUxODA2Mg==,size_16,color_FFFFFF,t_70)\n\n### 13.原码、反码、补码的讲解\n\n**在探求为何机器要使用补码之前, 让我们先了解原码, 反码和补码的概念.对于一个数, 计算机要使用一定的编码方式进行存储. 原码, 反码, 补码是机器存储一个具体数字的编码方式。**\n\n**原码：**\n原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:\n\n[+1]原 = 0000 0001\n\n[-1]原 = 1000 0001\n\n第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是:[1111 1111 , 0111 1111]即[-127 , 127]，原码是人脑最容易理解和计算的表示方式。\n\n**反码：**\n反码的表示方法是:正数的反码是其本身；负数的反码是在其原码的基础上, 符号位不变，其余各个位取反。\n\n[+1] = [00000001]原 = [00000001]反\n\n[-1] = [10000001]原 = [11111110]反\n\n可见如果一个反码表示的是负数, 人脑无法直观的看出来它的数值. 通常要将其转换成原码再计算。\n\n**补码：**\n补码的表示方法是:正数的补码就是其本身；负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)。\n\n[+1] = [00000001]原 = [00000001]反 = [00000001]补\n\n[-1] = [10000001]原 = [11111110]反 = [11111111]补\n\n对于负数, 补码表示方式也是人脑无法直观看出其数值的. 通常也需要转换成原码在计算其数值。\n\n### 14.变量的概述及格式\n\n**变量的概念：**\n\n- **在程序执行的过程中，在某个范围内其值可以发生改变的量**\n\n- **从本质上讲，变量其实是内存中的一小块区域，使用变量名来访问这块区域，因此，每一个变量使用前必须要先申请（声明），然后必须进行赋值（填充内容），才能使用。**\n\n**变量定义格式：**\n\n- **数据类型 变量名 = 初始化值;**\n\n注意：格式是固定的，记住格式，以不变应万变\n\n### 15.数据类型的概述和分类和定义不同数据类型的变量\n\n```\n/*\n\t数据类型：Java是一种强类型的语言，针对每一种数据都定义了明确的数据类型。\n\t\n\t数据类型分类：\n\t\tA:基本数据类型\n\t\tB:引用数据类型(类,接口,数值)\n\t\t\n\t基本数据类型:4类8种\n\t\tA:整数\t\t\t占用字节数\n\t\t\tbyte\t\t\t1\n\t\t\tshort\t\t\t2\n\t\t\tint\t\t\t\t4\n\t\t\tlong\t\t\t8\n\t\t\t\n\t\tB:浮点数\n\t\t\tfloat \t\t\t4\n\t\t\tdouble \t\t\t8\n\t\t\t\n\t\tC:字符\n\t\t\tchar\t\t\t2\n\t\tD:布尔\n\t\t\tboolean\t\t\t1\n\t\t\n\t\t注意：\n\t\t\t整数默认是int类型\n\t\t\t浮点数默认是double类型。\n\t\t\t\n\t\t\t长整型后缀用L或者l标记。建议使用L。\n\t\t\t单精度浮点数用F或者f标记。建议使用F。\n*/\nclass DataTypeDemo {\n\tpublic static void main(String[] args) {\n\t\t//定义变量的格式：\n\t\t//数据类型 变量名 = 初始化值;\n\t\t\n\t\t//定义一个字节变量\n\t\tbyte b = 10;\n\t\tSystem.out.println(10);\n\t\tSystem.out.println(b);\n\t\t\n\t\t//定义一个短整型变量\n\t\tshort s = 100;\n\t\tSystem.out.println(s);\n\t\t\n\t\t//定义一个整型变量\n\t\tint i = 1000;\n\t\tSystem.out.println(i);\n\t\t\n\t\t//超过了int的范围\n\t\t//int j = 1000000000000;\n\t\tlong j = 1000000000000L;\n\t\t//long j = 100L;\n\t\tSystem.out.println(j);\n\t\t\n\t\t//定义浮点数据变量\n\t\tfloat f = 12.345F;\n\t\tSystem.out.println(f);\n\t\t\n\t\tdouble d = 12.345;\n\t\tSystem.out.println(d);\n\t\t\n\t\t//定义字符变量\n\t\tchar ch = 'a';\n\t\tSystem.out.println(ch);\n\t\t\n\t\t//定义布尔变量\n\t\tboolean flag = true;\n\t\tSystem.out.println(flag);\n\t}\n}\n```\n\n### 16.使用变量的注意事项\n\n```\n/*\n\t使用变量的时候要注意的问题：\n\t\tA:作用域\n\t\t\t变量定义在哪个大括号内，它就在这个大括号内有效。\n\t\t\t并且，在同一个大括号内不能同时定义同名的变量。\n\t\t\t\n\t\tB:初始化值\n\t\t\t没有初始化值的变量不能直接使用。\n\t\t\t你只要在使用前给值就行，不一定非要在定义的时候立即给值。\n\t\t\t推荐在定义的时候给值。\n\t\t\t\n\t\t\t定义变量的格式：\n\t\t\t\ta:数据类型 变量名 = 初始化值;\n\t\t\t\tb:数据类型 变量名;\n\t\t\t\t  变量名 = 初始化值;\n\t\t\n\t\tC:在一行上建议只定义一个变量\n\t\t\t可以定义多个，但是不建议\n*/\nclass DataTypeDemo2 {\n\tpublic static void main(String[] args) {\n\t\t//定义变量\n\t\tint x = 100;\n\t\t\n\t\t//错误，不能有同名的\n\t\t//int x = 200;\n\t\t\n\t\t//定义变量必须给值\n\t\t//int y;\n\t\t//System.out.println(y);\n\t\t\n\t\tint z;\n\t\tz = 100;\n\t\tSystem.out.println(z);\n\t\t\n\t\t//在一行上定义多个变量\n\t\t//int a = 10; int b = 20; int c  = 30;\n\t\t//上面的写法可以，但是不建议。\n\t\tint a = 10;\n\t\tint b = 20;\n\t\tint c  = 30;\n\t\t\n\t\t//int d, e;\n\t\t//d = 40;\n\t\t//e = 50;\n\t\t\n\t\t//int f,int g; //错误\n\t\t//int h; int i; //正确\n\t}\n}\n```\n\n### 17.数据类型转换默认转换\n\n```\n/*\n\t+是一个运算符(我们等会讲解)。做加法运算的。\n\t\n\t一般来说，我们在运算的时候，要求参与运算的数据类型必须一致。\n\t\n\t注意：\n\t\tboolean类型不能转换为其他的数据类型\n\n\t默认转换(从小到大的转换)\n\t\tA:byte,short,char—int—long—float—double\n\t\tB:byte,short,char相互之间不转换，他们参与运算首先转换为int类型\n*/\nclass DataTypeDemo3 {\n\tpublic static void main(String[] args) {\n\t\t//直接输出的方式做加法\n\t\t//System.out.println(3 + 4);\n\t\n\t\t//两个int类型做加法\n\t\tint x = 3;\n\t\tint y = 4;\n\t\tint z = x + y;\n\t\tSystem.out.println(z);\n\t\t\n\t\t//定义一个byte类型，一个int类型，做加法\n\t\tbyte a = 3;\n\t\tint b = 4;\n\t\tSystem.out.println(a + b);\n\t\t\n\t\t//可能损失精度\n\t\t//byte c =  a + b;\n\t\tint c = a + b;\n\t\tSystem.out.println(c);\n\t}\n}\n```\n\n### 18.数据类型转换强制转换\n\n```\n/*\n\t强制转换：\n\t\t从大的数据类型到小的数据类型。\n\t\t\n\t\t格式：\n\t\t\t目标数据类型 变量 = (目标数据类型) (被转换的数据);\n\t\t\t\n\t\t注意：\n\t\t\t不要随意的去使用强制转换，因为它隐含了精度损失问题。\n*/\nclass DataTypeDemo4 {\n\tpublic static void main(String[] args) {\n\t\tbyte a = 3;\n\t\tint b = 4;\n\t\t\n\t\t//这个肯定没有问题\n\t\t//int c = a + b;\n\t\t\n\t\t//byte c = 7;\n\t\t//这个是有问题的\n\t\t//byte c = a + b; \n\t\t//用强制类型转换改进\n\t\tbyte c = (byte) (a + b);\n\t\tSystem.out.println(c);\n\t}\n}\n```\n\n### 19.强制转换的思考题\n\n```\n/*\n\t思考题1：请问下面这个有没有问题\n\t\tdouble d = 12.345;\n\t\tfloat f = d;\n\t\t\n\t思考题2：看看下面两个定义有没有区别呢?\n\t\tfloat f1 = (float)12.345;\n\t\tfloat f2 = 12.345f;\n\t\t\n\t\tf1其实是通过一个double类型转换过来的。\n\t\t而f2本身就是一个float类型。\n*/\nclass DataTypeDemo5 {\n\tpublic static void main(String[] args) {\n\t\t//把double赋值给float，加了强制类型转换\n\t\tdouble d = 12.345;\n\t\tfloat f = (float)d;\n\t\t\n\t\t//看看下面两个定义有没有区别呢?\n\t\tfloat f1 = (float)12.345;\n\t\tfloat f2 = 12.345F;\n\t}\n}\n```\n\n### 20.变量相加和常量相加的面试题\n\n```\n/*\n\t面试题：\n\t\tbyte b1=3,b2=4,b;\n\t\tb=b1+b2;\n\t\tb=3+4;\n\t\t哪句是编译失败的呢？为什么呢？\n\t\tb = b1 + b2;是有问题的。\n\t\t因为变量相加，会首先看类型问题，最终把结果赋值的也会考虑类型问题。\n\t\t常量相加，首先做加法，然后看结果是否在赋值的数据类型范围内，如果不是，才报错。\n*/\nclass DataTypeDemo6 {\n\tpublic static void main(String[] args) {\n\t\t//定义了三个byte类型的变量，b1，b2，b3\n\t\t//b1的值是3，b2的值是4，b没有值\n\t\tbyte b1 = 3,b2 = 4,b;\n\t\t\n\t\t//b = b1 + b2; //这个是类型提升，所以有问题\n\t\t\n\t\tb = 3 + 4; //常量，先把结果计算出来，然后看是否在byte的范围内，如果在就不报错。\n\t}\n}\n```\n\n### 21.强制转换数据溢出后的结果怎么算\n\n```\n/*\n\tbyte b = 130;有没有问题?如果我想让赋值正确，可以怎么做?结果是多少呢?\n\t\n\t练习：byte b = (byte)300;\n*/\nclass DataTypeDemo7 {\n\tpublic static void main(String[] args) {\n\t\t//因为byte的范围是：-128到127。\n\t\t//而130不在此范围内，所以报错。\n\t\t//byte b = 130; \n\t\t\n\t\t//我们可以使用强制类型转换\n\t\tbyte b = (byte) 130;\n\t\t\n\t\t//结果是多少呢?\n\t\tSystem.out.println(b);\n\t}\n}\n/*\n\t分析过程：\n\t\t我们要想知道结果是什么，就应该知道是如何进行计算的。\n\t\t而我们又知道计算机中数据的运算都是补码进行的。\n\t\t而要得到补码，首先要计算出数据的二进制。\n\t\t\n\t\tA:获取130这个数据的二进制。\n\t\t\t00000000 00000000 00000000 10000010\n\t\t\t这是130的原码，也是反码，还是补码。\n\t\tB:做截取操作，截成byte类型的了。\n\t\t\t10000010 \n\t\t\t这个结果是补码。\n\t\tC:已知补码求原码。\n\t\t\t\t\t符号位\t\t数值位\n\t\t\t补码：\t1\t\t\t0000010\n\t\t\t\n\t\t\t反码：\t1\t\t\t0000001\n\t\t\t\n\t\t\t原码：\t1\t\t\t1111110\n*/\n```\n\n### 22.字符数据参与运算\n\n**常用字符与ASCII代码对照表**\n\n![ACSII](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1588762945712&di=15da2d4da03c11464b6f7ef905bd8194&imgtype=0&src=http%3A%2F%2Faliyunzixunbucket.oss-cn-beijing.aliyuncs.com%2Fjpg%2F5802ba54ea55b831c41d5a4b5b13e641.jpg%3Fx-oss-process%3Dimage%2Fresize%2Cp_100%2Fauto-orient%2C1%2Fquality%2Cq_90%2Fformat%2Cjpg%2Fwatermark%2Cimage_eXVuY2VzaGk%3D%2Ct_100)\n\n### 23.字符串参与运算\n\n```\n/*\n\t看程序写结果\n\t\t字符串数据和其他数据做+，结果是字符串类型。\n\t\t这里的+不是加法运算，而是字符串连接符。\n*/\nclass DataTypeDemo9 {\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(\"hello\"+'a'+1); //helloa1，因为有优先级\n\t\tSystem.out.println('a'+1+\"hello\"); //98hello\n\t\t\n\t\tSystem.out.println(\"5+5=\"+5+5); //5+5=55\n\t\tSystem.out.println(5+5+\"=5+5\"); //10=5+5\n\t}\n}\n```\n\n**运算符优先级**\n\n![运算符优先级](https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=807700448,2127105133&fm=26&gp=0.jpg)","tags":["Java系统学习"],"categories":["Java系统学习-JavaSE篇"]},{"title":"JavaSE篇-Day1笔记","url":"/2020/05/04/JavaSE-Day(1)学习笔记/","content":"\n## 一、计算机基础\n\n### 1.计算机概述\n\n  **计算机全称为：电子计算机，俗称电脑**\n\n<!--more-->\n\n### 2.计算机硬件和软件概述\n\n- **计算机硬件是指计算机系统中由电子，机械和光电元件等组成的各种物理装置的总称。**\n- **计算机软件是指使用计算机过程中必不可少的东西，计算机软件可以使家算计按照事先预定好的顺序完成特定的功能，计算机软件按照其功能划分为系统软件和应用软件。**\n  \n### 3.软件开发和计算机语言概述\n\n- **软件开发：借助开发工具与计算机语言制作软件。**\n- **计算机语言：人与计算机之间进行信息交流沟通的一种特殊语言。**\n- **常见的计算机语言如C，C++，C#，JAVA，python。**\n\n### 4.人机交互\n\n   **交互方式：**\n\n- **图形化界面：这种方式简单直观，使用者易于接受，容易操作上手。**\n- **命令性方式：需要一个控制台，输入特定的指令，让计算机完成一些操作。较为麻烦。需要记录住一些命令。**\n\n### 5.键盘功能键和快捷键\n\n   **应该记住一些简单的功能键和快捷键**\n\n- **Tab 缩进空格**\n- **Enter 回车**\n- **Window键**\n- **Ctrl+A全选 Ctrl+C 复制 Ctrl+V 粘贴 Ctrl+X剪切 Ctrl+Z 撤销 Ctrl+S 保存**\n\n### 6.如何打开DOS控制台\n\n   **Windows+R -> cmd -> 回车**\n\n### 7.常见的DOS讲解\n\n- **d: +回车   盘符切换**\n- **dir(directory):   列出当前目录下的文件以及文件夹**\n- **md(make directory):    创建目录**\n- **rd(remove directory):   删除目录**\n- **cd(change directory):   改变指定目录（进入指定目录）**\n- **cd..:     退回上级目录**\n- **cd\\:     退回根目录**\n- **exit:     推出dos命令行**\n- **cls(clear screen):    清屏**\n- **del(delete):   删除文件，删除一堆后缀名一样的文件，例如.txt**\n\n## 二、Java语言基础\n\n### 1.Java语言概述\n\n**Java语言由詹姆斯.高斯林发明**\n\n### 2.Java语言跨平台原理\n\n**Java是面向对象的语言，其重点特点是开源和跨平台**\n\n![Java语言的跨平台性](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=52291647,1781400255&fm=15&gp=0.jpg)\n\n### 3.JDK与JRE的概述\n\n**JRE -> Java运行环境**\n\n**JDK -> Java开发工具包，其中包含了JRE**\n\n**简单而言：使用JDK开发完成的java程序，交给JRE去运行**\n\n### 4.JDK的下载、安装和卸载\n\n**详情请看：https://blog.csdn.net/nuoyanli/article/details/86513950**\n\n### 5.Java环境变量的配置\n\n**详情请看：https://blog.csdn.net/nuoyanli/article/details/86513950**\n\n### 6.第一个Java案例的编写和运行\n\n**视频里老师用的是记事本进行编写和运行，而我用的是Eclipse Jee 2018-12**\n\n```\nimport java.util.*;\nimport java.math.*;\nimport java.io.*;\npublic class Main {\n\n public static void main(String[] args) {\n  // TODO Auto-generated method stub\n        System.out.println(\"Hello world\");\n }\n}\n```\n","tags":["Java系统学习"],"categories":["Java系统学习-JavaSE篇"]},{"title":"Java系统学习规划(1)——JavaSE篇","url":"/2020/05/04/Java系统学习规划(1)—JavaSE篇/","content":"\n## 写在前面\n\n**关于为什么要在现在系统的学习Java，是因为我觉得去年暑假学习的一些Java知识基本都忘记了(~~其实是因为今年疫情影响，很大概率原地退役，所以也算为以后做做准备~~)**\n\n<!--more-->\n\n## Java系统学习规划(1)\n\n### 一、\n\n**选择什么课程：这里的话我是选择了刘意老师的深入浅出精华版为主，毕向东老师的Java基础教程为辅来进行学习。**\n\n这里给出刘意老师视频的B站地址：https://www.bilibili.com/video/BV1Jt411w7fR?from=search&seid=5273427619493979344\n\n这里给出毕向东老师视频的B站地址：https://www.bilibili.com/video/BV1pt41127na?from=search&seid=9126689322584219690\n\n### 二、\n\n**学习重点参考** \n\n初学者也容易想走捷径。我相信很多人都会有这个想法：能不能只学工作上要用的？根本原因是知识点真的太多了。以刘意老师视频为例，面向对象（封装，继承，多态），异常，多线程，集合框架，IO，网络编程都挺难的。其中面向对象是JavaSE的重中之重，里面的知识点个人认为是最难的。后面的知识点都是建立在这之上展开的，没学好面向对象，后面就会稀里糊涂。当然，也不是真的一点都不能跳，但最好完整地学下来。按照后面JavaWeb的学习来看，我的建议是：\n\n- **面向对象是基石，JavaSE中最重要的一是集合，二是IO，** 希望大家学习这两个知识点时认真对待，多敲代码，多思考。\n- **常用API里，String及其相关类StringBuilder, StringBuffer** 等必须熟悉，后面会不断用到。不学好的话，后面怎么死都不知道！\n- **泛型一般只出现在集合中** ，个人觉得如果一时无法掌握，那么**暂时会在集合中使用泛型就行了。**\n- 反射对于初学者来说是**非常抽象的！！** 但它又无比重要。它虽然不是JavaSE的重点，但是**它是JavaWeb很多难点的底层支撑，不懂反射，寸步难行。**\n\n**重点**\n\n- 面向对象☆☆☆☆☆\n- 集合☆☆☆☆☆\n- IO ☆☆☆☆☆\n- String/StringBuffer/StringBuilder ☆☆☆☆☆\n- 反射☆☆☆☆☆\n- 泛型☆☆☆☆\n\n**熟悉**\n\n- 异常\n- 多线程\n\n**先过一遍**\n\n- 网络编程\n- 正则表达式\n\n### 补充\n\n**这里给出刘意老师视频的配套资料**\n\n2015年版本刘意Java基础配套资料：https://pan.baidu.com/s/13slfA9U23PiXca_ROPC0ww   提取码：rmkv\n","tags":["Java系统学习"],"categories":["Java系统学习-JavaSE篇"]},{"title":"我的第一篇博客","url":"/2020/04/30/我的第一篇博客/","content":"## Hexo的一些语法\n\n### 常见命令\n\n```、\n**hexo new \"postName\" #新建文章\nhexo new page \"pageName\" #新建页面\nhexo generate #生成静态页面至public目录\nhexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）\nhexo deploy #部署到GitHub\nhexo help  # 查看帮助\nhexo version  #查看Hexo的版本**\nhexo clean  #清除缓存文件和静态文件\n```\n<!--more-->\n\n### 缩写\n\n```、\nhexo n == hexo new\nhexo g == hexo generate\nhexo s == hexo server\nhexo d == hexo deploy\n```\n\n### 组合命令\n\n```、\nhexo s -g #生成并本地预览\nhexo d -g #生成并上传\n```\n\n### 在生成一篇新的博客的一些操作\n\n**首先：hexo new/n + 博客标题(标题需加双引号)\n然后：运行后会自动生成markdown格式的文章\n然后：按创建成功后的提示信息（路径）进入到该文件所在的目录中，将md后缀的文件在Visual Studio Code中打开，可以在Visual Studio Code中下载一个markdownlint插件进行编辑。\n最后：编辑完成后返回主目录blog(cd … 返回上一层目录)\n运行 hexo clean 清除缓存文件和静态文件（非必要）\n运行 hexo generate/g 生成静态博客文件\n运行 hexo server/s 启动博客**\n\n### 如何把个人博客部署到远端\n\n**在blog目录下运行命令 hexo deploy/d 将本地博客部署到github\n部署过程中按要求输入 github 的账号和密码\n完成后就可直接通过该仓库名（username.github.io）访问博客了**\n","tags":["Hexo的一些基本用法和编写博客的一些注意事项"]},{"title":"Hello Stephencurry6666","url":"/2020/04/30/hello-world/","content":"\n### 科学公式 TeX(KaTeX)\n\n$$E=mc^2$$\n\n行内的公式$$E=mc^2$$行内的公式，行内的$$E=mc^2$$公式。\n\n$$x > y$$\n\n$$(\\sqrt{3x-1}+(1+x)^2)$$\n\n$$\\sin(\\alpha)^{\\theta}=\\sum_{i=0}^{n}(x^i + \\cos(f))$$\n\n$$\\iint_{a}^{b}\\frac{\\mathrm{3} }{\\mathrm{3} x}$$\n\n<!--more-->\n\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n<!--more-->\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]