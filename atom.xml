<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>愿你出走半生，归来仍是少年</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://stephencurry6666.github.io/"/>
  <updated>2020-05-12T09:31:43.390Z</updated>
  <id>https://stephencurry6666.github.io/</id>
  
  <author>
    <name>Stephencurry6666</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Constructing Roads（POJ-2421）（最小生成树）</title>
    <link href="https://stephencurry6666.github.io/2020/05/12/Constructing%20Roads%EF%BC%88POJ-2421%EF%BC%89%EF%BC%88%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%89/"/>
    <id>https://stephencurry6666.github.io/2020/05/12/Constructing%20Roads%EF%BC%88POJ-2421%EF%BC%89%EF%BC%88%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%89/</id>
    <published>2020-05-12T09:21:22.967Z</published>
    <updated>2020-05-12T09:31:43.390Z</updated>
    
    <content type="html"><![CDATA[<p>There are N villages, which are numbered from 1 to N, and you should build some roads such that every two villages can connect to each other. We say two village A and B are connected, if and only if there is a road between A and B, or there exists a village C such that there is a road between A and C, and C and B are connected.</p><a id="more"></a><p>We know that there are already some roads between some villages and your job is the build some roads such that all the villages are connect and the length of all the roads built is minimum.<br>Input<br>The first line is an integer N (3 &lt;= N &lt;= 100), which is the number of villages. Then come N lines, the i-th of which contains N integers, and the j-th of these N integers is the distance (the distance should be an integer within [1, 1000]) between village i and village j.</p><p>Then there is an integer Q (0 &lt;= Q &lt;= N * (N + 1) / 2). Then come Q lines, each line contains two integers a and b (1 &lt;= a &lt; b &lt;= N), which means the road between village a and village b has been built.<br>Output<br>You should output a line contains an integer, which is the length of all the roads to be built such that all the villages are connected, and this value is minimum.<br>Sample Input<br>3<br>0 990 692</p><p>990 0 179</p><p>692 179 0</p><p>1</p><p>1 2</p><p>Sample Output<br>179</p><p><strong>题意：</strong><br><strong>要修公路，输入一个n，表示n个村庄。接着输入n*n的矩阵，该图的邻接矩阵，然后输入一个q 接下来的q行，每行包含两个数a，b，表示a、b这条边联通，就是已经有公路不用修了，要让所有村庄联通在一起问：修路最小代价是多少。</strong></p><p><strong>思路：</strong><br><strong>这道题的话，根据题目输入构造邻接矩阵，然后把已经联通的村庄的距离设置为0，表示不用在修这条公路。然后用Prim算法即可。</strong></p><p><strong>AC代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxx &#x3D; 10010;</span><br><span class="line">const int mod &#x3D; 10007;</span><br><span class="line">const int inf &#x3D; 0x3f3f3f3f;</span><br><span class="line">const double eps &#x3D; 1e-8;</span><br><span class="line">using namespace std;</span><br><span class="line">int mapp[maxx][maxx];</span><br><span class="line">int dis[maxx];</span><br><span class="line">bool vis[maxx];</span><br><span class="line">int n;</span><br><span class="line">void Prim()</span><br><span class="line">&#123;</span><br><span class="line">    int sum &#x3D; 0;</span><br><span class="line">    int now;</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dis[i] &#x3D; i;</span><br><span class="line">        vis[i] &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">        dis[i] &#x3D; mapp[1][i];</span><br><span class="line">    dis[1] &#x3D; 0;</span><br><span class="line">    vis[1] &#x3D; true;</span><br><span class="line">    for (int i &#x3D; 1; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        now &#x3D; inf;</span><br><span class="line">        int minn &#x3D; inf;</span><br><span class="line">        for (int j &#x3D; 1; j &lt;&#x3D; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (!vis[j] &amp;&amp; dis[j] &lt; minn)</span><br><span class="line">            &#123;</span><br><span class="line">                now &#x3D; j;</span><br><span class="line">                minn &#x3D; dis[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(now &#x3D;&#x3D; inf)</span><br><span class="line">        break;</span><br><span class="line">        vis[now] &#x3D; true;</span><br><span class="line">        sum +&#x3D; minn;</span><br><span class="line">        for (int j &#x3D; 1; j &lt;&#x3D; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (!vis[j] &amp;&amp; dis[j] &gt; mapp[now][j])</span><br><span class="line">                dis[j] &#x3D; mapp[now][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;, sum);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while (~scanf(&quot;%d&quot;, &amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">            for (int j &#x3D; 1; j &lt;&#x3D; n; j++)</span><br><span class="line">                scanf(&quot;%d&quot;, &amp;mapp[i][j]);</span><br><span class="line">        int q, a, b;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;q);</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; q; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d%d&quot;, &amp;a, &amp;b);</span><br><span class="line">            mapp[a][b] &#x3D; mapp[b][a] &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">        Prim();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;There are N villages, which are numbered from 1 to N, and you should build some roads such that every two villages can connect to each other. We say two village A and B are connected, if and only if there is a road between A and B, or there exists a village C such that there is a road between A and C, and C and B are connected.&lt;/p&gt;
    
    </summary>
    
    
      <category term="最小生成树" scheme="https://stephencurry6666.github.io/categories/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
    
      <category term="最小生成树" scheme="https://stephencurry6666.github.io/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>QS Network（ZOJ-1586）（最小生成树）</title>
    <link href="https://stephencurry6666.github.io/2020/05/12/QS%20Network%EF%BC%88ZOJ-1586%EF%BC%89%EF%BC%88%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%89/"/>
    <id>https://stephencurry6666.github.io/2020/05/12/QS%20Network%EF%BC%88ZOJ-1586%EF%BC%89%EF%BC%88%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%89/</id>
    <published>2020-05-12T08:30:24.464Z</published>
    <updated>2020-05-12T09:24:50.592Z</updated>
    
    <content type="html"><![CDATA[<p>Sunny Cup 2003 - Preliminary Round<br>April 20th, 12:00 - 17:00</p><p>Problem E: QS Network</p><a id="more"></a><p>In the planet w-503 of galaxy cgb, there is a kind of intelligent creature named QS. QScommunicate with each other via networks. If two QS want to get connected, they need to buy two network adapters (one for each QS) and a segment of network cable. Please be advised that ONE NETWORK ADAPTER CAN ONLY BE USED IN A SINGLE CONNECTION.(ie. if a QS want to setup four connections, it needs to buy four adapters). In the procedure of communication, a QS broadcasts its message to all the QS it is connected with, the group of QS who receive the message broadcast the message to all the QS they connected with, the procedure repeats until all the QS’s have received the message.</p><p>A sample is shown below:</p><p><img src="https://vj.z180.cn/1120637f03c5c4bc9402775a6100caa8?v=1589071552" alt="tupian"></p><p>A sample QS network, and QS A want to send a message.</p><p>Step 1. QS A sends message to QS B and QS C;</p><p>Step 2. QS B sends message to QS A ; QS C sends message to QS A and QS D;</p><p>Step 3. the procedure terminates because all the QS received the message.</p><p>Each QS has its favorate brand of network adapters and always buys the brand in all of its connections. Also the distance between QS vary. Given the price of each QS’s favorate brand of network adapters and the price of cable between each pair of QS, your task is to write a program to determine the minimum cost to setup a QS network.</p><p>Input</p><p>The 1st line of the input contains an integer t which indicates the number of data sets.</p><p>From the second line there are t data sets.</p><p>In a single data set,the 1st line contains an interger n which indicates the number of QS.</p><p>The 2nd line contains n integers, indicating the price of each QS’s favorate network adapter.</p><p>In the 3rd line to the n+2th line contain a matrix indicating the price of cable between ecah pair of QS.</p><p>Constrains:</p><p>all the integers in the input are non-negative and not more than 1000.</p><p>Output</p><p>for each data set,output the minimum cost in a line. NO extra empty lines needed.</p><p>Sample Input</p><p>1</p><p>3</p><p>10 20 30</p><p>0 100 200</p><p>100 0 300</p><p>200 300 0</p><p>Sample Output</p><p>370</p><p><strong>题意：</strong><br><strong>第一行给出T，代表有T组数据。每组数据第一行给出N，代表图有N个结点。接着一行给出N个数，代表每个结点的权值（就是接收器的费用），接着N行每行N个数，矩阵的形式给出各点之间边的权值（也就是连接接收器网线的费用）。最后实际权值就是边的权值加上两个点的权值，输出最小生成树的权值总和即可。</strong></p><p><strong>思路：</strong><br><strong>这道题的话，因为输入的是矩阵，我们用Prim算法更好一些，套下模板即可。</strong></p><p><strong>AC代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxx &#x3D; 10010;</span><br><span class="line">const int mod &#x3D; 10007;</span><br><span class="line">const int inf &#x3D; 0x3f3f3f3f;</span><br><span class="line">const double eps &#x3D; 1e-8;</span><br><span class="line">using namespace std;</span><br><span class="line">int mapp[maxx][maxx];</span><br><span class="line">int dis[maxx];</span><br><span class="line">int val[maxx];</span><br><span class="line">bool vis[maxx];</span><br><span class="line">int n;</span><br><span class="line">void Prim()</span><br><span class="line">&#123;</span><br><span class="line">    int sum &#x3D; 0;</span><br><span class="line">    int now;</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dis[i] &#x3D; i;</span><br><span class="line">        vis[i] &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">        dis[i] &#x3D; mapp[1][i];</span><br><span class="line">    dis[1] &#x3D; 0;</span><br><span class="line">    vis[1] &#x3D; true;</span><br><span class="line">    for (int i &#x3D; 1; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        now &#x3D; inf;</span><br><span class="line">        int minn &#x3D; inf;</span><br><span class="line">        for (int j &#x3D; 1; j &lt;&#x3D; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (!vis[j] &amp;&amp; dis[j] &lt; minn)</span><br><span class="line">            &#123;</span><br><span class="line">                now &#x3D; j;</span><br><span class="line">                minn &#x3D; dis[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (now &#x3D;&#x3D; inf)</span><br><span class="line">            break;</span><br><span class="line">        vis[now] &#x3D; true;</span><br><span class="line">        sum +&#x3D; minn;</span><br><span class="line">        for (int j &#x3D; 1; j &lt;&#x3D; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (!vis[j] &amp;&amp; dis[j] &gt; mapp[now][j])</span><br><span class="line">                dis[j] &#x3D; mapp[now][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;, sum);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int t;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;t);</span><br><span class="line">    while (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;val[i]);</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">            for (int j &#x3D; 1; j &lt;&#x3D; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                scanf(&quot;%d&quot;, &amp;mapp[i][j]);</span><br><span class="line">                mapp[i][j] +&#x3D; val[i] + val[j];</span><br><span class="line">            &#125;</span><br><span class="line">        Prim();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Sunny Cup 2003 - Preliminary Round&lt;br&gt;April 20th, 12:00 - 17:00&lt;/p&gt;
&lt;p&gt;Problem E: QS Network&lt;/p&gt;
    
    </summary>
    
    
      <category term="最小生成树" scheme="https://stephencurry6666.github.io/categories/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
    
      <category term="最小生成树" scheme="https://stephencurry6666.github.io/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>再次温习最小生成树的一些思路</title>
    <link href="https://stephencurry6666.github.io/2020/05/12/%E5%86%8D%E6%AC%A1%E6%B8%A9%E4%B9%A0%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%B7%AF/"/>
    <id>https://stephencurry6666.github.io/2020/05/12/%E5%86%8D%E6%AC%A1%E6%B8%A9%E4%B9%A0%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%B7%AF/</id>
    <published>2020-05-12T08:30:24.464Z</published>
    <updated>2020-05-12T09:20:59.153Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>因为之前4月份打了将近一个月的个人赛，有些以前学习过的算法已经忘了，所以重新再温习一遍。</p><a id="more"></a><h2 id="关于最小生成树"><a href="#关于最小生成树" class="headerlink" title="关于最小生成树"></a>关于最小生成树</h2><p><strong>最小生成树（minimum spanning tree）是由n个顶点，n-1条边，将一个连通图连接起来，且使权值最小的结构。<br>最小生成树可以用Prim（普里姆）算法或kruskal（克鲁斯卡尔）算法求出。</strong></p><h2 id="Kruskal算法详解及模板与例题"><a href="#Kruskal算法详解及模板与例题" class="headerlink" title="Kruskal算法详解及模板与例题"></a>Kruskal算法详解及模板与例题</h2><h3 id="Kruskal算法简介"><a href="#Kruskal算法简介" class="headerlink" title="Kruskal算法简介"></a>Kruskal算法简介</h3><p><strong>Kruskal算法是基于并查集算法而进行的，很简单的思路就是，对一张图，将所有的边都拆出来，然后对每条边的边权进行排序（从大到小，从小到大看题目需要），然后再将边连回去，连边的时候判断两个点是否被连通了，如果是连通的，那么就将该边扔了再看下一条边，如果没有被连通，那么就将该条边连上，然后用并查集合并即可。</strong></p><p><strong>时间复杂度：O（NlogN）（N为边数）<br>kruskal算法又称“加边法”，用于边数较少的稀疏图<br>方法：每次找图中权值最小的边，将边连接的两个顶点加入最小生成树集合中<br>注意：相同权值任选其中一个即可，但是不允许出现闭合回路的情况。</strong></p><h3 id="Kruskal算法图解"><a href="#Kruskal算法图解" class="headerlink" title="Kruskal算法图解"></a>Kruskal算法图解</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwODIwMTE1NjM2MTE3?x-oss-process=image/format,png" alt="tupian1"></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwODIwMTE1NjQ2MzA4?x-oss-process=image/format,png" alt="tupian2"></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwODIwMTE1NjU4MzI0?x-oss-process=image/format,png" alt="tupian3"></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwODIwMTE1NzExODQ1?x-oss-process=image/format,png" alt="tupian4"></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwODIwMTE1NzIzMTg5?x-oss-process=image/format,png" alt="tupian5"></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwODIwMTE1NzMyNjMy?x-oss-process=image/format,png" alt="tupian6"></p><h3 id="Kruskal算法代码详解及模板"><a href="#Kruskal算法代码详解及模板" class="headerlink" title="Kruskal算法代码详解及模板"></a>Kruskal算法代码详解及模板</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxx &#x3D; 200010;</span><br><span class="line">const int inf &#x3D; 0x3f3f3f3f;</span><br><span class="line">using namespace std;</span><br><span class="line">int pre[maxx];</span><br><span class="line">int n;</span><br><span class="line">struct node&#x2F;&#x2F;存边权值</span><br><span class="line">&#123;</span><br><span class="line">    int s;</span><br><span class="line">    int e;</span><br><span class="line">    int v;</span><br><span class="line">&#125; edge[maxx];</span><br><span class="line">bool cmp(node a, node b)&#x2F;&#x2F;看情况修改 优先级给小边权还是大边权</span><br><span class="line">&#123;</span><br><span class="line">    return a.v &lt; b.v;</span><br><span class="line">&#125;</span><br><span class="line">void init()&#x2F;&#x2F;初始化</span><br><span class="line">&#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt;&#x3D; n; i++)</span><br><span class="line">        pre[i] &#x3D; i;</span><br><span class="line">&#125;</span><br><span class="line">int getf(int a)&#x2F;&#x2F;并查集 看两点是否在同一个图内</span><br><span class="line">&#123;</span><br><span class="line">    if (pre[a] &#x3D;&#x3D; a)</span><br><span class="line">        return a;</span><br><span class="line">    int tmp &#x3D; getf(pre[a]);</span><br><span class="line">    return pre[a] &#x3D; tmp;</span><br><span class="line">&#125;</span><br><span class="line">int Kruskal(int a, int b) &#x2F;&#x2F;并查集合并操作，看是否在同一个图内 如果在就跳过 不在就合并</span><br><span class="line">&#123;</span><br><span class="line">    int fa &#x3D; getf(a);</span><br><span class="line">    int fb &#x3D; getf(b);</span><br><span class="line">    if (fa !&#x3D; fb)</span><br><span class="line">    &#123;</span><br><span class="line">        pre[fa] &#x3D; fb;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while (~scanf(&quot;%d&quot;, &amp;n), n)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        int m &#x3D; (n * (n - 1)) &#x2F; 2;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; m; i++)</span><br><span class="line">            scanf(&quot;%d%d%d&quot;, &amp;edge[i].s, &amp;edge[i].e, &amp;edge[i].v);</span><br><span class="line">        sort(edge + 1, edge + m + 1, cmp);</span><br><span class="line">        int ans &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (Kruskal(edge[i].s, edge[i].e))</span><br><span class="line">                ans +&#x3D; edge[i].v;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Kruskal算法例题"><a href="#Kruskal算法例题" class="headerlink" title="Kruskal算法例题"></a>Kruskal算法例题</h3><p><strong>例题一：POJ-1287</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxx &#x3D; 10010;</span><br><span class="line">const int mod &#x3D; 10007;</span><br><span class="line">const int inf &#x3D; 0x3f3f3f3f;</span><br><span class="line">const double eps &#x3D; 1e-8;</span><br><span class="line">using namespace std;</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    int s;</span><br><span class="line">    int e;</span><br><span class="line">    int v;</span><br><span class="line">&#125; edge[maxx];</span><br><span class="line">bool cmp(node a, node b)</span><br><span class="line">&#123;</span><br><span class="line">    return a.v &lt; b.v;</span><br><span class="line">&#125;</span><br><span class="line">int pre[maxx];</span><br><span class="line">int n, r;</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt;&#x3D; n; i++)</span><br><span class="line">        pre[i] &#x3D; i;</span><br><span class="line">&#125;</span><br><span class="line">int getf(int a)</span><br><span class="line">&#123;</span><br><span class="line">    if (pre[a] &#x3D;&#x3D; a)</span><br><span class="line">        return a;</span><br><span class="line">    int tmp &#x3D; getf(pre[a]);</span><br><span class="line">    return pre[a] &#x3D; tmp;</span><br><span class="line">&#125;</span><br><span class="line">int Kruskal(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    int fa &#x3D; getf(a);</span><br><span class="line">    int fb &#x3D; getf(b);</span><br><span class="line">    if (fa !&#x3D; fb)</span><br><span class="line">    &#123;</span><br><span class="line">        pre[fa] &#x3D; fb;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while (~scanf(&quot;%d%d&quot;, &amp;n, &amp;r), n)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; r; i++)</span><br><span class="line">            scanf(&quot;%d%d%d&quot;, &amp;edge[i].s, &amp;edge[i].e, &amp;edge[i].v);</span><br><span class="line">        sort(edge + 1, edge + r + 1, cmp);</span><br><span class="line">        int ans &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; r; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (Kruskal(edge[i].s, edge[i].e))</span><br><span class="line">                ans +&#x3D; edge[i].v;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Prim算法详解及模板与例题"><a href="#Prim算法详解及模板与例题" class="headerlink" title="Prim算法详解及模板与例题"></a>Prim算法详解及模板与例题</h2><h3 id="Prim算法简介"><a href="#Prim算法简介" class="headerlink" title="Prim算法简介"></a>Prim算法简介</h3><p><strong>时间复杂度：O（N^2）（N为顶点数）<br>prim算法又称“加点法”，用于边数较多的带权无向连通图<br>方法：每次找与之连线权值最小的顶点，将该点加入最小生成树集合中<br>注意：相同权值任选其中一个即可，但是不允许出现闭合回路的情况。</strong></p><h3 id="Prim算法图解"><a href="#Prim算法图解" class="headerlink" title="Prim算法图解"></a>Prim算法图解</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwODIwMTEzODU0ODA3?x-oss-process=image/format,png" alt="tupian1"></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwODIwMTEzOTA1MTQ0?x-oss-process=image/format,png" alt="tupian2"></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwODIwMTEzOTEzODk1?x-oss-process=image/format,png" alt="tupian3"></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwODIwMTEzOTIxMDQ3?x-oss-process=image/format,png" alt="tupian4"></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwODIwMTEzOTI5Mjcz?x-oss-process=image/format,png" alt="tupian5"></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwODIwMTEzOTM4NDI0?x-oss-process=image/format,png" alt="tupian6"></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwODIwMTEzOTQ2MTQx?x-oss-process=image/format,png" alt="tupian7"></p><h3 id="Prim算法代码详解及模板"><a href="#Prim算法代码详解及模板" class="headerlink" title="Prim算法代码详解及模板"></a>Prim算法代码详解及模板</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxx &#x3D; 210;</span><br><span class="line">const int mod &#x3D; 10007;</span><br><span class="line">const int inf &#x3D; 0x3f3f3f3f;</span><br><span class="line">const double eps &#x3D; 1e-8;</span><br><span class="line">using namespace std;</span><br><span class="line">int mapp[maxx][maxx]; &#x2F;&#x2F;存图</span><br><span class="line">int dis[maxx];        &#x2F;&#x2F;记录任意一点到这个点的最近距离</span><br><span class="line">bool vis[maxx];       &#x2F;&#x2F;用来标记0和1  表示这个点是否被选择过</span><br><span class="line">int n;</span><br><span class="line">void Prim()</span><br><span class="line">&#123;</span><br><span class="line">    int sum &#x3D; 0;</span><br><span class="line">    int now;</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#x2F;&#x2F;初始化</span><br><span class="line">    &#123;</span><br><span class="line">        dis[i] &#x3D; inf;</span><br><span class="line">        vis[i] &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#x2F;&#x2F;选择1为起始点，初始化</span><br><span class="line">        dis[i] &#x3D; mapp[1][i];</span><br><span class="line">    dis[1] &#x3D; 0;                 &#x2F;&#x2F;起点的上一个节点没有节点，所以为0</span><br><span class="line">    vis[1] &#x3D; true;              &#x2F;&#x2F;定义起点已经加入了最小生成树</span><br><span class="line">    for (int i &#x3D; 1; i &lt; n; i++) &#x2F;&#x2F;循环找最小边，循环n-1次</span><br><span class="line">    &#123;</span><br><span class="line">        now &#x3D; inf;</span><br><span class="line">        int minn &#x3D; inf;</span><br><span class="line">        for (int j &#x3D; 1; j &lt;&#x3D; n; j++) &#x2F;&#x2F;找dis最小的节点并加入最小生成树</span><br><span class="line">        &#123;</span><br><span class="line">            if (!vis[j] &amp;&amp; dis[j] &lt; minn)</span><br><span class="line">            &#123;</span><br><span class="line">                now &#x3D; j;&#x2F;&#x2F;找出最小的顶点</span><br><span class="line">                minn &#x3D; dis[j];&#x2F;&#x2F;找出权值最短的路径长度</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (now &#x3D;&#x3D; inf)</span><br><span class="line">            break; &#x2F;&#x2F;防止不成图</span><br><span class="line">        vis[now] &#x3D; true;</span><br><span class="line">        sum +&#x3D; minn;&#x2F;&#x2F;求和</span><br><span class="line">        for (int j &#x3D; 1; j &lt;&#x3D; n; j++) &#x2F;&#x2F;添入新点后更新最小距离</span><br><span class="line">        &#123;</span><br><span class="line">            if (!vis[j] &amp;&amp; dis[j] &gt; mapp[now][j])</span><br><span class="line">                dis[j] &#x3D; mapp[now][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;, sum);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while (~scanf(&quot;%d&quot;, &amp;n), n)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#x2F;&#x2F;初始化邻接矩阵</span><br><span class="line">            for (int j &#x3D; 1; j &lt;&#x3D; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if (i &#x3D;&#x3D; j)</span><br><span class="line">                    mapp[i][j] &#x3D; 0;</span><br><span class="line">                else</span><br><span class="line">                    mapp[i][j] &#x3D; inf;</span><br><span class="line">            &#125;</span><br><span class="line">        int a,b,c;</span><br><span class="line">        for (int i &#x3D; 1; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);</span><br><span class="line">            mapp[a][b] &#x3D; mapp[b][a] &#x3D; c;</span><br><span class="line">        &#125;</span><br><span class="line">        Prim();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Prim算法例题"><a href="#Prim算法例题" class="headerlink" title="Prim算法例题"></a>Prim算法例题</h3><p><strong>例题一：POJ-1251</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxx &#x3D; 210;</span><br><span class="line">const int mod &#x3D; 10007;</span><br><span class="line">const int inf &#x3D; 0x3f3f3f3f;</span><br><span class="line">const double eps &#x3D; 1e-8;</span><br><span class="line">using namespace std;</span><br><span class="line">int mapp[maxx][maxx];</span><br><span class="line">int dis[maxx];</span><br><span class="line">bool vis[maxx];</span><br><span class="line">int n;</span><br><span class="line">void Prim()</span><br><span class="line">&#123;</span><br><span class="line">    int sum &#x3D; 0;</span><br><span class="line">    int now;</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dis[i] &#x3D; inf;</span><br><span class="line">        vis[i] &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">        dis[i] &#x3D; mapp[1][i];</span><br><span class="line">    dis[1] &#x3D; 0;</span><br><span class="line">    vis[1] &#x3D; true;</span><br><span class="line">    for (int i &#x3D; 1; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        now &#x3D; inf;</span><br><span class="line">        int minn &#x3D; inf;</span><br><span class="line">        for (int j &#x3D; 1; j &lt;&#x3D; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (!vis[j] &amp;&amp; dis[j] &lt; minn)</span><br><span class="line">            &#123;</span><br><span class="line">                now &#x3D; j;</span><br><span class="line">                minn &#x3D; dis[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (now &#x3D;&#x3D; inf)</span><br><span class="line">            break;</span><br><span class="line">        vis[now] &#x3D; true;</span><br><span class="line">        sum +&#x3D; minn;</span><br><span class="line">        for (int j &#x3D; 1; j &lt;&#x3D; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (!vis[j] &amp;&amp; dis[j] &gt; mapp[now][j])</span><br><span class="line">                dis[j] &#x3D; mapp[now][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;, sum);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char a, b;</span><br><span class="line">    int num1, num2;</span><br><span class="line">    int x, y;</span><br><span class="line">    while (~scanf(&quot;%d&quot;, &amp;n), n)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">            for (int j &#x3D; 1; j &lt;&#x3D; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if (i &#x3D;&#x3D; j)</span><br><span class="line">                    mapp[i][j] &#x3D; 0;</span><br><span class="line">                else</span><br><span class="line">                    mapp[i][j] &#x3D; inf;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 1; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; a &gt;&gt; num1;</span><br><span class="line">            for (int j &#x3D; 1; j &lt;&#x3D; num1; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                cin &gt;&gt; b &gt;&gt; num2;</span><br><span class="line">                x &#x3D; a - 64;</span><br><span class="line">                y &#x3D; b - 64;</span><br><span class="line">                mapp[x][y] &#x3D; mapp[y][x] &#x3D; num2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Prim();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>例题二：Hihocoder-1097</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxx &#x3D; 10010;</span><br><span class="line">const int mod &#x3D; 10007;</span><br><span class="line">const int inf &#x3D; 0x3f3f3f3f;</span><br><span class="line">const double eps &#x3D; 1e-8;</span><br><span class="line">using namespace std;</span><br><span class="line">int mapp[maxx][maxx];</span><br><span class="line">int dis[maxx];</span><br><span class="line">bool vis[maxx];</span><br><span class="line">int n;</span><br><span class="line">void Prim()</span><br><span class="line">&#123;</span><br><span class="line">    int sum &#x3D; 0;</span><br><span class="line">    int now;</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dis[i] &#x3D; inf;</span><br><span class="line">        vis[i] &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">        dis[i] &#x3D; mapp[1][i];</span><br><span class="line">    dis[1] &#x3D; 0;</span><br><span class="line">    vis[1] &#x3D; true;</span><br><span class="line">    for (int i &#x3D; 1; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        now &#x3D; inf;</span><br><span class="line">        int minn &#x3D; inf;</span><br><span class="line">        for (int j &#x3D; 1; j &lt;&#x3D; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (!vis[j] &amp;&amp; dis[j] &lt; minn)</span><br><span class="line">            &#123;</span><br><span class="line">                now &#x3D; j;</span><br><span class="line">                minn &#x3D; dis[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (now &#x3D;&#x3D; inf)</span><br><span class="line">            break;</span><br><span class="line">        vis[now] &#x3D; true;</span><br><span class="line">        sum +&#x3D; minn;</span><br><span class="line">        for (int j &#x3D; 1; j &lt;&#x3D; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (!vis[j] &amp;&amp; dis[j] &gt; mapp[now][j])</span><br><span class="line">                dis[j] &#x3D; mapp[now][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;, sum);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while (~scanf(&quot;%d&quot;, &amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">            for (int j &#x3D; 1; j &lt;&#x3D; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if (i &#x3D;&#x3D; j)</span><br><span class="line">                    mapp[i][j] &#x3D; 0;</span><br><span class="line">                else</span><br><span class="line">                    mapp[i][j] &#x3D; inf;</span><br><span class="line">            &#125;</span><br><span class="line">        int a;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">            for (int j &#x3D; 1; j &lt;&#x3D; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                scanf(&quot;%d&quot;, &amp;a);</span><br><span class="line">                if (a &lt; mapp[i][j])</span><br><span class="line">                    mapp[i][j] &#x3D; mapp[j][i] &#x3D; a;</span><br><span class="line">            &#125;</span><br><span class="line">        Prim();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;因为之前4月份打了将近一个月的个人赛，有些以前学习过的算法已经忘了，所以重新再温习一遍。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法重温" scheme="https://stephencurry6666.github.io/categories/%E7%AE%97%E6%B3%95%E9%87%8D%E6%B8%A9/"/>
    
    
      <category term="最小生成树再温" scheme="https://stephencurry6666.github.io/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E5%86%8D%E6%B8%A9/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 625(Div.2)</title>
    <link href="https://stephencurry6666.github.io/2020/05/11/Codeforces%20625(Div.2)/"/>
    <id>https://stephencurry6666.github.io/2020/05/11/Codeforces%20625(Div.2)/</id>
    <published>2020-05-11T12:28:49.376Z</published>
    <updated>2020-05-11T12:59:49.089Z</updated>
    
    <content type="html"><![CDATA[<p><strong>A题</strong></p><p>题意：输入两组数，为1表示有该任务，0表示没有，现在由你定义每个任务的分数，使得最高分最小的情况下，第一个人的总分大于第二个人，如果无法满足，输出-1。</p><a id="more"></a><p>思路：这道题的话，先处理两个人的特有任务，如果第一个人特有的任务第二个人都有，那么一定无法满足，因为两个人任务的分数是相同的，第二个人特有的任务按照题目要求，应当为1分，第一个人的特有任务，按照第二个人特有任务的数量，平均分配即可。</p><p>AC代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxx &#x3D; 100010;</span><br><span class="line">const int inf &#x3D; 0x3f3f3f3f;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[maxx];</span><br><span class="line">int b[maxx];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    while (cin &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">            cin &gt;&gt; b[i];</span><br><span class="line">        int ans1 &#x3D; 0, ans2 &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (a[i] + b[i] &#x3D;&#x3D; 1)</span><br><span class="line">            &#123;</span><br><span class="line">                ans1 +&#x3D; a[i];</span><br><span class="line">                ans2 +&#x3D; b[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (ans1 &#x3D;&#x3D; 0)</span><br><span class="line">            cout &lt;&lt; &quot;-1&quot; &lt;&lt; endl;</span><br><span class="line">        else</span><br><span class="line">            cout &lt;&lt; (ans1 + ans2) &#x2F; ans1 &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>B题</strong></p><p>题意 ：有n个数，对于Ai和Aj这两个数，如果满足Ai-Aj=i-j，那么两个数就可以求和，输出整个数组能够求和的最大值。</p><p>思路：这道题的话，因为每个城市有beauty值b，可以相互连通的城市i和j之间 i-j==b[i]-b[j]，所以i-b[i]==j-b[j]，所以可以连通的所有城市i-b[i]都是相等的，所以我们记录可以给到每一个差值的beauty值之和再取max就可以了。</p><p>AC代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxx &#x3D; 200010;</span><br><span class="line">const int inf &#x3D; 0x3f3f3f3f;</span><br><span class="line">using namespace std;</span><br><span class="line">unordered_map&lt;ll, ll&gt; mp;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    ll a;</span><br><span class="line">    ll ans &#x3D; -1;</span><br><span class="line">    for (ll i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a;</span><br><span class="line">        mp[a - i] +&#x3D; a;</span><br><span class="line">        ans &#x3D; max(ans, mp[a - i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>C题</strong></p><p>题意：一个字符串，如果与某个位置相邻的字母，至少有一个比该位置的字母小1，那么该位置的字母就可以删掉，剩下的字母接上来，输出对于整个字符串，最多可以删多少个字母。</p><p>思路：这道题的话，直接暴力，不难想到先删字母大的，然后再删小的可以保证删的最多，所以就从 ‘z’ 遍历到 ‘a’， 一个一个删，当前字母不能删就往前循环。</p><p>AC代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxx &#x3D; 200010;</span><br><span class="line">const int inf &#x3D; 0x3f3f3f3f;</span><br><span class="line">using namespace std;</span><br><span class="line">string s;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    while (cin &gt;&gt; n &gt;&gt; s)</span><br><span class="line">    &#123;</span><br><span class="line">        for (char i &#x3D; &#39;z&#39;; i &gt;&#x3D; &#39;b&#39;; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            if (s.size() &#x3D;&#x3D; 1)</span><br><span class="line">                break;</span><br><span class="line">            while (1)</span><br><span class="line">            &#123;</span><br><span class="line">                if (s.size() &#x3D;&#x3D; 1)</span><br><span class="line">                    break;</span><br><span class="line">                int flag &#x3D; 1;</span><br><span class="line">                for (int j &#x3D; 0; j &lt; s.size(); j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (s[j] !&#x3D; i)</span><br><span class="line">                        continue;</span><br><span class="line">                    if (j &#x3D;&#x3D; 0)</span><br><span class="line">                    &#123;</span><br><span class="line">                        if (s[j + 1] &#x3D;&#x3D; i - 1)</span><br><span class="line">                        &#123;</span><br><span class="line">                            flag &#x3D; 0;</span><br><span class="line">                            s.erase(s.begin() + j, s.begin() + j + 1);</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else if (j &#x3D;&#x3D; s.size() - 1)</span><br><span class="line">                    &#123;</span><br><span class="line">                        if (s[j - 1] &#x3D;&#x3D; i - 1)</span><br><span class="line">                        &#123;</span><br><span class="line">                            flag &#x3D; 0;</span><br><span class="line">                            s.erase(s.begin() + j, s.begin() + j + 1);</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else</span><br><span class="line">                    &#123;</span><br><span class="line">                        if (s[j - 1] &#x3D;&#x3D; i - 1 || s[j + 1] &#x3D;&#x3D; i - 1)</span><br><span class="line">                        &#123;</span><br><span class="line">                            flag &#x3D; 0;</span><br><span class="line">                            s.erase(s.begin() + j, s.begin() + j + 1);</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (flag)</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; n - s.size() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;A题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;题意：输入两组数，为1表示有该任务，0表示没有，现在由你定义每个任务的分数，使得最高分最小的情况下，第一个人的总分大于第二个人，如果无法满足，输出-1。&lt;/p&gt;
    
    </summary>
    
    
      <category term="CF" scheme="https://stephencurry6666.github.io/categories/CF/"/>
    
    
      <category term="CF" scheme="https://stephencurry6666.github.io/tags/CF/"/>
    
  </entry>
  
  <entry>
    <title>再次温习并查集的一些思路</title>
    <link href="https://stephencurry6666.github.io/2020/05/08/%E5%86%8D%E6%AC%A1%E6%B8%A9%E4%B9%A0%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%B7%AF/"/>
    <id>https://stephencurry6666.github.io/2020/05/08/%E5%86%8D%E6%AC%A1%E6%B8%A9%E4%B9%A0%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%B7%AF/</id>
    <published>2020-05-08T07:20:46.538Z</published>
    <updated>2020-05-11T12:48:04.355Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>因为之前4月份打了将近一个月的个人赛，有些以前学习过的算法已经忘了，所以重新再温习一遍。</p><a id="more"></a><h2 id="普通并查集"><a href="#普通并查集" class="headerlink" title="普通并查集"></a>普通并查集</h2><p><strong>并查集（Union Find）是一种树型的数据结构，用于处理一些不相交集合（Disjoint Sets）的合并及查询问题。在一些有N个元素的集合应用问题中，我们通常是在开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中。</strong></p><p><strong>对于并查集的理解</strong></p><p>首先并查集是一种树型结构，树型结构，顾名思义就是存在着子节点和父节点。</p><p>所以我们先设一个数组pre[]，这个数组里面存放每个元素的父节点。然后这里借鉴大佬的例子来解释并查集的作用。</p><p>例：话说江湖上散落着各式各样的大侠，有上千个之多。他们没有什么正当职业，整天背着剑在外面走来走去，碰到和自己不是一路人的，就免不了要打一架。但大侠们有一个优点就是讲义气，绝对不打自己的朋友。而且他们信奉“朋友的朋友就是我的朋友”，只要是能通过朋友关系串联起来的，不管拐了多少个弯，都认为是自己人。这样一来，江湖上就形成了一个一个的帮派，通过两两之间的朋友关系串联起来。而不在同一个帮派的人，无论如何都无法通过朋友关系连起来，于是就可以放心往死了打。但是两个原本互不相识的人，如何判断是否属于一个朋友圈呢？</p><p>我们可以在每个朋友圈内推举出一个比较有名望的人，作为该圈子的代表人物。这样，每个圈子就可以这样命名“中国同胞队”美国同胞队”……两人只要互相对一下自己的队长是不是同一个人，就可以确定敌友关系了。</p><p>但是还有问题啊，大侠们只知道自己直接的朋友是谁，很多人压根就不认识队长要判断自己的队长是谁，只能漫无目的的通过朋友的朋友关系问下去：“你是不是队长？你是不是队长？”这样，想打一架得先问个几十年，饿都饿死了，受不了。这样一来，队长面子上也挂不住了，不仅效率太低，还有可能陷入无限循环中。于是队长下令，重新组队。队内所有人实行分等级制度，形成树状结构，我队长就是根节点，下面分别是二级队员、三级队员。每个人只要记住自己的上级是谁就行了。遇到判断敌友的时候，只要一层层向上问，直到最高层，就可以在短时间内确定队长是谁了。由于我们关心的只是两个人之间是否是一个帮派的，至于他们是如何通过朋友关系相关联的，以及每个圈子内部的结构是怎样的，甚至队长是谁，都不重要了。所以我们可以放任队长随意重新组队，只要不搞错敌友关系就好了。于是，门派产生了。</p><p><img src="https://img-blog.csdnimg.cn/20190301210948491.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg0NjEzOQ==,size_16,color_FFFFFF,t_70" alt="bcj"></p><p>下面我们来看并查集的实现。 int pre[1000]; 这个数组，记录了每个大侠的上级是谁。大侠们从1或者0开始编号（依据题意而定），pre[15]=3就表示15号大侠的上级是3号大侠。如果一个人的上级就是他自己，那说明他就是掌门人了，查找到此为止。也有孤家寡人自成一派的，比如欧阳锋，那么他的上级就是他自己。每个人都只认自己的上级。比如胡青牛同学只知道自己的上级是杨左使。张无忌是谁？不认识！要想知道自己的掌门是谁，只能一级级查上去。<br>getf这个函数就是找掌门用的，意义再清楚不过了（路径压缩算法先不论，后面再说）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int getf(int a)&#x2F;&#x2F;查找根节点</span><br><span class="line">&#123;</span><br><span class="line">    if (pre[a] &#x3D;&#x3D; a)&#x2F;&#x2F;我的上级不是掌门</span><br><span class="line">        return a;</span><br><span class="line">    int tmp &#x3D; getf(pre[a]);&#x2F;&#x2F;我就找他的上级，直到掌门出现</span><br><span class="line">    return pre[a] &#x3D; tmp;&#x2F;&#x2F;掌门出现</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看看mer函数，就是在两个点之间连一条线，这样一来，原先它们所在的两个板块的所有点就都可以互通了。这在图上很好办，画条线就行了。但我们现在是用并查集来描述武林中的状况的，一共只有一个pre[]数组，该如何实现呢？ 还是举江湖的例子，假设现在武林中的形势如图所示。虚竹帅锅与周芷若MM是我非常喜欢的两个人物，他们的终极boss分别是玄慈方丈和灭绝师太，那明显就是两个阵营了。我不希望他们互相打架，就对他俩说：“你们两位拉拉勾，做好朋友吧。”他们看在我的面子上，同意了。这一同意可非同小可，整个少林和峨眉派的人就不能打架了。这么重大的变化，可如何实现呀，要改动多少地方？其实非常简单，我对玄慈方丈说：“大师，麻烦你把你的上级改为灭绝师太吧。这样一来，两派原先的所有人员的终极boss都是师太，那还打个球啊！反正我们关心的只是连通性，门派内部的结构不要紧的。”玄慈一听肯定火大了：“我靠，凭什么是我变成她手下呀，怎么不反过来？我抗议！”于是，两人相约一战，杀的是天昏地暗，风云为之变色啊，但是啊，这场战争终究会有胜负，胜者为王。弱者就被吞并了。反正谁加入谁效果是一样的，门派就由两个变成一个了。这段函数的意思明白了吧？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void mer(int a, int b)&#x2F;&#x2F;虚竹和周芷若做朋友</span><br><span class="line">&#123;</span><br><span class="line">    int fa &#x3D; getf(a);&#x2F;&#x2F;我老大是玄慈</span><br><span class="line">    int fb &#x3D; getf(b);&#x2F;&#x2F;我老大是灭绝</span><br><span class="line">    if (fa !&#x3D; fb)</span><br><span class="line">        pre[fa] &#x3D; fb;&#x2F;&#x2F;打一仗，谁赢就当对方老大</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看看路径压缩算法。建立门派的过程是用mer函数两个人两个人地连接起来的，谁当谁的手下完全随机。最后的树状结构会变成什么样，我也无法预知，一字长蛇阵也有可能。这样查找的效率就会比较低下。最理想的情况就是所有人的直接上级都是掌门，一共就两级结构，只要找一次就找到掌门了。哪怕不能完全做到，也最好尽量接近。这样就产生了路径压缩算法。<br>设想这样一个场景：两个互不相识的大侠碰面了，想知道能不能干一场。 于是赶紧打电话问自己的上级：“你是不是掌门？” 上级说：“我不是呀，我的上级是谁谁谁，你问问他看看。” 一路问下去，原来两人的最终boss都是东厂曹公公。 “哎呀呀，原来是自己人，有礼有礼，在下三营六组白面葫芦娃!” “幸会幸会，在下九营十八组仙子狗尾巴花！” 两人高高兴兴地手拉手喝酒去了。 “等等等等，两位大侠请留步，还有事情没完成呢！”我叫住他俩。 “哦，对了，还要做路径压缩。”两人醒悟。 白面葫芦娃打电话给他的上级六组长：“组长啊，我查过了，其实偶们的掌门是曹公公。不如偶们一起结拜在曹公公手下吧，省得级别太低，以后查找掌门麻烦。” “唔，有道理。” 白面葫芦娃接着打电话给刚才拜访过的三营长……仙子狗尾巴花也做了同样的事情。 这样，查询中所有涉及到的人物都聚集在曹公公的直接领导下。每次查询都做了优化处理，所以整个门派树的层数都会维持在比较低的水平上。路径压缩的代码，看得懂很好，看不懂可以自己模拟一下，很简单的一个递归而已。总之它所实现的功能就是这么个意思。</p><p><img src="https://img-blog.csdnimg.cn/20190301211224963.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg0NjEzOQ==,size_16,color_FFFFFF,t_70" alt="aa"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int tmp &#x3D; getf(pre[a]);&#x2F;&#x2F;路径压缩</span><br><span class="line">    return pre[a] &#x3D; tmp;</span><br></pre></td></tr></table></figure><p><strong>要实现这个例子的代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxx &#x3D; 10010;</span><br><span class="line">const int inf &#x3D; 0x3f3f3f3f;</span><br><span class="line">using namespace std;</span><br><span class="line">int pre[maxx];</span><br><span class="line">int n, m, ans;</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt;&#x3D; n; i++)</span><br><span class="line">        pre[i] &#x3D; i;</span><br><span class="line">&#125;</span><br><span class="line">int getf(int a)</span><br><span class="line">&#123;</span><br><span class="line">    if (a &#x3D;&#x3D; pre[a])</span><br><span class="line">        return a;</span><br><span class="line">    return pre[a] &#x3D; getf(pre[a]);</span><br><span class="line">&#125;</span><br><span class="line">int mer(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    int fa &#x3D; getf(a);</span><br><span class="line">    int fb &#x3D; getf(b);</span><br><span class="line">    if (fa !&#x3D; fb)</span><br><span class="line">    &#123;</span><br><span class="line">        pre[fa] &#x3D; fb;</span><br><span class="line">        ans--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while (~scanf(&quot;%d%d&quot;, &amp;n, &amp;m), n)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        int a, b;</span><br><span class="line">        ans &#x3D; n - 1;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d%d&quot;, &amp;a, &amp;b);</span><br><span class="line">            mer(a, b);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="带权并查集"><a href="#带权并查集" class="headerlink" title="带权并查集"></a>带权并查集</h2><p><strong>就像名字一样，带权并查集就是要多维护一个权值数组;和普通的并查集大同小异,用pre[]数组存父节点，v存当前结点到父亲结点的权值。</strong></p><p>首先是初始化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt;&#x3D; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pre[i] &#x3D; i;</span><br><span class="line">        v[i] &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20191012205623707.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MDc3NDU1,size_16,color_FFFFFF,t_70" alt="tu"></p><p>没有进行状态压缩的时候可以知道，pre[3]=2,pre[2]=1,pre[1]=1;v[3]=4;v[2]=3;v[1]=0;</p><p><img src="https://img-blog.csdnimg.cn/20191012205953664.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MDc3NDU1,size_16,color_FFFFFF,t_70" alt="tu"></p><p>状态压缩后，pre[3]=1;v[3]=7;其他不变;所以可以得出代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int getf(int a)</span><br><span class="line">&#123;</span><br><span class="line">    if(pre[a]&#x3D;&#x3D;a)</span><br><span class="line">        return a;</span><br><span class="line">    int tmp&#x3D;getf(pre[a]);  &#x2F;&#x2F;这里不能够没有，因为在递归的过程中pre[a]的值会被改变，会影响v[a]的更新</span><br><span class="line">    v[a]&#x3D;v[a]+v[pre[a]];</span><br><span class="line">    return pre[a]&#x3D;tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于合并两个集合，是将元素间关系看成向量<br>我们可以列出向量图:</p><p><img src="https://img-blog.csdnimg.cn/20191012211424881.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MDc3NDU1,size_16,color_FFFFFF,t_70" alt="tu"></p><p>我们假设上图中2-&gt;1表示1比2大3，同理得其他的，一开始1，2处于一个集合,3,处于另一个集合，现在要将这两个集合合并,那么1-&gt;4得权值就可以得出，根据平行四边形法则,v[1]=(-v[2]+v+v[3])=8(其中v表示3比2大多少有，也就是2-&gt;3)，就是说4比1大8，由此我们便得到了如何将两个带权集合合并。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void mer(int a, int b, int s)</span><br><span class="line">&#123;</span><br><span class="line">    int fa &#x3D; getf(a);</span><br><span class="line">    int fb &#x3D; getf(b);</span><br><span class="line">    if (fa !&#x3D; fb)</span><br><span class="line">    &#123;</span><br><span class="line">        pre[fa] &#x3D; fb;</span><br><span class="line">        v[fa] &#x3D; -v[a] + s + v[b];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>例题一：HihoCoder-1515</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxx &#x3D; 100010;</span><br><span class="line">const int inf &#x3D; 0x3f3f3f3f;</span><br><span class="line">using namespace std;</span><br><span class="line">int pre[maxx], v[maxx];</span><br><span class="line">int n, m, q;</span><br><span class="line">int x, y, s;</span><br><span class="line">int ans;</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt;&#x3D; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pre[i] &#x3D; i;</span><br><span class="line">        v[i] &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int getf(int a)</span><br><span class="line">&#123;</span><br><span class="line">    if (pre[a] &#x3D;&#x3D; a)</span><br><span class="line">        return a;</span><br><span class="line">    int tmp &#x3D; getf(pre[a]);</span><br><span class="line">    v[a] &#x3D; v[a] + v[pre[a]];</span><br><span class="line">    return pre[a] &#x3D; tmp;</span><br><span class="line">&#125;</span><br><span class="line">void mer(int a, int b, int s)</span><br><span class="line">&#123;</span><br><span class="line">    int fa &#x3D; getf(a);</span><br><span class="line">    int fb &#x3D; getf(b);</span><br><span class="line">    if (fa !&#x3D; fb)</span><br><span class="line">    &#123;</span><br><span class="line">        pre[fa] &#x3D; fb;</span><br><span class="line">        v[fa] &#x3D; -v[a] + s + v[b];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">inline void read(T &amp;res) &#x2F;&#x2F;快速读入模板</span><br><span class="line">&#123;</span><br><span class="line">    char c;</span><br><span class="line">    T flag &#x3D; 1;</span><br><span class="line">    while ((c &#x3D; getchar()) &lt; &#39;0&#39; || c &gt; &#39;9&#39;)</span><br><span class="line">        if (c &#x3D;&#x3D; &#39;-&#39;)</span><br><span class="line">            flag &#x3D; -1;</span><br><span class="line">    res &#x3D; c - &#39;0&#39;;</span><br><span class="line">    while ((c &#x3D; getchar()) &gt;&#x3D; &#39;0&#39; &amp;&amp; c &lt;&#x3D; &#39;9&#39;)</span><br><span class="line">        res &#x3D; res * 10 + c - &#39;0&#39;;</span><br><span class="line">    res *&#x3D; flag;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    read(n), read(m), read(q);</span><br><span class="line">    init();</span><br><span class="line">    while (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        read(x), read(y), read(s);</span><br><span class="line">        mer(x, y, s);</span><br><span class="line">    &#125;</span><br><span class="line">    while (q--)</span><br><span class="line">    &#123;</span><br><span class="line">        read(x), read(y);</span><br><span class="line">        if (getf(x) &#x3D;&#x3D; getf(y))</span><br><span class="line">            printf(&quot;%d\n&quot;, v[x] - v[y]);</span><br><span class="line">        else</span><br><span class="line">            printf(&quot;-1\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>例题二：HDU-3038</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxx &#x3D; 200010;</span><br><span class="line">const int inf &#x3D; 0x3f3f3f3f;</span><br><span class="line">using namespace std;</span><br><span class="line">int pre[maxx], v[maxx];</span><br><span class="line">int n, m;</span><br><span class="line">int x, y, s;</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt;&#x3D; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pre[i] &#x3D; i;</span><br><span class="line">        v[i] &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int getf(int a)</span><br><span class="line">&#123;</span><br><span class="line">    if (pre[a] &#x3D;&#x3D; a)</span><br><span class="line">        return a;</span><br><span class="line">    int tmp &#x3D; getf(pre[a]);</span><br><span class="line">    v[a] &#x3D; v[a] + v[pre[a]];</span><br><span class="line">    return pre[a] &#x3D; tmp;</span><br><span class="line">&#125;</span><br><span class="line">int mer(int a, int b, int s)</span><br><span class="line">&#123;</span><br><span class="line">    int fa &#x3D; getf(a);</span><br><span class="line">    int fb &#x3D; getf(b);</span><br><span class="line">    if (fa &#x3D;&#x3D; fb)</span><br><span class="line">        return v[a] !&#x3D; v[b] + s;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        pre[fa] &#x3D; fb;</span><br><span class="line">        v[fa] &#x3D; -v[a] + v[b] + s;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    while (~scanf(&quot;%d%d&quot;, &amp;n, &amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        int ans &#x3D; 0;</span><br><span class="line">        while (m--)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;s);</span><br><span class="line">            y++;</span><br><span class="line">            if (mer(x, y, s))</span><br><span class="line">                ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="种类并查集"><a href="#种类并查集" class="headerlink" title="种类并查集"></a>种类并查集</h2><p><strong>种类并查集，顾名思义，在所给数据中或多或少会带有种类的区别。</strong></p><p>种类并查集延用了带权并查集的特性,还是相当于维护了一个权值，只不过这个权值带有一定的意义，拿例题“食物链”来说，我们指定x-&gt;y表示与y是x的父节点，即pre[x]=y;我们用rela[i]来表示节点i和它的父节点之间的关系，规定rela[x]=0表示x,y是同类，rela[x]=1表示y吃x，rela[x]=2表示x吃y，那么我们可以根据这些权值推断出两个结点之间实际的关系。</p><p><img src="https://img-blog.csdnimg.cn/20191022194850194.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MDc3NDU1,size_16,color_FFFFFF,t_70" alt="tu"></p><p>比如现在告诉你3-&gt;1的值为1（1吃3），而2-&gt;1的值为2（2吃1），那么我们根据题意就可以得出3吃2，即2-&gt;3为1,也就得到了上图的关系。假设现在再来一句话说2吃3那么就是错的。问题是如何得到这样的关系。对于给定的x,y和它们之间的关系,我们分两种情况<br>1.假设pre[x]==pre[y]，就是说它们是一个集合的，现在的任务就是把它们推出它们之间的关系，也就是上图的情况，1为父节点，先开始的条件有3-&gt;1的为1,2-&gt;1=2，如何得到2-&gt;3=1呢？同样我们可以用向量的方法：2-&gt;3=2-&gt;1 - 1-&gt;3(添负号，箭头反向)=2-1=1；这样我们得到了2-&gt;3的值为1（这里在想一下，如果我们想得到假设之前我们已经建立了2-&gt;1的关系，现在又给出2-&gt;1的关系，如何得到到给出的关系对不对呢；我们只需要把上图的3换成1就可以了，同时3-&gt;1=1就变成了1-&gt;1=0同样的方法）<br>2.假设pre[x]!=pre[y]，x,y不在同一个集合也就是要联合x,y两个集合,已知y-&gt;x=1,x-&gt;fx=1,y-&gt;fy=0</p><p><img src="https://img-blog.csdnimg.cn/20191022200751469.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MDc3NDU1,size_16,color_FFFFFF,t_70" alt="tu"></p><p>同样的用向量就可以了fy-&gt;fx=-(y-&gt;fy)+y-&gt;x+x-&gt;fx=1+1=2;(已知fx吃x，x吃y，y和fy是同类，所以由题意可知fy吃fx),这样我们就可以将两个集合联合在一起并且维护好关系。<br>值得注意的是，这些操作对向量方向的要求很高，不能弄错方向，比如联合两个集合的时候,我们求的是fy-&gt;fx，也就是fy是儿子，fx是父亲,那么我们就应该pre[fy]=fx；而不是pre[fx]=fy;同样我们求的关系是rela[fy]的值，而不是rela[fx]，如果箭头反向，这些操作都要变.</p><p><strong>给出食物链这题的代码(POJ-1182)：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxx &#x3D; 100010;</span><br><span class="line">const int inf &#x3D; 0x3f3f3f3f;</span><br><span class="line">using namespace std;</span><br><span class="line">int pre[maxx], rela[maxx];</span><br><span class="line">int n, k;</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt;&#x3D; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pre[i] &#x3D; i;</span><br><span class="line">        rela[i] &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int getf(int a)</span><br><span class="line">&#123;</span><br><span class="line">    if (pre[a] &#x3D;&#x3D; a)</span><br><span class="line">        return a;</span><br><span class="line">    int tmp &#x3D; getf(pre[a]);</span><br><span class="line">    rela[a] &#x3D; (rela[a] + rela[pre[a]] + 3) % 3;</span><br><span class="line">    return pre[a] &#x3D; tmp;</span><br><span class="line">&#125;</span><br><span class="line">int mer(int c, int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    int fa &#x3D; getf(a);</span><br><span class="line">    int fb &#x3D; getf(b);</span><br><span class="line">    if (fa &#x3D;&#x3D; fb)</span><br><span class="line">    &#123;</span><br><span class="line">        if (c &#x3D;&#x3D; 1 &amp;&amp; rela[a] &#x3D;&#x3D; rela[b])</span><br><span class="line">            return 1;</span><br><span class="line">        else if (c &#x3D;&#x3D; 2 &amp;&amp; (rela[a] - rela[b] + 3) % 3 &#x3D;&#x3D; c - 1)</span><br><span class="line">            return 1;</span><br><span class="line">        else</span><br><span class="line">            return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        pre[fb] &#x3D; fa;</span><br><span class="line">        rela[fb] &#x3D; (-rela[b] + rela[a] - c + 1 + 3) % 3;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;n, &amp;k);</span><br><span class="line">    init();</span><br><span class="line">    int d, x, y;</span><br><span class="line">    int sum &#x3D; 0;</span><br><span class="line">    while (k--)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;, &amp;d, &amp;x, &amp;y);</span><br><span class="line">        if (x &gt; n || y &gt; n)</span><br><span class="line">            sum++;</span><br><span class="line">        else if (d &#x3D;&#x3D; 2 &amp;&amp; x &#x3D;&#x3D; y)</span><br><span class="line">            sum++;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            if (!mer(d, x, y))</span><br><span class="line">                sum++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;, sum);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>例题二：POJ-1703</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxx &#x3D; 100010;</span><br><span class="line">const int inf &#x3D; 0x3f3f3f3f;</span><br><span class="line">using namespace std;</span><br><span class="line">int pre[maxx * 2];</span><br><span class="line">int n, m;</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt;&#x3D; 2 * n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pre[i] &#x3D; i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int getf(int a)</span><br><span class="line">&#123;</span><br><span class="line">    if (pre[a] &#x3D;&#x3D; a)</span><br><span class="line">        return a;</span><br><span class="line">    int tmp &#x3D; getf(pre[a]);</span><br><span class="line">    return pre[a] &#x3D; tmp;</span><br><span class="line">&#125;</span><br><span class="line">void mer(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    int fa &#x3D; getf(a);</span><br><span class="line">    int fb &#x3D; getf(b);</span><br><span class="line">    if (fa !&#x3D; fb)</span><br><span class="line">        pre[fa] &#x3D; fb;</span><br><span class="line">&#125;</span><br><span class="line">int same(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    return getf(a) &#x3D;&#x3D; getf(b);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int t;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;t);</span><br><span class="line">    while (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line">        init();</span><br><span class="line">        char s;</span><br><span class="line">        int a, b;</span><br><span class="line">        while (m--)</span><br><span class="line">        &#123;</span><br><span class="line">            getchar();</span><br><span class="line">            scanf(&quot;%c%d%d&quot;, &amp;s, &amp;a, &amp;b);</span><br><span class="line">            if (s &#x3D;&#x3D; &#39;D&#39;)</span><br><span class="line">            &#123;</span><br><span class="line">                mer(a, b + n);</span><br><span class="line">                mer(b, a + n);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                if (same(a, b))</span><br><span class="line">                &#123;</span><br><span class="line">                    printf(&quot;In the same gang.\n&quot;);</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                else if (same(a, b + n))</span><br><span class="line">                &#123;</span><br><span class="line">                    printf(&quot;In different gangs.\n&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    printf(&quot;Not sure yet.\n&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;因为之前4月份打了将近一个月的个人赛，有些以前学习过的算法已经忘了，所以重新再温习一遍。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法重温" scheme="https://stephencurry6666.github.io/categories/%E7%AE%97%E6%B3%95%E9%87%8D%E6%B8%A9/"/>
    
    
      <category term="并查集再温" scheme="https://stephencurry6666.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%86%8D%E6%B8%A9/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE篇-Day2笔记</title>
    <link href="https://stephencurry6666.github.io/2020/05/05/JavaSE-Day(2)%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://stephencurry6666.github.io/2020/05/05/JavaSE-Day(2)%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-05-05T07:12:42.825Z</published>
    <updated>2020-05-06T08:20:56.884Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java语言基础"><a href="#Java语言基础" class="headerlink" title="Java语言基础"></a>Java语言基础</h1><h2 id="Java基础语法"><a href="#Java基础语法" class="headerlink" title="Java基础语法"></a>Java基础语法</h2><h3 id="1-关键字"><a href="#1-关键字" class="headerlink" title="1.关键字"></a>1.关键字</h3><a id="more"></a><p><strong>关键字概述：</strong><br>被Java语言赋予特定含义的单词。</p><p><strong>关键字特点：</strong><br>组成关键字的字母全部小写。</p><p><strong>注意事项：</strong><br>goto和const是保留字，在一般的高级Java编译器中，针对关键字都有特殊的颜色标记。</p><ul><li><strong>Java关键字</strong></li></ul><p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1588673781789&amp;di=405fa28b84d8a8b0464f054e43655198&amp;imgtype=0&amp;src=http%3A%2F%2Fpic4.zhimg.com%2Fv2-b1d047a34f15efeabd5211fd54f73b0b_b.jpg" alt="Java关键字"></p><h3 id="2-标识符"><a href="#2-标识符" class="headerlink" title="2.标识符"></a>2.标识符</h3><p><strong>标识符概述：</strong><br>就是给类，接口，方法，变量等起名字时使用的字符序列</p><p><strong>组成规则：</strong></p><ul><li><strong>英文大小写字母</strong></li><li><strong>数字字符</strong></li><li><strong>$和_</strong></li></ul><p><strong>注意事项：</strong></p><ul><li><strong>不能以数字开头</strong></li><li><strong>不能是Java中的关键字</strong></li><li><strong>区分大小写</strong></li></ul><h3 id="3-标识符的常见命名规则"><a href="#3-标识符的常见命名规则" class="headerlink" title="3.标识符的常见命名规则"></a>3.标识符的常见命名规则</h3><p><strong>注意事项：</strong><br>见名知意</p><ul><li><strong>举例：我要定义一个学生类</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Student &#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>包：</strong><br>其实就是文件夹，用于把相同的类名进行区分，全部小写</p><ul><li><strong>单级：liuyi</strong></li><li><strong>多级：cn.itcast</strong></li></ul><p><strong>类或者接口：</strong></p><ul><li><strong>一个单词：单词的首字母必须大写,举例：Student，Dog</strong></li><li><strong>多个单词：每个单词的首字母必须大写，举例：HelloWorld，StudentName</strong></li></ul><p><strong>方法或者变量：</strong></p><ul><li><strong>一个单词：单词的首字母小写，举例：main，age</strong></li><li><strong>多个单词：从第二个单词开始，每个单词的首字母大写，举例：studentAge,showAllNames</strong></li></ul><p><strong>常量：</strong></p><ul><li><strong>一个单词组成：全部大写，举例：PI</strong></li><li><strong>多个单词组成：每个字母都大写，用_隔开，举例：STUDENT_MAX_AGE</strong></li></ul><h3 id="4-注释概述及其分类"><a href="#4-注释概述及其分类" class="headerlink" title="4.注释概述及其分类"></a>4.注释概述及其分类</h3><p><strong>注释概述：</strong><br>用于解释说明的文字</p><p><strong>Java中注释分类格式：</strong></p><ul><li><strong>单行注释：格式：//注释文字</strong></li><li><strong>多行注释：格式：/星 注释文字 星/，注意：多行不可以嵌套使用，而单行是可以的</strong></li><li><strong>文档注释：格式：/星星 注释文字 星/</strong></li></ul><h3 id="5-HelloWorld案例加入注释"><a href="#5-HelloWorld案例加入注释" class="headerlink" title="5.HelloWorld案例加入注释"></a>5.HelloWorld案例加入注释</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> 需求：我准备写一个java程序，把&quot;HelloWorld&quot;这句话输出在控制台</span><br><span class="line"></span><br><span class="line">分析：</span><br><span class="line">A:要写一个Java程序，必须定义类</span><br><span class="line">B:把数据能够输出，说明我们的程序是可以独立运行的，而程序要独立运行，必须定义main方法</span><br><span class="line">C:把数据输出在控制台，必须使用输出语句</span><br><span class="line">实现：</span><br><span class="line">A:java语言提供了一个关键字：class用来定义类，后面跟的是类名</span><br><span class="line">B:main方法的格式是固定的：</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">C:输出语句的格式是固定的：</span><br><span class="line">System.out.println(&quot;HelloWorld&quot;);</span><br><span class="line">&quot;HelloWorld&quot;这个内容是可以改变的</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;这是我的HelloWorld案例</span><br><span class="line">class HelloWorld &#123;</span><br><span class="line">&#x2F;*</span><br><span class="line">为了程序能够独立运行，定义main方法</span><br><span class="line">main方法是程序的入口</span><br><span class="line">被jvm自动调用</span><br><span class="line">*&#x2F;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">  &#x2F;&#x2F;为了把数据显示在控制台，我们就使用了输出语句</span><br><span class="line"> System.out.println(&quot;HelloWorld&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-注释的作用"><a href="#6-注释的作用" class="headerlink" title="6.注释的作用"></a>6.注释的作用</h3><p>略过，在Eclipse Jee 2018-12程序中编写Java代码时，有错误的话，编译器会提示。</p><h3 id="7-常量的概述和使用"><a href="#7-常量的概述和使用" class="headerlink" title="7.常量的概述和使用"></a>7.常量的概述和使用</h3><p><strong>常量概述：</strong><br>在程序执行的过程中其值不可以发生改变</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">    常量：</span><br><span class="line">        在程序执行过程中，其值不发生改变的量。</span><br><span class="line"></span><br><span class="line">    分类：</span><br><span class="line">        A:字面值常量</span><br><span class="line">        B:自定义常量(后面讲)</span><br><span class="line"></span><br><span class="line">    字面值常量</span><br><span class="line">        A:字符串常量  用双引号括起来的内容。</span><br><span class="line">            举例：&quot;hello&quot;,&quot;world&quot;,&quot;HelloWorld&quot;</span><br><span class="line">        B:整数常量   所有的整数</span><br><span class="line">            举例：100,200</span><br><span class="line">        C:小数常量   所有的小数</span><br><span class="line">            举例：10.23,110.11</span><br><span class="line">D:字符常量用单引号括起来的内容</span><br><span class="line">举例：&#39;a&#39;,&#39;A&#39;,&#39;0&#39;</span><br><span class="line">错误的：&#39;ab&#39;</span><br><span class="line">E:布尔常量比较特殊</span><br><span class="line">举例：true,false</span><br><span class="line">F:空常量后面讲</span><br><span class="line">举例：null</span><br><span class="line">*&#x2F;</span><br><span class="line">class ConstantDemo &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">&#x2F;&#x2F;字符串常量的输出</span><br><span class="line">System.out.println(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;整数常量的输出</span><br><span class="line">System.out.println(100);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;小数常量的输出</span><br><span class="line">System.out.println(100.10);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;字符常量的输出</span><br><span class="line">System.out.println(&#39;a&#39;);</span><br><span class="line">System.out.println(&#39;A&#39;);</span><br><span class="line">System.out.println(&#39;0&#39;);</span><br><span class="line">&#x2F;&#x2F;这个是有问题的</span><br><span class="line">&#x2F;&#x2F;System.out.println(&#39;ab&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;布尔常量的输出</span><br><span class="line">System.out.println(true);</span><br><span class="line">System.out.println(false);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-进制概述以及二进制、八进制、十六进制图解"><a href="#8-进制概述以及二进制、八进制、十六进制图解" class="headerlink" title="8.进制概述以及二进制、八进制、十六进制图解"></a>8.进制概述以及二进制、八进制、十六进制图解</h3><p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1588680207620&amp;di=5dc7fbed0760175d40d1bbb10baa7b8d&amp;imgtype=0&amp;src=http%3A%2F%2Fgss0.baidu.com%2F9fo3dSag_xI4khGko9WTAnF6hhy%2Fzhidao%2Fpic%2Fitem%2Fd439b6003af33a87736ff400c45c10385343b5ae.jpg" alt="进制"></p><p><strong>二进制-&gt;八进制：</strong><br>把二进制的数据，从右开始，每三位一组合，最左边不够的时候，补0。然后，分别计算出对应的十进制数值，最后，再把每个十进制的数据组合起来，就是一个八进制数据。</p><p><strong>二进制-&gt;十六进制：</strong><br>把二进制的数据，从右开始，每四位一组合，最左边不够的时候，补0。然后，分别计算出对应的十进制数值，最后，再把每个十进制的数据组合起来，就是一个十六进制数据。</p><p><strong>规则：进制越大，表现形式越短</strong></p><h3 id="9-不同进制数据的表现形式"><a href="#9-不同进制数据的表现形式" class="headerlink" title="9.不同进制数据的表现形式"></a>9.不同进制数据的表现形式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">不同进制的数据表现：</span><br><span class="line">二进制：由0，1组成。以0b开头。</span><br><span class="line">八进制：由0,1,...7组成。以0开头。</span><br><span class="line">十进制：由0,1,...9组成。默认整数是十进制。</span><br><span class="line">十六进制：由0,1,...9,a,b,c,d,e,f(大小写均可)组成。以0x开头。</span><br><span class="line">*&#x2F;</span><br><span class="line">class JinZhiDemo &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">System.out.println(100); &#x2F;&#x2F;十进制</span><br><span class="line"></span><br><span class="line">System.out.println(0b100); &#x2F;&#x2F;二进制</span><br><span class="line">System.out.println(0100); &#x2F;&#x2F;八进制</span><br><span class="line">System.out.println(0x100); &#x2F;&#x2F;十六进制</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-任意进制到十进制的转换"><a href="#10-任意进制到十进制的转换" class="headerlink" title="10.任意进制到十进制的转换"></a>10.任意进制到十进制的转换</h3><p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1588680802524&amp;di=c3fd9ec5b2d6bae9fefda7479f3c2742&amp;imgtype=0&amp;src=http%3A%2F%2Fwww.myexception.cn%2Fimg%2F2015%2F07%2F11%2F060509721.png" alt="转换"></p><p><strong>系数：每一个位上的数据值本身就是系数。</strong></p><p><strong>基数：x进制的基数就是x。</strong></p><p><strong>权：我们针对每一个位上的数据进行编号，从右边，并且是从0开始编号，这个编号就是该位上数据的权值。</strong></p><p><strong>PS：每一个位上的系数x基数^权次幂相加。</strong></p><h3 id="11-十进制到任意进制的转换"><a href="#11-十进制到任意进制的转换" class="headerlink" title="11.十进制到任意进制的转换"></a>11.十进制到任意进制的转换</h3><p><strong>方法：这个数对基数依次取余，将余数倒序输出，在倒序输出余数之前正序输出最后一次的商。（这个方法是很简单的一种方式，可以大大的节省时间）。</strong></p><p><strong>将十进制转成八进制：</strong><br>579 / 8 = 72　．．．3<br>72 / 8 =9　．．．0<br>9 / 8 =1　．．．1</p><p>先输出最后一次计算的商，然后倒序从下到上输出余数<br>八进制的 576 为　1103</p><h3 id="12-快速的进制转换法"><a href="#12-快速的进制转换法" class="headerlink" title="12.快速的进制转换法"></a>12.快速的进制转换法</h3><p><strong>8421码</strong></p><p><img src="https://img-blog.csdnimg.cn/20181213115022126.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjUxODA2Mg==,size_16,color_FFFFFF,t_70" alt="8421"></p><h3 id="13-原码、反码、补码的讲解"><a href="#13-原码、反码、补码的讲解" class="headerlink" title="13.原码、反码、补码的讲解"></a>13.原码、反码、补码的讲解</h3><p><strong>在探求为何机器要使用补码之前, 让我们先了解原码, 反码和补码的概念.对于一个数, 计算机要使用一定的编码方式进行存储. 原码, 反码, 补码是机器存储一个具体数字的编码方式。</strong></p><p><strong>原码：</strong><br>原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:</p><p>[+1]原 = 0000 0001</p><p>[-1]原 = 1000 0001</p><p>第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是:[1111 1111 , 0111 1111]即[-127 , 127]，原码是人脑最容易理解和计算的表示方式。</p><p><strong>反码：</strong><br>反码的表示方法是:正数的反码是其本身；负数的反码是在其原码的基础上, 符号位不变，其余各个位取反。</p><p>[+1] = [00000001]原 = [00000001]反</p><p>[-1] = [10000001]原 = [11111110]反</p><p>可见如果一个反码表示的是负数, 人脑无法直观的看出来它的数值. 通常要将其转换成原码再计算。</p><p><strong>补码：</strong><br>补码的表示方法是:正数的补码就是其本身；负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)。</p><p>[+1] = [00000001]原 = [00000001]反 = [00000001]补</p><p>[-1] = [10000001]原 = [11111110]反 = [11111111]补</p><p>对于负数, 补码表示方式也是人脑无法直观看出其数值的. 通常也需要转换成原码在计算其数值。</p><h3 id="14-变量的概述及格式"><a href="#14-变量的概述及格式" class="headerlink" title="14.变量的概述及格式"></a>14.变量的概述及格式</h3><p><strong>变量的概念：</strong></p><ul><li><p><strong>在程序执行的过程中，在某个范围内其值可以发生改变的量</strong></p></li><li><p><strong>从本质上讲，变量其实是内存中的一小块区域，使用变量名来访问这块区域，因此，每一个变量使用前必须要先申请（声明），然后必须进行赋值（填充内容），才能使用。</strong></p></li></ul><p><strong>变量定义格式：</strong></p><ul><li><strong>数据类型 变量名 = 初始化值;</strong></li></ul><p>注意：格式是固定的，记住格式，以不变应万变</p><h3 id="15-数据类型的概述和分类和定义不同数据类型的变量"><a href="#15-数据类型的概述和分类和定义不同数据类型的变量" class="headerlink" title="15.数据类型的概述和分类和定义不同数据类型的变量"></a>15.数据类型的概述和分类和定义不同数据类型的变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">数据类型：Java是一种强类型的语言，针对每一种数据都定义了明确的数据类型。</span><br><span class="line"></span><br><span class="line">数据类型分类：</span><br><span class="line">A:基本数据类型</span><br><span class="line">B:引用数据类型(类,接口,数值)</span><br><span class="line"></span><br><span class="line">基本数据类型:4类8种</span><br><span class="line">A:整数占用字节数</span><br><span class="line">byte1</span><br><span class="line">short2</span><br><span class="line">int4</span><br><span class="line">long8</span><br><span class="line"></span><br><span class="line">B:浮点数</span><br><span class="line">float 4</span><br><span class="line">double 8</span><br><span class="line"></span><br><span class="line">C:字符</span><br><span class="line">char2</span><br><span class="line">D:布尔</span><br><span class="line">boolean1</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">整数默认是int类型</span><br><span class="line">浮点数默认是double类型。</span><br><span class="line"></span><br><span class="line">长整型后缀用L或者l标记。建议使用L。</span><br><span class="line">单精度浮点数用F或者f标记。建议使用F。</span><br><span class="line">*&#x2F;</span><br><span class="line">class DataTypeDemo &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">&#x2F;&#x2F;定义变量的格式：</span><br><span class="line">&#x2F;&#x2F;数据类型 变量名 &#x3D; 初始化值;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;定义一个字节变量</span><br><span class="line">byte b &#x3D; 10;</span><br><span class="line">System.out.println(10);</span><br><span class="line">System.out.println(b);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;定义一个短整型变量</span><br><span class="line">short s &#x3D; 100;</span><br><span class="line">System.out.println(s);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;定义一个整型变量</span><br><span class="line">int i &#x3D; 1000;</span><br><span class="line">System.out.println(i);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;超过了int的范围</span><br><span class="line">&#x2F;&#x2F;int j &#x3D; 1000000000000;</span><br><span class="line">long j &#x3D; 1000000000000L;</span><br><span class="line">&#x2F;&#x2F;long j &#x3D; 100L;</span><br><span class="line">System.out.println(j);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;定义浮点数据变量</span><br><span class="line">float f &#x3D; 12.345F;</span><br><span class="line">System.out.println(f);</span><br><span class="line"></span><br><span class="line">double d &#x3D; 12.345;</span><br><span class="line">System.out.println(d);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;定义字符变量</span><br><span class="line">char ch &#x3D; &#39;a&#39;;</span><br><span class="line">System.out.println(ch);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;定义布尔变量</span><br><span class="line">boolean flag &#x3D; true;</span><br><span class="line">System.out.println(flag);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16-使用变量的注意事项"><a href="#16-使用变量的注意事项" class="headerlink" title="16.使用变量的注意事项"></a>16.使用变量的注意事项</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">使用变量的时候要注意的问题：</span><br><span class="line">A:作用域</span><br><span class="line">变量定义在哪个大括号内，它就在这个大括号内有效。</span><br><span class="line">并且，在同一个大括号内不能同时定义同名的变量。</span><br><span class="line"></span><br><span class="line">B:初始化值</span><br><span class="line">没有初始化值的变量不能直接使用。</span><br><span class="line">你只要在使用前给值就行，不一定非要在定义的时候立即给值。</span><br><span class="line">推荐在定义的时候给值。</span><br><span class="line"></span><br><span class="line">定义变量的格式：</span><br><span class="line">a:数据类型 变量名 &#x3D; 初始化值;</span><br><span class="line">b:数据类型 变量名;</span><br><span class="line">  变量名 &#x3D; 初始化值;</span><br><span class="line"></span><br><span class="line">C:在一行上建议只定义一个变量</span><br><span class="line">可以定义多个，但是不建议</span><br><span class="line">*&#x2F;</span><br><span class="line">class DataTypeDemo2 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">&#x2F;&#x2F;定义变量</span><br><span class="line">int x &#x3D; 100;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;错误，不能有同名的</span><br><span class="line">&#x2F;&#x2F;int x &#x3D; 200;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;定义变量必须给值</span><br><span class="line">&#x2F;&#x2F;int y;</span><br><span class="line">&#x2F;&#x2F;System.out.println(y);</span><br><span class="line"></span><br><span class="line">int z;</span><br><span class="line">z &#x3D; 100;</span><br><span class="line">System.out.println(z);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在一行上定义多个变量</span><br><span class="line">&#x2F;&#x2F;int a &#x3D; 10; int b &#x3D; 20; int c  &#x3D; 30;</span><br><span class="line">&#x2F;&#x2F;上面的写法可以，但是不建议。</span><br><span class="line">int a &#x3D; 10;</span><br><span class="line">int b &#x3D; 20;</span><br><span class="line">int c  &#x3D; 30;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;int d, e;</span><br><span class="line">&#x2F;&#x2F;d &#x3D; 40;</span><br><span class="line">&#x2F;&#x2F;e &#x3D; 50;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;int f,int g; &#x2F;&#x2F;错误</span><br><span class="line">&#x2F;&#x2F;int h; int i; &#x2F;&#x2F;正确</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="17-数据类型转换默认转换"><a href="#17-数据类型转换默认转换" class="headerlink" title="17.数据类型转换默认转换"></a>17.数据类型转换默认转换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">+是一个运算符(我们等会讲解)。做加法运算的。</span><br><span class="line"></span><br><span class="line">一般来说，我们在运算的时候，要求参与运算的数据类型必须一致。</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">boolean类型不能转换为其他的数据类型</span><br><span class="line"></span><br><span class="line">默认转换(从小到大的转换)</span><br><span class="line">A:byte,short,char—int—long—float—double</span><br><span class="line">B:byte,short,char相互之间不转换，他们参与运算首先转换为int类型</span><br><span class="line">*&#x2F;</span><br><span class="line">class DataTypeDemo3 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">&#x2F;&#x2F;直接输出的方式做加法</span><br><span class="line">&#x2F;&#x2F;System.out.println(3 + 4);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;两个int类型做加法</span><br><span class="line">int x &#x3D; 3;</span><br><span class="line">int y &#x3D; 4;</span><br><span class="line">int z &#x3D; x + y;</span><br><span class="line">System.out.println(z);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;定义一个byte类型，一个int类型，做加法</span><br><span class="line">byte a &#x3D; 3;</span><br><span class="line">int b &#x3D; 4;</span><br><span class="line">System.out.println(a + b);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;可能损失精度</span><br><span class="line">&#x2F;&#x2F;byte c &#x3D;  a + b;</span><br><span class="line">int c &#x3D; a + b;</span><br><span class="line">System.out.println(c);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="18-数据类型转换强制转换"><a href="#18-数据类型转换强制转换" class="headerlink" title="18.数据类型转换强制转换"></a>18.数据类型转换强制转换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">强制转换：</span><br><span class="line">从大的数据类型到小的数据类型。</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">目标数据类型 变量 &#x3D; (目标数据类型) (被转换的数据);</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">不要随意的去使用强制转换，因为它隐含了精度损失问题。</span><br><span class="line">*&#x2F;</span><br><span class="line">class DataTypeDemo4 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">byte a &#x3D; 3;</span><br><span class="line">int b &#x3D; 4;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;这个肯定没有问题</span><br><span class="line">&#x2F;&#x2F;int c &#x3D; a + b;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;byte c &#x3D; 7;</span><br><span class="line">&#x2F;&#x2F;这个是有问题的</span><br><span class="line">&#x2F;&#x2F;byte c &#x3D; a + b; </span><br><span class="line">&#x2F;&#x2F;用强制类型转换改进</span><br><span class="line">byte c &#x3D; (byte) (a + b);</span><br><span class="line">System.out.println(c);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="19-强制转换的思考题"><a href="#19-强制转换的思考题" class="headerlink" title="19.强制转换的思考题"></a>19.强制转换的思考题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">思考题1：请问下面这个有没有问题</span><br><span class="line">double d &#x3D; 12.345;</span><br><span class="line">float f &#x3D; d;</span><br><span class="line"></span><br><span class="line">思考题2：看看下面两个定义有没有区别呢?</span><br><span class="line">float f1 &#x3D; (float)12.345;</span><br><span class="line">float f2 &#x3D; 12.345f;</span><br><span class="line"></span><br><span class="line">f1其实是通过一个double类型转换过来的。</span><br><span class="line">而f2本身就是一个float类型。</span><br><span class="line">*&#x2F;</span><br><span class="line">class DataTypeDemo5 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">&#x2F;&#x2F;把double赋值给float，加了强制类型转换</span><br><span class="line">double d &#x3D; 12.345;</span><br><span class="line">float f &#x3D; (float)d;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;看看下面两个定义有没有区别呢?</span><br><span class="line">float f1 &#x3D; (float)12.345;</span><br><span class="line">float f2 &#x3D; 12.345F;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="20-变量相加和常量相加的面试题"><a href="#20-变量相加和常量相加的面试题" class="headerlink" title="20.变量相加和常量相加的面试题"></a>20.变量相加和常量相加的面试题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">面试题：</span><br><span class="line">byte b1&#x3D;3,b2&#x3D;4,b;</span><br><span class="line">b&#x3D;b1+b2;</span><br><span class="line">b&#x3D;3+4;</span><br><span class="line">哪句是编译失败的呢？为什么呢？</span><br><span class="line">b &#x3D; b1 + b2;是有问题的。</span><br><span class="line">因为变量相加，会首先看类型问题，最终把结果赋值的也会考虑类型问题。</span><br><span class="line">常量相加，首先做加法，然后看结果是否在赋值的数据类型范围内，如果不是，才报错。</span><br><span class="line">*&#x2F;</span><br><span class="line">class DataTypeDemo6 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">&#x2F;&#x2F;定义了三个byte类型的变量，b1，b2，b3</span><br><span class="line">&#x2F;&#x2F;b1的值是3，b2的值是4，b没有值</span><br><span class="line">byte b1 &#x3D; 3,b2 &#x3D; 4,b;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;b &#x3D; b1 + b2; &#x2F;&#x2F;这个是类型提升，所以有问题</span><br><span class="line"></span><br><span class="line">b &#x3D; 3 + 4; &#x2F;&#x2F;常量，先把结果计算出来，然后看是否在byte的范围内，如果在就不报错。</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="21-强制转换数据溢出后的结果怎么算"><a href="#21-强制转换数据溢出后的结果怎么算" class="headerlink" title="21.强制转换数据溢出后的结果怎么算"></a>21.强制转换数据溢出后的结果怎么算</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">byte b &#x3D; 130;有没有问题?如果我想让赋值正确，可以怎么做?结果是多少呢?</span><br><span class="line"></span><br><span class="line">练习：byte b &#x3D; (byte)300;</span><br><span class="line">*&#x2F;</span><br><span class="line">class DataTypeDemo7 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">&#x2F;&#x2F;因为byte的范围是：-128到127。</span><br><span class="line">&#x2F;&#x2F;而130不在此范围内，所以报错。</span><br><span class="line">&#x2F;&#x2F;byte b &#x3D; 130; </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;我们可以使用强制类型转换</span><br><span class="line">byte b &#x3D; (byte) 130;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;结果是多少呢?</span><br><span class="line">System.out.println(b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*</span><br><span class="line">分析过程：</span><br><span class="line">我们要想知道结果是什么，就应该知道是如何进行计算的。</span><br><span class="line">而我们又知道计算机中数据的运算都是补码进行的。</span><br><span class="line">而要得到补码，首先要计算出数据的二进制。</span><br><span class="line"></span><br><span class="line">A:获取130这个数据的二进制。</span><br><span class="line">00000000 00000000 00000000 10000010</span><br><span class="line">这是130的原码，也是反码，还是补码。</span><br><span class="line">B:做截取操作，截成byte类型的了。</span><br><span class="line">10000010 </span><br><span class="line">这个结果是补码。</span><br><span class="line">C:已知补码求原码。</span><br><span class="line">符号位数值位</span><br><span class="line">补码：10000010</span><br><span class="line"></span><br><span class="line">反码：10000001</span><br><span class="line"></span><br><span class="line">原码：11111110</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure><h3 id="22-字符数据参与运算"><a href="#22-字符数据参与运算" class="headerlink" title="22.字符数据参与运算"></a>22.字符数据参与运算</h3><p><strong>常用字符与ASCII代码对照表</strong></p><p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1588762945712&amp;di=15da2d4da03c11464b6f7ef905bd8194&amp;imgtype=0&amp;src=http%3A%2F%2Faliyunzixunbucket.oss-cn-beijing.aliyuncs.com%2Fjpg%2F5802ba54ea55b831c41d5a4b5b13e641.jpg%3Fx-oss-process%3Dimage%2Fresize%2Cp_100%2Fauto-orient%2C1%2Fquality%2Cq_90%2Fformat%2Cjpg%2Fwatermark%2Cimage_eXVuY2VzaGk%3D%2Ct_100" alt="ACSII"></p><h3 id="23-字符串参与运算"><a href="#23-字符串参与运算" class="headerlink" title="23.字符串参与运算"></a>23.字符串参与运算</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">看程序写结果</span><br><span class="line">字符串数据和其他数据做+，结果是字符串类型。</span><br><span class="line">这里的+不是加法运算，而是字符串连接符。</span><br><span class="line">*&#x2F;</span><br><span class="line">class DataTypeDemo9 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">System.out.println(&quot;hello&quot;+&#39;a&#39;+1); &#x2F;&#x2F;helloa1，因为有优先级</span><br><span class="line">System.out.println(&#39;a&#39;+1+&quot;hello&quot;); &#x2F;&#x2F;98hello</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;5+5&#x3D;&quot;+5+5); &#x2F;&#x2F;5+5&#x3D;55</span><br><span class="line">System.out.println(5+5+&quot;&#x3D;5+5&quot;); &#x2F;&#x2F;10&#x3D;5+5</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运算符优先级</strong></p><p><img src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=807700448,2127105133&amp;fm=26&amp;gp=0.jpg" alt="运算符优先级"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java语言基础&quot;&gt;&lt;a href=&quot;#Java语言基础&quot; class=&quot;headerlink&quot; title=&quot;Java语言基础&quot;&gt;&lt;/a&gt;Java语言基础&lt;/h1&gt;&lt;h2 id=&quot;Java基础语法&quot;&gt;&lt;a href=&quot;#Java基础语法&quot; class=&quot;headerlink&quot; title=&quot;Java基础语法&quot;&gt;&lt;/a&gt;Java基础语法&lt;/h2&gt;&lt;h3 id=&quot;1-关键字&quot;&gt;&lt;a href=&quot;#1-关键字&quot; class=&quot;headerlink&quot; title=&quot;1.关键字&quot;&gt;&lt;/a&gt;1.关键字&lt;/h3&gt;
    
    </summary>
    
    
      <category term="Java系统学习-JavaSE篇" scheme="https://stephencurry6666.github.io/categories/Java%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0-JavaSE%E7%AF%87/"/>
    
    
      <category term="Java系统学习" scheme="https://stephencurry6666.github.io/tags/Java%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE篇-Day1笔记</title>
    <link href="https://stephencurry6666.github.io/2020/05/04/JavaSE-Day(1)%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://stephencurry6666.github.io/2020/05/04/JavaSE-Day(1)%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-05-04T13:40:32.213Z</published>
    <updated>2020-05-04T14:04:49.354Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、计算机基础"><a href="#一、计算机基础" class="headerlink" title="一、计算机基础"></a>一、计算机基础</h2><h3 id="1-计算机概述"><a href="#1-计算机概述" class="headerlink" title="1.计算机概述"></a>1.计算机概述</h3><p>  <strong>计算机全称为：电子计算机，俗称电脑</strong></p><a id="more"></a><h3 id="2-计算机硬件和软件概述"><a href="#2-计算机硬件和软件概述" class="headerlink" title="2.计算机硬件和软件概述"></a>2.计算机硬件和软件概述</h3><ul><li><strong>计算机硬件是指计算机系统中由电子，机械和光电元件等组成的各种物理装置的总称。</strong></li><li><strong>计算机软件是指使用计算机过程中必不可少的东西，计算机软件可以使家算计按照事先预定好的顺序完成特定的功能，计算机软件按照其功能划分为系统软件和应用软件。</strong></li></ul><h3 id="3-软件开发和计算机语言概述"><a href="#3-软件开发和计算机语言概述" class="headerlink" title="3.软件开发和计算机语言概述"></a>3.软件开发和计算机语言概述</h3><ul><li><strong>软件开发：借助开发工具与计算机语言制作软件。</strong></li><li><strong>计算机语言：人与计算机之间进行信息交流沟通的一种特殊语言。</strong></li><li><strong>常见的计算机语言如C，C++，C#，JAVA，python。</strong></li></ul><h3 id="4-人机交互"><a href="#4-人机交互" class="headerlink" title="4.人机交互"></a>4.人机交互</h3><p>   <strong>交互方式：</strong></p><ul><li><strong>图形化界面：这种方式简单直观，使用者易于接受，容易操作上手。</strong></li><li><strong>命令性方式：需要一个控制台，输入特定的指令，让计算机完成一些操作。较为麻烦。需要记录住一些命令。</strong></li></ul><h3 id="5-键盘功能键和快捷键"><a href="#5-键盘功能键和快捷键" class="headerlink" title="5.键盘功能键和快捷键"></a>5.键盘功能键和快捷键</h3><p>   <strong>应该记住一些简单的功能键和快捷键</strong></p><ul><li><strong>Tab 缩进空格</strong></li><li><strong>Enter 回车</strong></li><li><strong>Window键</strong></li><li><strong>Ctrl+A全选 Ctrl+C 复制 Ctrl+V 粘贴 Ctrl+X剪切 Ctrl+Z 撤销 Ctrl+S 保存</strong></li></ul><h3 id="6-如何打开DOS控制台"><a href="#6-如何打开DOS控制台" class="headerlink" title="6.如何打开DOS控制台"></a>6.如何打开DOS控制台</h3><p>   <strong>Windows+R -&gt; cmd -&gt; 回车</strong></p><h3 id="7-常见的DOS讲解"><a href="#7-常见的DOS讲解" class="headerlink" title="7.常见的DOS讲解"></a>7.常见的DOS讲解</h3><ul><li><strong>d: +回车   盘符切换</strong></li><li><strong>dir(directory):   列出当前目录下的文件以及文件夹</strong></li><li><strong>md(make directory):    创建目录</strong></li><li><strong>rd(remove directory):   删除目录</strong></li><li><strong>cd(change directory):   改变指定目录（进入指定目录）</strong></li><li><strong>cd..:     退回上级目录</strong></li><li><strong>cd\:     退回根目录</strong></li><li><strong>exit:     推出dos命令行</strong></li><li><strong>cls(clear screen):    清屏</strong></li><li><strong>del(delete):   删除文件，删除一堆后缀名一样的文件，例如.txt</strong></li></ul><h2 id="二、Java语言基础"><a href="#二、Java语言基础" class="headerlink" title="二、Java语言基础"></a>二、Java语言基础</h2><h3 id="1-Java语言概述"><a href="#1-Java语言概述" class="headerlink" title="1.Java语言概述"></a>1.Java语言概述</h3><p><strong>Java语言由詹姆斯.高斯林发明</strong></p><h3 id="2-Java语言跨平台原理"><a href="#2-Java语言跨平台原理" class="headerlink" title="2.Java语言跨平台原理"></a>2.Java语言跨平台原理</h3><p><strong>Java是面向对象的语言，其重点特点是开源和跨平台</strong></p><p><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=52291647,1781400255&amp;fm=15&amp;gp=0.jpg" alt="Java语言的跨平台性"></p><h3 id="3-JDK与JRE的概述"><a href="#3-JDK与JRE的概述" class="headerlink" title="3.JDK与JRE的概述"></a>3.JDK与JRE的概述</h3><p><strong>JRE -&gt; Java运行环境</strong></p><p><strong>JDK -&gt; Java开发工具包，其中包含了JRE</strong></p><p><strong>简单而言：使用JDK开发完成的java程序，交给JRE去运行</strong></p><h3 id="4-JDK的下载、安装和卸载"><a href="#4-JDK的下载、安装和卸载" class="headerlink" title="4.JDK的下载、安装和卸载"></a>4.JDK的下载、安装和卸载</h3><p><strong>详情请看：<a href="https://blog.csdn.net/nuoyanli/article/details/86513950" target="_blank" rel="noopener">https://blog.csdn.net/nuoyanli/article/details/86513950</a></strong></p><h3 id="5-Java环境变量的配置"><a href="#5-Java环境变量的配置" class="headerlink" title="5.Java环境变量的配置"></a>5.Java环境变量的配置</h3><p><strong>详情请看：<a href="https://blog.csdn.net/nuoyanli/article/details/86513950" target="_blank" rel="noopener">https://blog.csdn.net/nuoyanli/article/details/86513950</a></strong></p><h3 id="6-第一个Java案例的编写和运行"><a href="#6-第一个Java案例的编写和运行" class="headerlink" title="6.第一个Java案例的编写和运行"></a>6.第一个Java案例的编写和运行</h3><p><strong>视频里老师用的是记事本进行编写和运行，而我用的是Eclipse Jee 2018-12</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">import java.math.*;</span><br><span class="line">import java.io.*;</span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line">  &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">        System.out.println(&quot;Hello world&quot;);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、计算机基础&quot;&gt;&lt;a href=&quot;#一、计算机基础&quot; class=&quot;headerlink&quot; title=&quot;一、计算机基础&quot;&gt;&lt;/a&gt;一、计算机基础&lt;/h2&gt;&lt;h3 id=&quot;1-计算机概述&quot;&gt;&lt;a href=&quot;#1-计算机概述&quot; class=&quot;headerlink&quot; title=&quot;1.计算机概述&quot;&gt;&lt;/a&gt;1.计算机概述&lt;/h3&gt;&lt;p&gt;  &lt;strong&gt;计算机全称为：电子计算机，俗称电脑&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java系统学习-JavaSE篇" scheme="https://stephencurry6666.github.io/categories/Java%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0-JavaSE%E7%AF%87/"/>
    
    
      <category term="Java系统学习" scheme="https://stephencurry6666.github.io/tags/Java%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Java系统学习规划(1)——JavaSE篇</title>
    <link href="https://stephencurry6666.github.io/2020/05/04/Java%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%92(1)%E2%80%94JavaSE%E7%AF%87/"/>
    <id>https://stephencurry6666.github.io/2020/05/04/Java%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%92(1)%E2%80%94JavaSE%E7%AF%87/</id>
    <published>2020-05-04T09:55:56.852Z</published>
    <updated>2020-05-04T13:44:29.027Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p><strong>关于为什么要在现在系统的学习Java，是因为我觉得去年暑假学习的一些Java知识基本都忘记了(<del>其实是因为今年疫情影响，很大概率原地退役，所以也算为以后做做准备</del>)</strong></p><a id="more"></a><h2 id="Java系统学习规划-1"><a href="#Java系统学习规划-1" class="headerlink" title="Java系统学习规划(1)"></a>Java系统学习规划(1)</h2><h3 id="一、"><a href="#一、" class="headerlink" title="一、"></a>一、</h3><p><strong>选择什么课程：这里的话我是选择了刘意老师的深入浅出精华版为主，毕向东老师的Java基础教程为辅来进行学习。</strong></p><p>这里给出刘意老师视频的B站地址：<a href="https://www.bilibili.com/video/BV1Jt411w7fR?from=search&amp;seid=5273427619493979344" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1Jt411w7fR?from=search&amp;seid=5273427619493979344</a></p><p>这里给出毕向东老师视频的B站地址：<a href="https://www.bilibili.com/video/BV1pt41127na?from=search&amp;seid=9126689322584219690" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1pt41127na?from=search&amp;seid=9126689322584219690</a></p><h3 id="二、"><a href="#二、" class="headerlink" title="二、"></a>二、</h3><p><strong>学习重点参考</strong> </p><p>初学者也容易想走捷径。我相信很多人都会有这个想法：能不能只学工作上要用的？根本原因是知识点真的太多了。以刘意老师视频为例，面向对象（封装，继承，多态），异常，多线程，集合框架，IO，网络编程都挺难的。其中面向对象是JavaSE的重中之重，里面的知识点个人认为是最难的。后面的知识点都是建立在这之上展开的，没学好面向对象，后面就会稀里糊涂。当然，也不是真的一点都不能跳，但最好完整地学下来。按照后面JavaWeb的学习来看，我的建议是：</p><ul><li><strong>面向对象是基石，JavaSE中最重要的一是集合，二是IO，</strong> 希望大家学习这两个知识点时认真对待，多敲代码，多思考。</li><li><strong>常用API里，String及其相关类StringBuilder, StringBuffer</strong> 等必须熟悉，后面会不断用到。不学好的话，后面怎么死都不知道！</li><li><strong>泛型一般只出现在集合中</strong> ，个人觉得如果一时无法掌握，那么<strong>暂时会在集合中使用泛型就行了。</strong></li><li>反射对于初学者来说是<strong>非常抽象的！！</strong> 但它又无比重要。它虽然不是JavaSE的重点，但是<strong>它是JavaWeb很多难点的底层支撑，不懂反射，寸步难行。</strong></li></ul><p><strong>重点</strong></p><ul><li>面向对象☆☆☆☆☆</li><li>集合☆☆☆☆☆</li><li>IO ☆☆☆☆☆</li><li>String/StringBuffer/StringBuilder ☆☆☆☆☆</li><li>反射☆☆☆☆☆</li><li>泛型☆☆☆☆</li></ul><p><strong>熟悉</strong></p><ul><li>异常</li><li>多线程</li></ul><p><strong>先过一遍</strong></p><ul><li>网络编程</li><li>正则表达式</li></ul><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p><strong>这里给出刘意老师视频的配套资料</strong></p><p>2015年版本刘意Java基础配套资料：<a href="https://pan.baidu.com/s/13slfA9U23PiXca_ROPC0ww" target="_blank" rel="noopener">https://pan.baidu.com/s/13slfA9U23PiXca_ROPC0ww</a>   提取码：rmkv</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;关于为什么要在现在系统的学习Java，是因为我觉得去年暑假学习的一些Java知识基本都忘记了(&lt;del&gt;其实是因为今年疫情影响，很大概率原地退役，所以也算为以后做做准备&lt;/del&gt;)&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java系统学习-JavaSE篇" scheme="https://stephencurry6666.github.io/categories/Java%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0-JavaSE%E7%AF%87/"/>
    
    
      <category term="Java系统学习" scheme="https://stephencurry6666.github.io/tags/Java%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>我的第一篇博客</title>
    <link href="https://stephencurry6666.github.io/2020/04/30/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <id>https://stephencurry6666.github.io/2020/04/30/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</id>
    <published>2020-04-30T10:50:48.798Z</published>
    <updated>2020-05-01T01:56:59.839Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Hexo的一些语法"><a href="#Hexo的一些语法" class="headerlink" title="Hexo的一些语法"></a>Hexo的一些语法</h2><h3 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">**hexo new &quot;postName&quot; #新建文章</span><br><span class="line">hexo new page &quot;pageName&quot; #新建页面</span><br><span class="line">hexo generate #生成静态页面至public目录</span><br><span class="line">hexo server #开启预览访问端口（默认端口4000，&#39;ctrl + c&#39;关闭server）</span><br><span class="line">hexo deploy #部署到GitHub</span><br><span class="line">hexo help  # 查看帮助</span><br><span class="line">hexo version  #查看Hexo的版本**</span><br><span class="line">hexo clean  #清除缓存文件和静态文件</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a>缩写</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo n &#x3D;&#x3D; hexo new</span><br><span class="line">hexo g &#x3D;&#x3D; hexo generate</span><br><span class="line">hexo s &#x3D;&#x3D; hexo server</span><br><span class="line">hexo d &#x3D;&#x3D; hexo deploy</span><br></pre></td></tr></table></figure><h3 id="组合命令"><a href="#组合命令" class="headerlink" title="组合命令"></a>组合命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo s -g #生成并本地预览</span><br><span class="line">hexo d -g #生成并上传</span><br></pre></td></tr></table></figure><h3 id="在生成一篇新的博客的一些操作"><a href="#在生成一篇新的博客的一些操作" class="headerlink" title="在生成一篇新的博客的一些操作"></a>在生成一篇新的博客的一些操作</h3><p><strong>首先：hexo new/n + 博客标题(标题需加双引号)<br>然后：运行后会自动生成markdown格式的文章<br>然后：按创建成功后的提示信息（路径）进入到该文件所在的目录中，将md后缀的文件在Visual Studio Code中打开，可以在Visual Studio Code中下载一个markdownlint插件进行编辑。<br>最后：编辑完成后返回主目录blog(cd … 返回上一层目录)<br>运行 hexo clean 清除缓存文件和静态文件（非必要）<br>运行 hexo generate/g 生成静态博客文件<br>运行 hexo server/s 启动博客</strong></p><h3 id="如何把个人博客部署到远端"><a href="#如何把个人博客部署到远端" class="headerlink" title="如何把个人博客部署到远端"></a>如何把个人博客部署到远端</h3><p><strong>在blog目录下运行命令 hexo deploy/d 将本地博客部署到github<br>部署过程中按要求输入 github 的账号和密码<br>完成后就可直接通过该仓库名（username.github.io）访问博客了</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Hexo的一些语法&quot;&gt;&lt;a href=&quot;#Hexo的一些语法&quot; class=&quot;headerlink&quot; title=&quot;Hexo的一些语法&quot;&gt;&lt;/a&gt;Hexo的一些语法&lt;/h2&gt;&lt;h3 id=&quot;常见命令&quot;&gt;&lt;a href=&quot;#常见命令&quot; class=&quot;headerlink&quot; title=&quot;常见命令&quot;&gt;&lt;/a&gt;常见命令&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;**hexo new &amp;quot;postName&amp;quot; #新建文章&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo new page &amp;quot;pageName&amp;quot; #新建页面&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo generate #生成静态页面至public目录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo server #开启预览访问端口（默认端口4000，&amp;#39;ctrl + c&amp;#39;关闭server）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo deploy #部署到GitHub&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo help  # 查看帮助&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo version  #查看Hexo的版本**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo clean  #清除缓存文件和静态文件&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="Hexo的一些基本用法和编写博客的一些注意事项" scheme="https://stephencurry6666.github.io/tags/Hexo%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%E5%92%8C%E7%BC%96%E5%86%99%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    
  </entry>
  
  <entry>
    <title>Hello Stephencurry6666</title>
    <link href="https://stephencurry6666.github.io/2020/04/30/hello-world/"/>
    <id>https://stephencurry6666.github.io/2020/04/30/hello-world/</id>
    <published>2020-04-30T03:20:40.007Z</published>
    <updated>2020-05-02T09:44:29.808Z</updated>
    
    <content type="html"><![CDATA[<h3 id="科学公式-TeX-KaTeX"><a href="#科学公式-TeX-KaTeX" class="headerlink" title="科学公式 TeX(KaTeX)"></a>科学公式 TeX(KaTeX)</h3><script type="math/tex; mode=display">E=mc^2</script><p>行内的公式<script type="math/tex">E=mc^2</script>行内的公式，行内的<script type="math/tex">E=mc^2</script>公式。</p><script type="math/tex; mode=display">x > y</script><script type="math/tex; mode=display">(\sqrt{3x-1}+(1+x)^2)</script><script type="math/tex; mode=display">\sin(\alpha)^{\theta}=\sum_{i=0}^{n}(x^i + \cos(f))</script><script type="math/tex; mode=display">\iint_{a}^{b}\frac{\mathrm{3} }{\mathrm{3} x}</script><a id="more"></a><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><!--more--><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;科学公式-TeX-KaTeX&quot;&gt;&lt;a href=&quot;#科学公式-TeX-KaTeX&quot; class=&quot;headerlink&quot; title=&quot;科学公式 TeX(KaTeX)&quot;&gt;&lt;/a&gt;科学公式 TeX(KaTeX)&lt;/h3&gt;&lt;script type=&quot;math/tex; mode=display&quot;&gt;E=mc^2&lt;/script&gt;&lt;p&gt;行内的公式&lt;script type=&quot;math/tex&quot;&gt;E=mc^2&lt;/script&gt;行内的公式，行内的&lt;script type=&quot;math/tex&quot;&gt;E=mc^2&lt;/script&gt;公式。&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;x &gt; y&lt;/script&gt;&lt;script type=&quot;math/tex; mode=display&quot;&gt;(\sqrt{3x-1}+(1+x)^2)&lt;/script&gt;&lt;script type=&quot;math/tex; mode=display&quot;&gt;\sin(\alpha)^{\theta}=\sum_{i=0}^{n}(x^i + \cos(f))&lt;/script&gt;&lt;script type=&quot;math/tex; mode=display&quot;&gt;\iint_{a}^{b}\frac{\mathrm{3} }{\mathrm{3} x}&lt;/script&gt;
    
    </summary>
    
    
    
  </entry>
  
</feed>
