<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>愿你出走半生，归来仍是少年</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://stephencurry6666.github.io/"/>
  <updated>2020-08-15T07:44:48.753Z</updated>
  <id>https://stephencurry6666.github.io/</id>
  
  <author>
    <name>Stephencurry6666</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2020HDU多校第八场</title>
    <link href="https://stephencurry6666.github.io/2020/08/15/2020HDU%E5%A4%9A%E6%A0%A1%E7%AC%AC%E5%85%AB%E5%9C%BA/"/>
    <id>https://stephencurry6666.github.io/2020/08/15/2020HDU%E5%A4%9A%E6%A0%A1%E7%AC%AC%E5%85%AB%E5%9C%BA/</id>
    <published>2020-08-15T07:37:51.329Z</published>
    <updated>2020-08-15T07:44:48.753Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Clockwise-or-Counterclockwise-（HDU-6857）（1003）"><a href="#Clockwise-or-Counterclockwise-（HDU-6857）（1003）" class="headerlink" title="Clockwise or Counterclockwise （HDU-6857）（1003）"></a>Clockwise or Counterclockwise （HDU-6857）（1003）</h3><p><strong>题意：给定三个点的坐标，A,B,C，判断从A到B到C是顺时针还是逆时针。</strong></p><a id="more"></a><p><strong>思路：这道题的话，右手定则。向量αx向量β，若β在α的逆时针方向，则为正值;顺时针则为负值顺时针则为负值;两向量共线则为0。</strong></p><p><strong>AC代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxn &#x3D; 100010;</span><br><span class="line">const int inf &#x3D; 0x3f3f3f3f;</span><br><span class="line">#define P pair&lt;double, double&gt;</span><br><span class="line">#define x first</span><br><span class="line">#define y second</span><br><span class="line">using namespace std;</span><br><span class="line">P V[5];</span><br><span class="line">P s[5];</span><br><span class="line">double Cross(P a, P b)</span><br><span class="line">&#123;</span><br><span class="line">    return a.x * b.y - a.y * b.x;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    cout.tie(0);</span><br><span class="line">    int t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 3; i++)</span><br><span class="line">            cin &gt;&gt; V[i].x &gt;&gt; V[i].y;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 2; i++)</span><br><span class="line">            s[i] &#x3D; &#123;V[i + 1].x - V[i].x, V[i + 1].y - V[i].y&#125;;</span><br><span class="line">        bool z &#x3D; true;</span><br><span class="line">        if (Cross(s[0], s[1]) &gt; 0)</span><br><span class="line">            z &#x3D; false;</span><br><span class="line"></span><br><span class="line">        if (z)</span><br><span class="line">            cout &lt;&lt; &quot;Clockwise&quot; &lt;&lt; endl;</span><br><span class="line">        else</span><br><span class="line">            cout &lt;&lt; &quot;Counterclockwise&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Fluctuation-Limit-（HDU-6860）（1006）"><a href="#Fluctuation-Limit-（HDU-6860）（1006）" class="headerlink" title="Fluctuation Limit （HDU-6860）（1006）"></a>Fluctuation Limit （HDU-6860）（1006）</h3><p><strong>题意：给你n个范围$[li,ri]$和一个整数x，要求构建一个长度为n的数组ai，要求保证$ai &gt;= li$ &amp;&amp; $ai &lt;= ri$,并且保证相邻两个x之间的差值的绝对值不大于x。</strong></p><p><strong>思路：这道题的话，正着对区间约束过后还得倒着将每个区间缩一遍。这样最终随便从每段可行区间里任意取一个值即可。其中$up[i]$表示第i天能预测的最大值，$down[i]$同理，因为可能存在类似第i天的$down[i]$加上k后还到不了第$i+1$天的下界，所以最后得倒着根据第$i+1$天的$down[i]$减掉k来更新第i天的$down[i]$。</strong></p><p><strong>AC代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxn &#x3D; 100010;</span><br><span class="line">const int inf &#x3D; 0x3f3f3f3f;</span><br><span class="line">using namespace std;</span><br><span class="line">int l[maxn], r[maxn], up[maxn], down[maxn];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    cout.tie(0);</span><br><span class="line">    int t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        int n, k;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">            cin &gt;&gt; l[i] &gt;&gt; r[i];</span><br><span class="line">        up[1] &#x3D; r[1];</span><br><span class="line">        down[1] &#x3D; l[1];</span><br><span class="line">        bool flag &#x3D; true;</span><br><span class="line">        for (int i &#x3D; 2; i &lt;&#x3D; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            up[i] &#x3D; min(r[i], up[i - 1] + k);</span><br><span class="line">            down[i] &#x3D; max(l[i], down[i - 1] - k);</span><br><span class="line">            if (up[i] &lt; down[i])</span><br><span class="line">                flag &#x3D; false;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; n - 1; i &gt;&#x3D; 1; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            up[i] &#x3D; min(up[i], up[i + 1] + k);</span><br><span class="line">            down[i] &#x3D; max(down[i], down[i + 1] - k);</span><br><span class="line">            if (up[i] &lt; down[i])</span><br><span class="line">                flag &#x3D; false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!flag)</span><br><span class="line">            cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;</span><br><span class="line">            for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; down[i] &lt;&lt; &#39; &#39;;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Hexagon-（HDU-6862）（1008）"><a href="#Hexagon-（HDU-6862）（1008）" class="headerlink" title="Hexagon （HDU-6862）（1008）"></a>Hexagon （HDU-6862）（1008）</h3><p><strong>题意：如图所示，有一个半径为n的六边形网络，你应该从中间开始经过每一个网格，问你路线。</strong></p><p><strong>思路：这道题的话，<a href="https://blog.csdn.net/Sankkl1/article/details/107991889" target="_blank" rel="noopener">https://blog.csdn.net/Sankkl1/article/details/107991889</a></strong></p><p><strong>AC代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxn &#x3D; 100010;</span><br><span class="line">const int inf &#x3D; 0x3f3f3f3f;</span><br><span class="line">using namespace std;</span><br><span class="line">int t, n;</span><br><span class="line">void solveji()</span><br><span class="line">&#123;</span><br><span class="line">    for (int k &#x3D; n - 2; k &gt;&#x3D; 1; k -&#x3D; 2)</span><br><span class="line">    &#123;</span><br><span class="line">        int a &#x3D; 4, b &#x3D; 2;</span><br><span class="line">        printf(&quot;3&quot;);</span><br><span class="line">        for (int t &#x3D; 1; t &lt;&#x3D; 5; t++)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int i &#x3D; 1; i &lt;&#x3D; k; i++)</span><br><span class="line">                printf(&quot;%d%d&quot;, a, b);</span><br><span class="line">            printf(&quot;%d&quot;, a);</span><br><span class="line">            a++, b++;</span><br><span class="line">            if (a &gt; 6)</span><br><span class="line">                a &#x3D; 1;</span><br><span class="line">            if (b &gt; 6)</span><br><span class="line">                b &#x3D; 1;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d&quot;, a);</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; k - 1; i++)</span><br><span class="line">            printf(&quot;%d%d&quot;, b, a);</span><br><span class="line">        printf(&quot;4&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solveou()</span><br><span class="line">&#123;</span><br><span class="line">    for (int k &#x3D; n - 1; k &gt;&#x3D; 1; k -&#x3D; 2)</span><br><span class="line">    &#123;</span><br><span class="line">        int a &#x3D; 4, b &#x3D; 2;</span><br><span class="line">        printf(&quot;3&quot;);</span><br><span class="line">        for (int t &#x3D; 1; t &lt;&#x3D; 5; t++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (t &#x3D;&#x3D; 5 &amp;&amp; k &#x3D;&#x3D; 1)</span><br><span class="line">                break;</span><br><span class="line">            printf(&quot;%d&quot;, a);</span><br><span class="line">            for (int i &#x3D; 1; i &lt;&#x3D; k - 1; i++)</span><br><span class="line">                printf(&quot;%d%d&quot;, b, a);</span><br><span class="line">            a++, b++;</span><br><span class="line">            if (a &gt; 6)</span><br><span class="line">                a &#x3D; 1;</span><br><span class="line">            if (b &gt; 6)</span><br><span class="line">                b &#x3D; 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (k !&#x3D; 1)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;%d&quot;, a);</span><br><span class="line">            for (int i &#x3D; 1; i &lt;&#x3D; k - 2; i++)</span><br><span class="line">                printf(&quot;%d%d&quot;, b, a);</span><br><span class="line">        &#125;</span><br><span class="line">        if (k &#x3D;&#x3D; 1)</span><br><span class="line">            printf(&quot;3&quot;);</span><br><span class="line">        else</span><br><span class="line">            printf(&quot;4&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;t);</span><br><span class="line">    while (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">        if (n % 2)</span><br><span class="line">            solveji();</span><br><span class="line">        else</span><br><span class="line">            solveou();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Clockwise-or-Counterclockwise-（HDU-6857）（1003）&quot;&gt;&lt;a href=&quot;#Clockwise-or-Counterclockwise-（HDU-6857）（1003）&quot; class=&quot;headerlink&quot; title=&quot;Clockwise or Counterclockwise （HDU-6857）（1003）&quot;&gt;&lt;/a&gt;Clockwise or Counterclockwise （HDU-6857）（1003）&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;题意：给定三个点的坐标，A,B,C，判断从A到B到C是顺时针还是逆时针。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="多校" scheme="https://stephencurry6666.github.io/categories/%E5%A4%9A%E6%A0%A1/"/>
    
    
      <category term="HDU" scheme="https://stephencurry6666.github.io/tags/HDU/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 636(Div.3)</title>
    <link href="https://stephencurry6666.github.io/2020/08/13/Codeforces%20636(Div.3)/"/>
    <id>https://stephencurry6666.github.io/2020/08/13/Codeforces%20636(Div.3)/</id>
    <published>2020-08-13T07:12:00.985Z</published>
    <updated>2020-08-13T07:23:39.772Z</updated>
    
    <content type="html"><![CDATA[<h3 id="A题"><a href="#A题" class="headerlink" title="A题"></a>A题</h3><p><strong>题意：给你一个n，解方程，(1+2+4+…+2^(k-1))*x=n，保证k&gt;1。</strong></p><a id="more"></a><p><strong>思路：这道题的话，因为保证有解，我们枚举一下k就行。</strong></p><p><strong>AC代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxn &#x3D; 100010;</span><br><span class="line">const int inf &#x3D; 0x3f3f3f3f;</span><br><span class="line">const ll mod &#x3D; 998244353;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    cout.tie(0);</span><br><span class="line">    int t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        ll n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        ll sum &#x3D; 4;</span><br><span class="line">        while (n % (sum - 1) !&#x3D; 0)</span><br><span class="line">            sum *&#x3D; 2;</span><br><span class="line">        cout &lt;&lt; n &#x2F; (sum - 1) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="B题"><a href="#B题" class="headerlink" title="B题"></a>B题</h3><p><strong>题意： 给一个偶数n，构造一个数组，前面都是偶数，后面都是奇数，且互不相同。且前面n/2个数的和与后面n/2个数的和相等。</strong></p><p><strong>思路：这道题的话，首先如果n/2是奇数肯定不成立。前面是偶数，后面是奇数，不相等。如果n/2是偶数我们就尝试构造。偶数就2,4,6,8这样输出，奇数就1,3,5,7这样输出。然后在最后一个数把前面的差补全就好了。</strong></p><p><strong>AC代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxn &#x3D; 100010;</span><br><span class="line">const int inf &#x3D; 0x3f3f3f3f;</span><br><span class="line">const ll mod &#x3D; 998244353;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    cout.tie(0);</span><br><span class="line">    int t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        int n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        if ((n &#x2F; 2) % 2 !&#x3D; 0)</span><br><span class="line">            cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;</span><br><span class="line">            for (int i &#x3D; 1; i &lt;&#x3D; n &#x2F; 2; ++i)</span><br><span class="line">                cout &lt;&lt; 2 * i &lt;&lt; &quot; &quot;;</span><br><span class="line">            for (int i &#x3D; 1; i &lt;&#x3D; n &#x2F; 2 - 1; ++i)</span><br><span class="line">                cout &lt;&lt; 2 * i - 1 &lt;&lt; &quot; &quot;;</span><br><span class="line">            cout &lt;&lt; n &#x2F; 2 * 3 - 1 &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C题"><a href="#C题" class="headerlink" title="C题"></a>C题</h3><p><strong>题意：给一个序列a，问你最长连续正负子序列的和最大是多少。</strong></p><p><strong>思路：这道题的话，我们可以将序列a的正负分开来算，所以这个序列被分成了几个正连续子序列和负连续子序列，我只要将每一段序列求出它在这段的最大值最后将所有段的最大值相加就是答案。</strong></p><p><strong>AC代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxn &#x3D; 200010;</span><br><span class="line">const int inf &#x3D; 0x3f3f3f3f;</span><br><span class="line">const ll mod &#x3D; 998244353;</span><br><span class="line">using namespace std;</span><br><span class="line">ll a[maxn];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    cout.tie(0);</span><br><span class="line">    int t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        int n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        ll sum &#x3D; 0;</span><br><span class="line">        cin &gt;&gt; a[1];</span><br><span class="line">        ll maxx &#x3D; a[1];</span><br><span class="line">        for (int i &#x3D; 2; i &lt;&#x3D; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">            if (a[i] * a[i - 1] &lt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                sum +&#x3D; maxx;</span><br><span class="line">                maxx &#x3D; a[i];</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                maxx &#x3D; max(maxx, a[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sum +&#x3D; maxx;</span><br><span class="line">        cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="D题"><a href="#D题" class="headerlink" title="D题"></a>D题</h3><p><strong>题意：给你n个数的数组，n为偶数。每一个数都不超过k，修改之后的值也不能超过k。现在求最小的修改次数，使得$a[i]+a[n-i+1]=const$。</strong></p><p><strong>思路：这道题的话，1.我们发现，将a[i]和a[n-i+1]全变为1是sum最小的值,将a[i]和a[n-i+1]全变为2k是sum最大的值。所以sum的取值范围为【2,2k】；</strong><br><strong>2.我们发现每一对a[i]和a[n-i+1]都分三种情况：1）修改1次 2）修改2次 3）不修改。</strong><br><strong>分析修改一次的情况：将a[i]和a[n-i+1]修改一次后，最小值的话就是将最大的数变1，用公式表示为 min（a[i],a[n-i+1]）+1；则最大值公式为：max（a[i],a[n-i+1]）+k；所以修改一次的区间为【min（a[i],a[n-i+1]）+1，max（a[i],a[n-i+1]）+k】，在此区间内，其修改次数全是1，分析修改零次的情况：当sum刚好等于a[i]+a[n-i+1]，不用修改。分析修改2次的情况：除了一次和零次外，其余段全是修改两次。根据以上特性我们可以用差分，来维护区间内修改次数，枚举sum，看sum落在哪个区间内。</strong></p><p><strong>AC代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxn &#x3D; 200010;</span><br><span class="line">const int inf &#x3D; 0x3f3f3f3f;</span><br><span class="line">const ll mod &#x3D; 998244353;</span><br><span class="line">using namespace std;</span><br><span class="line">int vis[maxn &lt;&lt; 1];</span><br><span class="line">ll a[maxn];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    cout.tie(0);</span><br><span class="line">    int t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        int n, k;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">        memset(vis, 0, sizeof(vis));</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; n &#x2F; 2; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int l &#x3D; min(a[i], a[n - i + 1]) + 1;</span><br><span class="line">            int r &#x3D; max(a[i], a[n - i + 1]) + k;</span><br><span class="line">            int sum &#x3D; a[i] + a[n - i + 1];</span><br><span class="line">            vis[2] +&#x3D; 2;</span><br><span class="line">            vis[l]--;</span><br><span class="line">            vis[r + 1]++;</span><br><span class="line">            vis[sum]--;</span><br><span class="line">            vis[sum + 1]++;</span><br><span class="line">        &#125;</span><br><span class="line">        int ans &#x3D; inf;</span><br><span class="line">        for (int i &#x3D; 2; i &lt;&#x3D; 2 * k; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            vis[i] +&#x3D; vis[i - 1];</span><br><span class="line">            ans &#x3D; min(ans, vis[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;A题&quot;&gt;&lt;a href=&quot;#A题&quot; class=&quot;headerlink&quot; title=&quot;A题&quot;&gt;&lt;/a&gt;A题&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;题意：给你一个n，解方程，(1+2+4+…+2^(k-1))*x=n，保证k&amp;gt;1。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="CF" scheme="https://stephencurry6666.github.io/categories/CF/"/>
    
    
      <category term="CF" scheme="https://stephencurry6666.github.io/tags/CF/"/>
    
  </entry>
  
  <entry>
    <title>Increasing and Decreasing （HDU-6852）(2020多校第七场)</title>
    <link href="https://stephencurry6666.github.io/2020/08/12/Increasing%20and%20Decreasing%20%EF%BC%88HDU-6852%EF%BC%89/"/>
    <id>https://stephencurry6666.github.io/2020/08/12/Increasing%20and%20Decreasing%20%EF%BC%88HDU-6852%EF%BC%89/</id>
    <published>2020-08-12T08:31:21.079Z</published>
    <updated>2020-08-12T08:37:31.966Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Problem Description</strong><br>Notice：Don’t output extra spaces at the end of one line.</p><p>Given n,x,y, please construct a permutation of length n, satisfying that:</p><ul><li>The length of LIS(Longest Increasing Subsequence) is equal to x.</li><li>The length of LDS(Longest Decreasing Subsequence) is equal to y.</li></ul><a id="more"></a><p>If there are multiple possible permutations satisfying all the conditions, print the lexicographically minimum one.</p><p><strong>Input</strong><br>The first line contains an integer $T$($1≤T≤100$), indicating the number of test cases.</p><p>Each test case contains one line, which contains three integers $n,x,y$($1≤n≤105,1≤x,y≤n$).</p><p><strong>Output</strong><br>For each test case, the first line contains ‘’YES’’ or ‘’NO’’, indicating if the answer exists. If the answer exists, output another line which contains n integers, indicating the permutation.</p><p><strong>Sample Input</strong><br>4<br>10 1 10<br>10 10 1<br>10 5 5<br>10 8 8</p><p><strong>Sample Output</strong><br>YES<br>10 9 8 7 6 5 4 3 2 1<br>YES<br>1 2 3 4 5 6 7 8 9 10<br>YES<br>1 2 3 5 4 10 9 8 7 6<br>NO</p><p><strong>题意：让构造一个长度为n的序列，使得其最长递增子序列长度为x，最长递减子序列的长度为y。若无法构成自己输出 “NO”。</strong></p><p><strong>思路：</strong> <img src="https://img-blog.csdnimg.cn/20200811223623125.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NhdHVyOQ==,size_16,color_FFFFFF,t_70" alt="tupian"> </p><p><strong>AC代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxn &#x3D; 100010;</span><br><span class="line">const int inf &#x3D; 0x3f3f3f3f;</span><br><span class="line">const ll mod &#x3D; 998244353;</span><br><span class="line">using namespace std;</span><br><span class="line">vector&lt;int&gt; v;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    cout.tie(0);</span><br><span class="line">    int t, n, x, y;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        int a &#x3D; sqrt(n);</span><br><span class="line">        int b &#x3D; n &#x2F; a;</span><br><span class="line">        if (a * b !&#x3D; n)</span><br><span class="line">            b++;</span><br><span class="line">        if (x + y &gt; n + 1 || x + y &lt; a + b)</span><br><span class="line">            cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;</span><br><span class="line">            v.clear();</span><br><span class="line">            for (int i &#x3D; x; i; i--)</span><br><span class="line">            &#123;</span><br><span class="line">                int xx &#x3D; min(n - i + 1, y);</span><br><span class="line">                for (int j &#x3D; n - xx + 1; j &lt;&#x3D; n; j++)</span><br><span class="line">                    v.push_back(j);</span><br><span class="line">                n -&#x3D; xx;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int i &#x3D; v.size() - 1; ~i; i--)</span><br><span class="line">                cout &lt;&lt; v[i] &lt;&lt; &quot; \n&quot;[!i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Problem Description&lt;/strong&gt;&lt;br&gt;Notice：Don’t output extra spaces at the end of one line.&lt;/p&gt;
&lt;p&gt;Given n,x,y, please construct a permutation of length n, satisfying that:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The length of LIS(Longest Increasing Subsequence) is equal to x.&lt;/li&gt;
&lt;li&gt;The length of LDS(Longest Decreasing Subsequence) is equal to y.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="2020HDU多校" scheme="https://stephencurry6666.github.io/categories/2020HDU%E5%A4%9A%E6%A0%A1/"/>
    
    
      <category term="构造" scheme="https://stephencurry6666.github.io/tags/%E6%9E%84%E9%80%A0/"/>
    
  </entry>
  
  <entry>
    <title>2020HDU多校第六场</title>
    <link href="https://stephencurry6666.github.io/2020/08/12/2020HDU%E5%A4%9A%E6%A0%A1%E7%AC%AC%E5%85%AD%E5%9C%BA/"/>
    <id>https://stephencurry6666.github.io/2020/08/12/2020HDU%E5%A4%9A%E6%A0%A1%E7%AC%AC%E5%85%AD%E5%9C%BA/</id>
    <published>2020-08-12T07:34:44.023Z</published>
    <updated>2020-08-12T07:40:40.488Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Divisibility-（HDU-6835）-（1009）"><a href="#Divisibility-（HDU-6835）-（1009）" class="headerlink" title="Divisibility  （HDU-6835） （1009）"></a>Divisibility  （HDU-6835） （1009）</h3><p><strong>题意：就是在什么情况下，对于b进制数x以及任意b进制数y，y的各位数字的和能被x整除可以推出y能被x整除；y的各位数字的和不能被x整除可以推出y不能被x整除。</strong></p><a id="more"></a><p><strong>思路：<a href="https://www.cnblogs.com/lipoicyclic/p/13449188.html" target="_blank" rel="noopener">https://www.cnblogs.com/lipoicyclic/p/13449188.html</a></strong></p><p><strong>AC代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxn &#x3D; 100010;</span><br><span class="line">const int inf &#x3D; 0x3f3f3f3f;</span><br><span class="line">const ll mod &#x3D; 998244353;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    cout.tie(0);</span><br><span class="line">    int t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        ll b, x;</span><br><span class="line">        cin &gt;&gt; b &gt;&gt; x;</span><br><span class="line">        if ((b - 1) % x &#x3D;&#x3D; 0)</span><br><span class="line">            cout &lt;&lt; &quot;T&quot; &lt;&lt; endl;</span><br><span class="line">        else</span><br><span class="line">            cout &lt;&lt; &quot;F&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Little-Rabbit’s-Equation-（HDU-6828）（1002）"><a href="#Little-Rabbit’s-Equation-（HDU-6828）（1002）" class="headerlink" title="Little Rabbit’s Equation （HDU-6828）（1002）"></a>Little Rabbit’s Equation （HDU-6828）（1002）</h3><p><strong>题意：判断给出的表达式在哪种进制下成立。</strong></p><p><strong>思路：直接把字符串截成三段，从小到大枚举每种进制即可。注意的地方：开long long   如果有一位数比当前枚举到的进制还大，直接跳过这种情况。</strong></p><p><strong>AC代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">#define int long long</span><br><span class="line">using namespace std;</span><br><span class="line">int Atoi(string s, int radix)</span><br><span class="line">&#123;</span><br><span class="line">    int ans &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; s.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        char t &#x3D; s[i];</span><br><span class="line">        if (t &gt;&#x3D; &#39;0&#39; &amp;&amp; t &lt;&#x3D; &#39;9&#39;)</span><br><span class="line">        &#123;</span><br><span class="line">            if (t - &#39;0&#39; &gt;&#x3D; radix)</span><br><span class="line">                return -1;</span><br><span class="line">            ans &#x3D; ans * radix + 1ll * (t - &#39;0&#39;);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            if (1ll * (t - &#39;A&#39; + 10) &gt;&#x3D; radix)</span><br><span class="line">                return -1;</span><br><span class="line">            ans &#x3D; ans * radix + 1ll * (t - &#39;A&#39; + 10);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">bool calc(int a, int b, int c, char opt)</span><br><span class="line">&#123;</span><br><span class="line">    if (opt &#x3D;&#x3D; &#39;+&#39;)</span><br><span class="line">    &#123;</span><br><span class="line">        return a + b &#x3D;&#x3D; c;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (opt &#x3D;&#x3D; &#39;-&#39;)</span><br><span class="line">    &#123;</span><br><span class="line">        return a - b &#x3D;&#x3D; c;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (opt &#x3D;&#x3D; &#39;*&#39;)</span><br><span class="line">    &#123;</span><br><span class="line">        return a * b &#x3D;&#x3D; c;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        if (b &#x3D;&#x3D; 0)</span><br><span class="line">            return -1;</span><br><span class="line">        return a % b &#x3D;&#x3D; 0 &amp;&amp; a &#x3D;&#x3D; b * c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string s;</span><br><span class="line">    while (cin &gt;&gt; s)</span><br><span class="line">    &#123;</span><br><span class="line">        int opt &#x3D; -1, eq &#x3D; -1;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; s.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (s[i] &gt;&#x3D; &#39;0&#39; &amp;&amp; s[i] &lt;&#x3D; &#39;9&#39; || s[i] &gt;&#x3D; &#39;A&#39; &amp;&amp; s[i] &lt;&#x3D; &#39;Z&#39;)</span><br><span class="line">                continue;</span><br><span class="line">            if (opt &#x3D;&#x3D; -1)</span><br><span class="line">                opt &#x3D; i;</span><br><span class="line">            else</span><br><span class="line">                eq &#x3D; i;</span><br><span class="line">        &#125;</span><br><span class="line">        string a &#x3D; s.substr(0, opt);</span><br><span class="line">        string b &#x3D; s.substr(opt + 1, eq - opt - 1);</span><br><span class="line">        string c &#x3D; s.substr(eq + 1);</span><br><span class="line">        bool flag &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 2; i &lt;&#x3D; 16; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int aa &#x3D; Atoi(a, i), bb &#x3D; Atoi(b, i), cc &#x3D; Atoi(c, i);</span><br><span class="line">            if (aa &#x3D;&#x3D; -1 || bb &#x3D;&#x3D; -1 || cc &#x3D;&#x3D; -1)</span><br><span class="line">                continue;</span><br><span class="line">            if (calc(aa, bb, cc, s[opt]))</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">                flag &#x3D; 1;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!flag)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; -1 &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="A-Very-Easy-Graph-Problem-（HDU-6832）（1006）"><a href="#A-Very-Easy-Graph-Problem-（HDU-6832）（1006）" class="headerlink" title="A Very Easy Graph Problem  （HDU-6832）（1006）"></a>A Very Easy Graph Problem  （HDU-6832）（1006）</h3><p><strong>题意：给你一个n个点,m条无向边的图，每个点有是黑点或者白点，要你求所有黑点和所有白点的最短路的和。</strong></p><p><strong>思路：这道题的边权是2的幂次，显然我们发现边权前面所有边相加都不如这条边长，因此其实本题的最短路径就是最小生成树。之后对于答案只需要计算每条边的贡献即可。</strong></p><p><strong>AC代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int mod &#x3D; 1e9 + 7;</span><br><span class="line">const int N &#x3D; 3e5 + 10;</span><br><span class="line">using namespace std;</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    int a, b;</span><br><span class="line">    ll w;</span><br><span class="line">&#125; s[N];</span><br><span class="line">int p[N];</span><br><span class="line">int a[N];</span><br><span class="line">int h[N], e[N], ne[N], idx;</span><br><span class="line">ll w[N];</span><br><span class="line">int cnt1, cnt2;</span><br><span class="line">ll f[N][2];</span><br><span class="line">void add(int a, int b, int c)</span><br><span class="line">&#123;</span><br><span class="line">    e[idx] &#x3D; b, ne[idx] &#x3D; h[a], w[idx] &#x3D; c, h[a] &#x3D; idx++;</span><br><span class="line">&#125;</span><br><span class="line">ll qmi(ll a, ll b)</span><br><span class="line">&#123;</span><br><span class="line">    ll res &#x3D; 1;</span><br><span class="line">    while (b)</span><br><span class="line">    &#123;</span><br><span class="line">        if (b &amp; 1)</span><br><span class="line">        &#123;</span><br><span class="line">            res &#x3D; res * a % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        b &gt;&gt;&#x3D; 1;</span><br><span class="line">        a &#x3D; a * a % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">int find(int x)</span><br><span class="line">&#123;</span><br><span class="line">    if (x !&#x3D; p[x])</span><br><span class="line">    &#123;</span><br><span class="line">        p[x] &#x3D; find(p[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    return p[x];</span><br><span class="line">&#125;</span><br><span class="line">ll ans &#x3D; 0;</span><br><span class="line">void dfs(int u, int fa)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    if (a[u])</span><br><span class="line">        f[u][1] &#x3D; 1;</span><br><span class="line">    else</span><br><span class="line">        f[u][0] &#x3D; 1;</span><br><span class="line">    for (i &#x3D; h[u]; i !&#x3D; -1; i &#x3D; ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        int j &#x3D; e[i];</span><br><span class="line">        if (j &#x3D;&#x3D; fa)</span><br><span class="line">            continue;</span><br><span class="line">        dfs(j, u);</span><br><span class="line">        f[u][1] +&#x3D; f[j][1];</span><br><span class="line">        f[u][0] +&#x3D; f[j][0];</span><br><span class="line">        ans &#x3D; (ans + w[i] * (f[j][0] * (cnt1 - f[j][1]) % mod + f[j][1] * (cnt2 - f[j][0]) % mod) % mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    cout.tie(0);</span><br><span class="line">    int t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        int n, m;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        int i;</span><br><span class="line">        ans &#x3D; 0;</span><br><span class="line">        cnt1 &#x3D; 0;</span><br><span class="line">        cnt2 &#x3D; 0;</span><br><span class="line">        memset(h, -1, sizeof h);</span><br><span class="line">        memset(f, 0, sizeof f);</span><br><span class="line">        for (i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            p[i] &#x3D; i;</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">            if (a[i])</span><br><span class="line">                cnt1++;</span><br><span class="line">            else</span><br><span class="line">                cnt2++;</span><br><span class="line">        &#125;</span><br><span class="line">        for (i &#x3D; 1; i &lt;&#x3D; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int u, v;</span><br><span class="line">            cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">            ll w &#x3D; qmi(2, i);</span><br><span class="line">            s[i] &#x3D; &#123;u, v, w&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        for (i &#x3D; 1; i &lt;&#x3D; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int pa &#x3D; find(s[i].a);</span><br><span class="line">            int pb &#x3D; find(s[i].b);</span><br><span class="line">            if (pa !&#x3D; pb)</span><br><span class="line">            &#123;</span><br><span class="line">                p[pa] &#x3D; pb;</span><br><span class="line">                add(s[i].a, s[i].b, s[i].w);</span><br><span class="line">                add(s[i].b, s[i].a, s[i].w);</span><br><span class="line">                p[pa] &#x3D; pb;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(1, 0);</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Divisibility-（HDU-6835）-（1009）&quot;&gt;&lt;a href=&quot;#Divisibility-（HDU-6835）-（1009）&quot; class=&quot;headerlink&quot; title=&quot;Divisibility  （HDU-6835） （1009）&quot;&gt;&lt;/a&gt;Divisibility  （HDU-6835） （1009）&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;题意：就是在什么情况下，对于b进制数x以及任意b进制数y，y的各位数字的和能被x整除可以推出y能被x整除；y的各位数字的和不能被x整除可以推出y不能被x整除。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="多校" scheme="https://stephencurry6666.github.io/categories/%E5%A4%9A%E6%A0%A1/"/>
    
    
      <category term="HDU" scheme="https://stephencurry6666.github.io/tags/HDU/"/>
    
  </entry>
  
  <entry>
    <title>2020HDU多校第五场</title>
    <link href="https://stephencurry6666.github.io/2020/08/07/2020HDU%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%BA%94%E5%9C%BA/"/>
    <id>https://stephencurry6666.github.io/2020/08/07/2020HDU%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%BA%94%E5%9C%BA/</id>
    <published>2020-08-07T08:39:47.267Z</published>
    <updated>2020-08-07T08:46:33.171Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Tetrahedron-（HDU-6814）（1001）"><a href="#Tetrahedron-（HDU-6814）（1001）" class="headerlink" title="Tetrahedron （HDU-6814）（1001）"></a>Tetrahedron （HDU-6814）（1001）</h3><p><strong>题意：已知直角四面体三个直角边长，求E(1/h^2)。</strong></p><a id="more"></a><p><strong>思路：这道题的话，等体积法，把1/h^2表示出来，E(1/h^2)=3E(1/a平方)。</strong></p><p><strong>AC代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxn &#x3D; 6000010;</span><br><span class="line">const int inf &#x3D; 0x3f3f3f3f;</span><br><span class="line">const int mod &#x3D; 998244353;</span><br><span class="line">using namespace std;</span><br><span class="line">ll fastpow(ll base, ll n, ll mod)</span><br><span class="line">&#123;</span><br><span class="line">    ll ans &#x3D; 1;</span><br><span class="line">    while (n)</span><br><span class="line">    &#123;</span><br><span class="line">        if (n &amp; 1)</span><br><span class="line">            ans *&#x3D; base % mod, ans %&#x3D; mod;</span><br><span class="line">        base *&#x3D; base, base %&#x3D; mod;</span><br><span class="line">        n &gt;&gt;&#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans % mod;</span><br><span class="line">&#125;</span><br><span class="line">int T;</span><br><span class="line">int n;</span><br><span class="line">int sum[maxn];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    for (ll i &#x3D; 1; i &lt;&#x3D; 6e6; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum[i] &#x3D; (sum[i - 1] + fastpow(i * i % mod, mod - 2, mod)) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    while (T--)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">        printf(&quot;%lld\n&quot;, 3ll * sum[n] * fastpow(n, mod - 2, mod) % mod); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Paperfolding-（HDU-6822）-（1009）"><a href="#Paperfolding-（HDU-6822）-（1009）" class="headerlink" title="Paperfolding   （HDU-6822） （1009）"></a>Paperfolding   （HDU-6822） （1009）</h3><p><strong>题意：将一张纸折n次，四个方向都可以折，折完后取中点，横竖分别切一刀（切十字），问最后纸被分成的数量的期望（模998244353）。</strong></p><p><strong>思路：<a href="https://www.cnblogs.com/stelayuri/p/13435083.html" target="_blank" rel="noopener">https://www.cnblogs.com/stelayuri/p/13435083.html</a></strong></p><p><strong>AC代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxn &#x3D; 100010;</span><br><span class="line">const int inf &#x3D; 0x3f3f3f3f;</span><br><span class="line">const ll mod &#x3D; 998244353;</span><br><span class="line">using namespace std;</span><br><span class="line">ll qpow(ll a, ll n)</span><br><span class="line">&#123;</span><br><span class="line">    ll ans &#x3D; 1;</span><br><span class="line">    a %&#x3D; mod;</span><br><span class="line">    while (n)</span><br><span class="line">    &#123;</span><br><span class="line">        if (n &amp; 1)</span><br><span class="line">            ans &#x3D; (ans * a) % mod;</span><br><span class="line">        n &gt;&gt;&#x3D; 1;</span><br><span class="line">        a &#x3D; (a * a) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    cout.tie(0);</span><br><span class="line">    int t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        ll n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        ll cnt1 &#x3D; qpow(2, n);</span><br><span class="line">        ll cnt2 &#x3D; qpow(3, n);</span><br><span class="line">        ll cnt3 &#x3D; qpow(cnt1, mod - 2);</span><br><span class="line">        cout &lt;&lt; (cnt1 + 1 + 2 * cnt2 * cnt3) % mod &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Tetrahedron-（HDU-6814）（1001）&quot;&gt;&lt;a href=&quot;#Tetrahedron-（HDU-6814）（1001）&quot; class=&quot;headerlink&quot; title=&quot;Tetrahedron （HDU-6814）（1001）&quot;&gt;&lt;/a&gt;Tetrahedron （HDU-6814）（1001）&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;题意：已知直角四面体三个直角边长，求E(1/h^2)。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="多校" scheme="https://stephencurry6666.github.io/categories/%E5%A4%9A%E6%A0%A1/"/>
    
    
      <category term="HDU" scheme="https://stephencurry6666.github.io/tags/HDU/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 637(Div.2)</title>
    <link href="https://stephencurry6666.github.io/2020/08/05/Codeforces%20637(Div.2)/"/>
    <id>https://stephencurry6666.github.io/2020/08/05/Codeforces%20637(Div.2)/</id>
    <published>2020-08-05T09:21:35.735Z</published>
    <updated>2020-08-05T09:26:49.643Z</updated>
    
    <content type="html"><![CDATA[<h3 id="A题"><a href="#A题" class="headerlink" title="A题"></a>A题</h3><p><strong>题意：给你n包零食，每包零食的重量为c-d~c+d之间，每包零食里面的每片的重量在a-b~a+b之间。现在给你一些数据，问你质量从a-b到a+b的n片能不能构成总质量从c-d到c+d的零食。</strong></p><a id="more"></a><p><strong>思路：这道题的话，我们分别把最小最大求出，比较一下即可。</strong></p><p><strong>AC代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxn &#x3D; 100010;</span><br><span class="line">const int inf &#x3D; 0x3f3f3f3f;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    cout.tie(0);</span><br><span class="line">    int t, n, a, b, c, d;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;</span><br><span class="line">        int minn1 &#x3D; a - b;</span><br><span class="line">        int minn2 &#x3D; c - d;</span><br><span class="line">        int maxx1 &#x3D; a + b;</span><br><span class="line">        int maxx2 &#x3D; c + d;</span><br><span class="line">        if (maxx1 * n &lt; minn2 || minn1 * n &gt; maxx2)</span><br><span class="line">            cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;</span><br><span class="line">        else</span><br><span class="line">            cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="B题"><a href="#B题" class="headerlink" title="B题"></a>B题</h3><p><strong>题意：定义“顶”：对于任意一个i，若满足a[i] &gt; a[i - 1] 与 a[i] &gt; a[i + 1]，则称i为“顶点”。给定区间长度为k，要求滑动窗口，统计[L，L + k - 1]中“顶点”个数（不含区间端点），“顶点”个数最多且左端点下标最小的的区间，输出该区间的L和共有的“顶点”个数。</strong></p><p><strong>思路：这道题的话，预处理一下前面有多少个山峰，sum[i]就是前i个数的山峰数量（包括第i个数），这样区间内的山峰数量就可以计算了。</strong></p><p><strong>AC代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxn &#x3D; 200010;</span><br><span class="line">const int inf &#x3D; 0x3f3f3f3f;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[maxn], sum[maxn];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    cout.tie(0);</span><br><span class="line">    int t, n, m;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">        memset(sum, 0, sizeof(sum));</span><br><span class="line">        int k &#x3D; 0, l &#x3D; 1;</span><br><span class="line">        for (int i &#x3D; 2; i &lt;&#x3D; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (a[i] &gt; a[i - 1] &amp;&amp; a[i] &gt; a[i + 1] &amp;&amp; i &lt; n)</span><br><span class="line">                sum[i] &#x3D; sum[i - 2] + 1;</span><br><span class="line">            else</span><br><span class="line">                sum[i] &#x3D; sum[i - 1];</span><br><span class="line">            if (i &gt;&#x3D; m &amp;&amp; sum[i - 1] - sum[i - m + 1] + 1 &gt; k)</span><br><span class="line">            &#123;</span><br><span class="line">                l &#x3D; i - m + 1;</span><br><span class="line">                k &#x3D; sum[i - 1] - sum[i - m + 1] + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; k &lt;&lt; &quot; &quot; &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C题"><a href="#C题" class="headerlink" title="C题"></a>C题</h3><p><strong>题意：一个序列生成器按照规则生成序列：依次考虑1~n，对于每个数i，我们为其选择在生成序列中位置，有生成的规则：生成一个数组r，第j个数的值记作r[j]，满足：j &lt;= r[j] &lt;= n，且当前生成序列当中（没有完全生成好，也就是有的位置没有生成的数），第r[j]个位置必须保证没有数生成（换句话说，若在先前操作中该位置已经填上了数了，那么r[j]不可以是该位置的下标），同时r[j]须越小越好（如果3、4和5均可，则选择3，因为值最小）。再生成count数组，记录r数组中每一个值的个数。譬如：r[3] = {2, 2, 3}，则count[4] = {0, 2, 1}（统计出现次数）。言归正传，在生成环节结束后（r和count数组生成完毕了），对于i生成的位置，该位置为count数组中数最大的位置的下标（如果count[4]最大，该数应填在生成序列中的第四个），若有多个位置下的值满足，则在其中选择任意一个位置。给定一个序列p，求是否可以按上述规律生成p。</strong></p><p><strong>思路：这道题的话，从1-n填数，在i位置填数，下一个要么在 i+1 的位置填，要么在[1，i-1]之间填。</strong></p><p><strong>AC代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxn &#x3D; 100010;</span><br><span class="line">const int inf &#x3D; 0x3f3f3f3f;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[maxn];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    cout.tie(0);</span><br><span class="line">    int t, n;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">        int ans &#x3D; 1, flag &#x3D; 1;</span><br><span class="line">        for (int i &#x3D; n; i; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            if (ans &#x3D;&#x3D; a[i])</span><br><span class="line">                ans++;</span><br><span class="line">            else if (ans &lt; a[i])</span><br><span class="line">                ans &#x3D; a[i];</span><br><span class="line">            else if (a[i + 1] - a[i] !&#x3D; 1)</span><br><span class="line">            &#123;</span><br><span class="line">                flag &#x3D; 0;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (flag)</span><br><span class="line">            cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;</span><br><span class="line">        else</span><br><span class="line">            cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;A题&quot;&gt;&lt;a href=&quot;#A题&quot; class=&quot;headerlink&quot; title=&quot;A题&quot;&gt;&lt;/a&gt;A题&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;题意：给你n包零食，每包零食的重量为c-d~c+d之间，每包零食里面的每片的重量在a-b~a+b之间。现在给你一些数据，问你质量从a-b到a+b的n片能不能构成总质量从c-d到c+d的零食。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="CF" scheme="https://stephencurry6666.github.io/categories/CF/"/>
    
    
      <category term="CF" scheme="https://stephencurry6666.github.io/tags/CF/"/>
    
  </entry>
  
  <entry>
    <title>高斯消元题二道</title>
    <link href="https://stephencurry6666.github.io/2020/08/03/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E9%A2%98%E4%BA%8C%E9%81%93/"/>
    <id>https://stephencurry6666.github.io/2020/08/03/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E9%A2%98%E4%BA%8C%E9%81%93/</id>
    <published>2020-08-03T08:02:27.407Z</published>
    <updated>2020-08-03T08:16:42.617Z</updated>
    
    <content type="html"><![CDATA[<h3 id="高斯消元模板1"><a href="#高斯消元模板1" class="headerlink" title="高斯消元模板1"></a>高斯消元模板1</h3><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">*功能: 列选主元消元法 </span><br><span class="line">*@Author: Stephencurry6666</span><br><span class="line">*@Language: C++</span><br><span class="line">*@File Name: gaosixiaoyuan.cpp</span><br><span class="line">*&#x2F;</span><br><span class="line">&#x2F;*</span><br><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 5;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出矩阵</span><br><span class="line">void printM(double a[][maxn], int n)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j &#x3D; 1; j &lt;&#x3D; n + 1; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;%10f,&quot;, a[i][j]);</span><br><span class="line">            printf(&quot;\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;选择列主元并进行消元</span><br><span class="line">void SelectColE(double a[][maxn], int n)</span><br><span class="line">&#123;</span><br><span class="line">    double temp; &#x2F;&#x2F;用于记录消元时的因数</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int r &#x3D; i;</span><br><span class="line">        for (int j &#x3D; i + 1; j &lt;&#x3D; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (fabs(a[j][i]) &gt; fabs(a[r][i]))</span><br><span class="line">                r &#x3D; j;</span><br><span class="line">        &#125;</span><br><span class="line">        if (r !&#x3D; i)</span><br><span class="line">            for (int j &#x3D; i; j &lt;&#x3D; n + 1; j++)</span><br><span class="line">                swap(a[i][j], a[r][j]); &#x2F;&#x2F;与最大主元所在行交换</span><br><span class="line">        for (int j &#x3D; i + 1; j &lt;&#x3D; n; j++)</span><br><span class="line">        &#123; &#x2F;&#x2F;消元</span><br><span class="line">            temp &#x3D; a[j][i] &#x2F; a[i][i];</span><br><span class="line">            for (int k &#x3D; i; k &lt;&#x3D; n + 1; k++)</span><br><span class="line">                a[j][k] -&#x3D; a[i][k] * temp;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;第%d列消元后：\n&quot;, i);</span><br><span class="line">        printM(a, 3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;高斯消元法(列选主元)</span><br><span class="line">void Gauss(double a[][maxn], int n)</span><br><span class="line">&#123;</span><br><span class="line">    SelectColE(a, n); &#x2F;&#x2F;列选主元并消元成上三角</span><br><span class="line">    printf(&quot;上三角的结果：\n&quot;);</span><br><span class="line">    printM(a, 3);</span><br><span class="line">    for (int i &#x3D; n; i &gt;&#x3D; 1; i--)</span><br><span class="line">    &#123; &#x2F;&#x2F;回代求解</span><br><span class="line">        for (int j &#x3D; i + 1; j &lt;&#x3D; n; j++)</span><br><span class="line">            a[i][n + 1] -&#x3D; a[i][j] * a[j][n + 1];</span><br><span class="line">        a[i][n + 1] &#x2F;&#x3D; a[i][i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;测试函数</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    double a[4][maxn] &#x3D; &#123;</span><br><span class="line">        &#123;0, 0, 0, 0, 0&#125;,</span><br><span class="line">        &#123;0, 2, 1, -1, 8&#125;,</span><br><span class="line">        &#123;0, -3, -1, 2, -11&#125;,</span><br><span class="line">        &#123;0, -2, 1, 2, -3&#125;&#125;;</span><br><span class="line">    Gauss(a, 3);</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; 3; i++)</span><br><span class="line">        printf(&quot;X%d &#x3D; %9f\n&quot;, i, a[i][4]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure><h3 id="高斯消元模板2"><a href="#高斯消元模板2" class="headerlink" title="高斯消元模板2"></a>高斯消元模板2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 用于求整数解得方程组. *&#x2F;</span><br><span class="line">&#x2F;*</span><br><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn &#x3D; 105;</span><br><span class="line"></span><br><span class="line">int equ, var; &#x2F;&#x2F; 有equ个方程，var个变元。增广阵行数为equ, 分别为0到equ - 1，列数为var + 1，分别为0到var.</span><br><span class="line">int a[maxn][maxn];</span><br><span class="line">int x[maxn];       &#x2F;&#x2F; 解集.</span><br><span class="line">bool free_x[maxn]; &#x2F;&#x2F; 判断是否是不确定的变元.</span><br><span class="line">int free_num;</span><br><span class="line"></span><br><span class="line">void Debug(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i, j;</span><br><span class="line">    for (i &#x3D; 0; i &lt; equ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (j &#x3D; 0; j &lt; var + 1; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; a[i][j] &lt;&lt; &quot; &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline int gcd(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    int t;</span><br><span class="line">    while (b !&#x3D; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        t &#x3D; b;</span><br><span class="line">        b &#x3D; a % b;</span><br><span class="line">        a &#x3D; t;</span><br><span class="line">    &#125;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline int lcm(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    return a * b &#x2F; gcd(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 高斯消元法解方程组(Gauss-Jordan elimination).(-2表示有浮点数解，但无整数解，-1表示无解，0表示唯一解，大于0表示无穷解，并返回自由变元的个数)</span><br><span class="line">int Gauss(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i, j, k;</span><br><span class="line">    int max_r; &#x2F;&#x2F; 当前这列绝对值最大的行.</span><br><span class="line">    int col;   &#x2F;&#x2F; 当前处理的列.</span><br><span class="line">    int ta, tb;</span><br><span class="line">    int LCM;</span><br><span class="line">    int temp;</span><br><span class="line">    int free_x_num;</span><br><span class="line">    int free_index;</span><br><span class="line">    &#x2F;&#x2F; 转换为阶梯阵.</span><br><span class="line">    col &#x3D; 0; &#x2F;&#x2F; 当前处理的列.</span><br><span class="line">    for (k &#x3D; 0; k &lt; equ &amp;&amp; col &lt; var; k++, col++)</span><br><span class="line">    &#123; &#x2F;&#x2F; 枚举当前处理的行.</span><br><span class="line">        &#x2F;&#x2F; 找到该col列元素绝对值最大的那行与第k行交换.(为了在除法时减小误差)</span><br><span class="line">        max_r &#x3D; k;</span><br><span class="line">        for (i &#x3D; k + 1; i &lt; equ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (abs(a[i][col]) &gt; abs(a[max_r][col]))</span><br><span class="line">                max_r &#x3D; i;</span><br><span class="line">        &#125;</span><br><span class="line">        if (max_r !&#x3D; k)</span><br><span class="line">        &#123; &#x2F;&#x2F; 与第k行交换.</span><br><span class="line">            for (j &#x3D; k; j &lt; var + 1; j++)</span><br><span class="line">                swap(a[k][j], a[max_r][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        if (a[k][col] &#x3D;&#x3D; 0)</span><br><span class="line">        &#123; &#x2F;&#x2F; 说明该col列第k行以下全是0了，则处理当前行的下一列.</span><br><span class="line">            k--;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        for (i &#x3D; k + 1; i &lt; equ; i++)</span><br><span class="line">        &#123; &#x2F;&#x2F; 枚举要删去的行.</span><br><span class="line">            if (a[i][col] !&#x3D; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                LCM &#x3D; lcm(abs(a[i][col]), abs(a[k][col]));</span><br><span class="line">                ta &#x3D; LCM &#x2F; abs(a[i][col]), tb &#x3D; LCM &#x2F; abs(a[k][col]);</span><br><span class="line">                if (a[i][col] * a[k][col] &lt; 0)</span><br><span class="line">                    tb &#x3D; -tb; &#x2F;&#x2F; 异号的情况是两个数相加.</span><br><span class="line">                for (j &#x3D; col; j &lt; var + 1; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    a[i][j] &#x3D; a[i][j] * ta - a[k][j] * tb;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Debug();</span><br><span class="line">    &#x2F;&#x2F; 1. 无解的情况: 化简的增广阵中存在(0, 0, ..., a)这样的行(a !&#x3D; 0).</span><br><span class="line">    for (i &#x3D; k; i &lt; equ; i++)</span><br><span class="line">    &#123; &#x2F;&#x2F; 对于无穷解来说，如果要判断哪些是自由变元，那么初等行变换中的交换就会影响，则要记录交换.</span><br><span class="line">        if (a[i][col] !&#x3D; 0)</span><br><span class="line">            return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 2. 无穷解的情况: 在var * (var + 1)的增广阵中出现(0, 0, ..., 0)这样的行，即说明没有形成严格的上三角阵.</span><br><span class="line">    &#x2F;&#x2F; 且出现的行数即为自由变元的个数.</span><br><span class="line">    if (k &lt; var)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; 首先，自由变元有var - k个，即不确定的变元至少有var - k个.</span><br><span class="line">        for (i &#x3D; k - 1; i &gt;&#x3D; 0; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F; 第i行一定不会是(0, 0, ..., 0)的情况，因为这样的行是在第k行到第equ行.</span><br><span class="line">            &#x2F;&#x2F; 同样，第i行一定不会是(0, 0, ..., a), a !&#x3D; 0的情况，这样的无解的.</span><br><span class="line">            free_x_num &#x3D; 0; &#x2F;&#x2F; 用于判断该行中的不确定的变元的个数，如果超过1个，则无法求解，它们仍然为不确定的变元.</span><br><span class="line">            for (j &#x3D; 0; j &lt; var; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if (a[i][j] !&#x3D; 0 &amp;&amp; free_x[j])</span><br><span class="line">                    free_x_num++, free_index &#x3D; j;</span><br><span class="line">            &#125;</span><br><span class="line">            if (free_x_num &gt; 1)</span><br><span class="line">                continue; &#x2F;&#x2F; 无法求解出确定的变元.</span><br><span class="line">            &#x2F;&#x2F; 说明就只有一个不确定的变元free_index，那么可以求解出该变元，且该变元是确定的.</span><br><span class="line">            temp &#x3D; a[i][var];</span><br><span class="line">            for (j &#x3D; 0; j &lt; var; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if (a[i][j] !&#x3D; 0 &amp;&amp; j !&#x3D; free_index)</span><br><span class="line">                    temp -&#x3D; a[i][j] * x[j];</span><br><span class="line">            &#125;</span><br><span class="line">            x[free_index] &#x3D; temp &#x2F; a[i][free_index]; &#x2F;&#x2F; 求出该变元.</span><br><span class="line">            free_x[free_index] &#x3D; 0;                  &#x2F;&#x2F; 该变元是确定的.</span><br><span class="line">        &#125;</span><br><span class="line">        return var - k; &#x2F;&#x2F; 自由变元有var - k个.</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 3. 唯一解的情况: 在var * (var + 1)的增广阵中形成严格的上三角阵.</span><br><span class="line">    &#x2F;&#x2F; 计算出Xn-1, Xn-2 ... X0.</span><br><span class="line">    for (i &#x3D; var - 1; i &gt;&#x3D; 0; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        temp &#x3D; a[i][var];</span><br><span class="line">        for (j &#x3D; i + 1; j &lt; var; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (a[i][j] !&#x3D; 0)</span><br><span class="line">                temp -&#x3D; a[i][j] * x[j];</span><br><span class="line">        &#125;</span><br><span class="line">        if (temp % a[i][i] !&#x3D; 0)</span><br><span class="line">            return -2; &#x2F;&#x2F; 说明有浮点数解，但无整数解.</span><br><span class="line">        x[i] &#x3D; temp &#x2F; a[i][i];</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    freopen(&quot;Input.txt&quot;, &quot;r&quot;, stdin);</span><br><span class="line">    int i, j;</span><br><span class="line">    while (scanf(&quot;%d %d&quot;, &amp;equ, &amp;var) !&#x3D; EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        memset(a, 0, sizeof(a));</span><br><span class="line">        memset(x, 0, sizeof(x));</span><br><span class="line">        memset(free_x, 1, sizeof(free_x)); &#x2F;&#x2F; 一开始全是不确定的变元.</span><br><span class="line">        for (i &#x3D; 0; i &lt; equ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for (j &#x3D; 0; j &lt; var + 1; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                scanf(&quot;%d&quot;, &amp;a[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;        Debug();</span><br><span class="line">        free_num &#x3D; Gauss();</span><br><span class="line">        if (free_num &#x3D;&#x3D; -1)</span><br><span class="line">            printf(&quot;无解!\n&quot;);</span><br><span class="line">        else if (free_num &#x3D;&#x3D; -2)</span><br><span class="line">            printf(&quot;有浮点数解，无整数解!\n&quot;);</span><br><span class="line">        else if (free_num &gt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;无穷多解! 自由变元个数为%d\n&quot;, free_num);</span><br><span class="line">            for (i &#x3D; 0; i &lt; var; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                if (free_x[i])</span><br><span class="line">                    printf(&quot;x%d 是不确定的\n&quot;, i + 1);</span><br><span class="line">                else</span><br><span class="line">                    printf(&quot;x%d: %d\n&quot;, i + 1, x[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            for (i &#x3D; 0; i &lt; var; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                printf(&quot;x%d: %d\n&quot;, i + 1, x[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异或方程组的高斯消元"><a href="#异或方程组的高斯消元" class="headerlink" title="异或方程组的高斯消元"></a>异或方程组的高斯消元</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;有equ个方程，var个变元。增广矩阵行数为equ,列数为var+1,分别为0到var</span><br><span class="line">  int equ,var;</span><br><span class="line">  int a[MAXN][MAXN]; &#x2F;&#x2F;增广矩阵</span><br><span class="line">  int x[MAXN]; &#x2F;&#x2F;解集</span><br><span class="line">  int free_x[MAXN];&#x2F;&#x2F;用来存储自由变元（多解枚举自由变元可以使用）</span><br><span class="line">  int free_num;&#x2F;&#x2F;自由变元的个数</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;返回值为-1表示无解，为0是唯一解，否则返回自由变元个数</span><br><span class="line">  int Gauss()</span><br><span class="line">  &#123;</span><br><span class="line">      int max_r,col,k;</span><br><span class="line">      free_num &#x3D; 0;</span><br><span class="line">      for(k &#x3D; 0, col &#x3D; 0 ; k &lt; equ &amp;&amp; col &lt; var ; k++, col++)</span><br><span class="line">      &#123;</span><br><span class="line">          max_r &#x3D; k;</span><br><span class="line">          for(int i &#x3D; k+1;i &lt; equ;i++)</span><br><span class="line">          &#123;</span><br><span class="line">              if(abs(a[i][col]) &gt; abs(a[max_r][col]))</span><br><span class="line">                  max_r &#x3D; i;</span><br><span class="line">          &#125;</span><br><span class="line">          if(a[max_r][col] &#x3D;&#x3D; 0)</span><br><span class="line">          &#123;</span><br><span class="line">              k--;</span><br><span class="line">              free_x[free_num++] &#x3D; col;&#x2F;&#x2F;这个是自由变元</span><br><span class="line">              continue;</span><br><span class="line">          &#125;</span><br><span class="line">          if(max_r !&#x3D; k)</span><br><span class="line">          &#123;</span><br><span class="line">              for(int j &#x3D; col; j &lt; var+1; j++)</span><br><span class="line">                  swap(a[k][j],a[max_r][j]);</span><br><span class="line">          &#125;</span><br><span class="line">          for(int i &#x3D; k+1;i &lt; equ;i++)</span><br><span class="line">          &#123;</span><br><span class="line">              if(a[i][col] !&#x3D; 0)</span><br><span class="line">              &#123;</span><br><span class="line">                 for(int j &#x3D; col;j &lt; var+1;j++)</span><br><span class="line">                      a[i][j] ^&#x3D; a[k][j];</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">     for(int i &#x3D; k;i &lt; equ;i++)&#x2F;&#x2F;进入此循环的条件：本身矩阵行大于列 或者 因为出现自由变元后使得非自由变元数比行数小</span><br><span class="line">          if(a[i][col] !&#x3D; 0)&#x2F;&#x2F;若等号右边是1则无解，因为等号左边已经消为0</span><br><span class="line">              return -1;&#x2F;&#x2F;无解</span><br><span class="line">      if(k &lt; var) return var-k;&#x2F;&#x2F;自由变元个数</span><br><span class="line">      &#x2F;&#x2F;唯一解，回代</span><br><span class="line">      for(int i &#x3D; var-1; i &gt;&#x3D; 0;i--)</span><br><span class="line">      &#123;</span><br><span class="line">          x[i] &#x3D; a[i][var];</span><br><span class="line">          for(int j &#x3D; i+1;j &lt; var;j++)</span><br><span class="line">              x[i] ^&#x3D; (a[i][j] &amp;&amp; x[j]);</span><br><span class="line">      &#125;</span><br><span class="line">      return 0;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="POJ-1222"><a href="#POJ-1222" class="headerlink" title="POJ-1222"></a>POJ-1222</h3><p><strong>有一个 5 * 6 的初始矩阵, 1 表示一个亮灯泡, 0 表示一个不亮的灯泡. 对 (i, j) 位置进行一次操作则 (i, j),(i + 1, j), (i - 1, j), (i, j - 1),  (i, j + 1) 位置的灯泡变为原来的相反状态, 输出一种能让所有灯泡都变成不亮状态的操作集合.</strong></p><p><strong>思路：这道题的话，可以用高斯消元来做。</strong></p><p><strong>AC代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN &#x3D; 3e2;</span><br><span class="line">int equ &#x3D; 30, var &#x3D; 30; &#x2F;&#x2F;有equ个方程,var个变元,增广矩正行数为equ,列数为var+1,从0开始计数</span><br><span class="line">int a[MAXN][MAXN];      &#x2F;&#x2F;增广矩正</span><br><span class="line">int free_x[MAXN];       &#x2F;&#x2F;用来存储自由变元(多解枚举自由变元可以使用)</span><br><span class="line">int free_num;           &#x2F;&#x2F;自由变元个数</span><br><span class="line">int x[MAXN];            &#x2F;&#x2F;解集</span><br><span class="line">int Gauss(void)</span><br><span class="line">&#123; &#x2F;&#x2F;返回-1表示无解,0表示有唯一解,否则返回自由变元个数</span><br><span class="line">    int max_r, col, k;</span><br><span class="line">    free_num &#x3D; 0;</span><br><span class="line">    for (k &#x3D; 0, col &#x3D; 0; k &lt; equ &amp;&amp; col &lt; var; k++, col++)</span><br><span class="line">    &#123;</span><br><span class="line">        max_r &#x3D; k;</span><br><span class="line">        for (int i &#x3D; k + 1; i &lt; equ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (abs(a[i][col] &gt; abs(a[max_r][col])))</span><br><span class="line">                max_r &#x3D; i;</span><br><span class="line">        &#125;</span><br><span class="line">        if (a[max_r][col] &#x3D;&#x3D; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            k--;</span><br><span class="line">            free_x[free_num++] &#x3D; col; &#x2F;&#x2F;这个是变元</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        if (max_r !&#x3D; k)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int j &#x3D; col; j &lt; var + 1; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                swap(a[k][j], a[max_r][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; k + 1; i &lt; equ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (a[i][col] !&#x3D; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                for (int j &#x3D; col; j &lt; var + 1; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    a[i][j] ^&#x3D; a[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i &#x3D; k; i &lt; equ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (a[i][col] !&#x3D; 0)</span><br><span class="line">            return -1; &#x2F;&#x2F;无解</span><br><span class="line">    &#125;</span><br><span class="line">    if (k &lt; var)</span><br><span class="line">        return var - k; &#x2F;&#x2F;返回自由变元个数</span><br><span class="line">    for (int i &#x3D; var - 1; i &gt;&#x3D; 0; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        x[i] &#x3D; a[i][var];</span><br><span class="line">        for (int j &#x3D; i + 1; j &lt; var; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            x[i] ^&#x3D; (a[i][j] &amp;&amp; x[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int t, n;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    for (int cas &#x3D; 1; cas &lt;&#x3D; t; cas++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 30; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; a[i][30];</span><br><span class="line">            x[i] &#x3D; 0; &#x2F;&#x2F;清空数组</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 30; i++)</span><br><span class="line">        &#123; &#x2F;&#x2F;构造增广矩阵</span><br><span class="line">            int x1 &#x3D; i &#x2F; 6;</span><br><span class="line">            int y1 &#x3D; i % 6;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; 30; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                int x2 &#x3D; j &#x2F; 6;</span><br><span class="line">                int y2 &#x3D; j % 6;</span><br><span class="line">                if (abs(x1 - x2) + abs(y1 - y2) &lt; 2)</span><br><span class="line">                    a[j][i] &#x3D; 1;</span><br><span class="line">                else</span><br><span class="line">                    a[j][i] &#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Gauss();</span><br><span class="line">        cout &lt;&lt; &quot;PUZZLE #&quot; &lt;&lt; cas &lt;&lt; endl;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 30; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; x[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">            if ((i + 1) % 6 &#x3D;&#x3D; 0)</span><br><span class="line">                cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="POJ-1830"><a href="#POJ-1830" class="headerlink" title="POJ-1830"></a>POJ-1830</h3><p><strong>题意：中文题，不过多叙述题意。</strong></p><p><strong>思路：<a href="https://blog.csdn.net/immiao/article/details/17342143" target="_blank" rel="noopener">https://blog.csdn.net/immiao/article/details/17342143</a></strong></p><p><strong>AC代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int A[35][35];</span><br><span class="line">int B[35];</span><br><span class="line">int n;</span><br><span class="line">int ans;</span><br><span class="line">void swap(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    int temp;</span><br><span class="line">    for (i &#x3D; 0; i &lt;&#x3D; n - 1; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp &#x3D; A[a][i];</span><br><span class="line">        A[a][i] &#x3D; A[b][i];</span><br><span class="line">        A[b][i] &#x3D; temp;</span><br><span class="line">    &#125;</span><br><span class="line">    temp &#x3D; B[a];</span><br><span class="line">    B[a] &#x3D; B[b];</span><br><span class="line">    B[b] &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line">void gauss()</span><br><span class="line">&#123;</span><br><span class="line">    int i, j, k;</span><br><span class="line">    for (i &#x3D; 0; i &lt;&#x3D; n - 1; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        bool flag &#x3D; false;</span><br><span class="line">        if (!A[i][i])</span><br><span class="line">        &#123;</span><br><span class="line">            for (j &#x3D; i + 1; j &lt;&#x3D; n - 1; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if (A[j][i])</span><br><span class="line">                &#123;</span><br><span class="line">                    swap(i, j);</span><br><span class="line">                    flag &#x3D; true;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (!flag)</span><br><span class="line">                continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (j &#x3D; i + 1; j &lt;&#x3D; n - 1; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (A[j][i])</span><br><span class="line">            &#123;</span><br><span class="line">                for (k &#x3D; i; k &lt;&#x3D; n - 1; k++)</span><br><span class="line">                    A[j][k] ^&#x3D; A[i][k];</span><br><span class="line">                B[j] ^&#x3D; B[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (i &#x3D; n - 1; i &gt;&#x3D; 0; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        if (A[i][i] &#x3D;&#x3D; 0 &amp;&amp; B[i] &#x3D;&#x3D; 1)</span><br><span class="line">        &#123;</span><br><span class="line">            ans &#x3D; -1;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (A[i][i] &#x3D;&#x3D; 0)</span><br><span class="line">            ans &#x3D; ans &lt;&lt; 1;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            for (j &#x3D; i - 1; j &gt;&#x3D; 0; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                if (A[j][i])</span><br><span class="line">                &#123;</span><br><span class="line">                    A[j][i] ^&#x3D; A[i][i];</span><br><span class="line">                    B[j] ^&#x3D; B[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int T;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    while (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        ans &#x3D; 1;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">        int i;</span><br><span class="line"></span><br><span class="line">        int s[35], e[35];</span><br><span class="line"></span><br><span class="line">        for (i &#x3D; 0; i &lt;&#x3D; n - 1; i++)</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;s[i]);</span><br><span class="line">        for (i &#x3D; 0; i &lt;&#x3D; n - 1; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;e[i]);</span><br><span class="line">            if (e[i] !&#x3D; s[i])</span><br><span class="line">                B[i] &#x3D; 1;</span><br><span class="line">            else</span><br><span class="line">                B[i] &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        memset(A, 0, sizeof(A));</span><br><span class="line">        for (i &#x3D; 0; i &lt;&#x3D; n - 1; i++)</span><br><span class="line">            A[i][i] &#x3D; 1;</span><br><span class="line">        while (1)</span><br><span class="line">        &#123;</span><br><span class="line">            int a, b;</span><br><span class="line">            scanf(&quot;%d%d&quot;, &amp;a, &amp;b);</span><br><span class="line">            if (!a &amp;&amp; !b)</span><br><span class="line">                break;</span><br><span class="line">            A[b - 1][a - 1] &#x3D; 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        gauss();</span><br><span class="line">        if (ans !&#x3D; -1)</span><br><span class="line">            printf(&quot;%d\n&quot;, ans);</span><br><span class="line">        else</span><br><span class="line">            printf(&quot;Oh,it&#39;s impossible~!!\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;高斯消元模板1&quot;&gt;&lt;a href=&quot;#高斯消元模板1&quot; class=&quot;headerlink&quot; title=&quot;高斯消元模板1&quot;&gt;&lt;/a&gt;高斯消元模板1&lt;/h3&gt;
    
    </summary>
    
    
      <category term="高斯消元" scheme="https://stephencurry6666.github.io/categories/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/"/>
    
    
      <category term="高斯消元" scheme="https://stephencurry6666.github.io/tags/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/"/>
    
  </entry>
  
  <entry>
    <title>2020HDU多校第四场</title>
    <link href="https://stephencurry6666.github.io/2020/07/31/2020HDU%E5%A4%9A%E6%A0%A1%E7%AC%AC%E5%9B%9B%E5%9C%BA/"/>
    <id>https://stephencurry6666.github.io/2020/07/31/2020HDU%E5%A4%9A%E6%A0%A1%E7%AC%AC%E5%9B%9B%E5%9C%BA/</id>
    <published>2020-07-31T09:03:54.055Z</published>
    <updated>2020-07-31T09:17:33.157Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Kindergarten-Physics-（HDU-6812）-1011"><a href="#Kindergarten-Physics-（HDU-6812）-1011" class="headerlink" title="Kindergarten Physics （HDU-6812） (1011)"></a>Kindergarten Physics （HDU-6812） (1011)</h3><p><strong>题意：给你两个质点a和b，然后给出a和b的质量和它们之间的距离h，问你经过万有引力的作用之后，在经过t0时间之后，它们之间的距离。</strong></p><a id="more"></a><p><strong>思路：这道题的话，我们需要套用物理公式。$F(万有引力)=(Gxmaxmb)/rxr$,$F=ma$,$S=(1/2)xaxtxt$。</strong></p><p><strong>AC代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxx &#x3D; 100010;</span><br><span class="line">const int inf &#x3D; 0x3f3f3f3f;</span><br><span class="line">const int mod &#x3D; 1000000009;</span><br><span class="line">const int G &#x3D; 6.67430 * (1e-11);</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    cout.tie(0);</span><br><span class="line">    int t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        double a, b, d, t0;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; d &gt;&gt; t0;</span><br><span class="line">        double a1 &#x3D; G * b &#x2F; (d * d);</span><br><span class="line">        double a2 &#x3D; G * a &#x2F; (d * d);</span><br><span class="line">        double s1 &#x3D; (1 &#x2F; 2) * a1 * t0 * t0;</span><br><span class="line">        double s2 &#x3D; (1 &#x2F; 2) * a2 * t0 * t0;</span><br><span class="line">        d &#x3D; d - s1 - s2;</span><br><span class="line">        printf(&quot;%.6lf\n&quot;, d);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Blow-up-the-Enemy-（HDU-6803）-1002"><a href="#Blow-up-the-Enemy-（HDU-6803）-1002" class="headerlink" title="Blow up the Enemy （HDU-6803） (1002)"></a>Blow up the Enemy （HDU-6803） (1002)</h3><p><strong>题意：给定有n种武器，每种武器有2种属性：伤害A和冷却时间D，张三和爸爸各从n种武器种选择一个武器进行对战。张三和爸爸各从n种武器种选择一个武器进行对战。每人初始HP=100，每种武器每次攻击可以使得对手HP值减去Ai，HP≤0的一方出局。初始时武器未冷却，每攻击一次，武器冷却Di时长，Di时间后，可立刻攻击。爸爸每次从n种武器种等概率地随机选择一种武器，若二人的HP同时小于等于0，那么二人各有0.5的概率获胜。请帮助张三选择武器，使得他能够以最大的概率获胜。</strong></p><p><strong>思路：这道题的话，我们可以先算出每种武器打掉100血的时间，然后选择最小的，然后再分别与每种武器进行比较，计算概率即可。</strong></p><p><strong>AC代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxx &#x3D; 10010;</span><br><span class="line">const int inf &#x3D; 0x3f3f3f3f;</span><br><span class="line">const int mod &#x3D; 1000000009;</span><br><span class="line">const int G &#x3D; 6.67430 * (1e-11);</span><br><span class="line">using namespace std;</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    int a;</span><br><span class="line">    int d;</span><br><span class="line">    double tim;</span><br><span class="line">&#125; edge[maxx];</span><br><span class="line">bool cmp(node x, node y)</span><br><span class="line">&#123;</span><br><span class="line">    return x.tim &lt; y.tim;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    cout.tie(0);</span><br><span class="line">    int t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        int n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; edge[i].a &gt;&gt; edge[i].d;</span><br><span class="line">            if (100 % edge[i].a &#x3D;&#x3D; 0)</span><br><span class="line">                edge[i].tim &#x3D; (100 &#x2F; edge[i].a - 1) * edge[i].d;</span><br><span class="line">            else</span><br><span class="line">                edge[i].tim &#x3D; (100 &#x2F; edge[i].a) * edge[i].d;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(edge, edge + n, cmp);</span><br><span class="line">        double minn &#x3D; edge[0].tim;</span><br><span class="line">        double ans &#x3D; 1;</span><br><span class="line">        for (int i &#x3D; 1; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (edge[i].tim &#x3D;&#x3D; minn)</span><br><span class="line">                ans++;</span><br><span class="line">            else</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        double cnt &#x3D; 1 - (ans &#x2F; n) * 0.5;</span><br><span class="line">        printf(&quot;%.6lf\n&quot;, cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Equal-Sentences-（HDU-6806）-1005"><a href="#Equal-Sentences-（HDU-6806）-1005" class="headerlink" title="Equal Sentences （HDU-6806） (1005)"></a>Equal Sentences （HDU-6806） (1005)</h3><p><strong>题意：给你一串字符串S，现在有两个要求：1. S中的单词的多集与T中的单词的多集相同。2. 对于一个单词概要，它在S中的第i次出现和在T中的第i次出现的索引差异不超过1。(句子中的第k个单词的索引是k。)只要单词在两个句子中出现至少i次，这对所有的a和i都成立。然后我们可以说S和T几乎相同。但是请注意，“几乎相等”不是一个等价关系，不像它的名字。也就是说，如果句子A和B接近相等，B和C接近相等，那么A和C可能不接近相等。然后问你有多少个句子与S几乎相同。</strong></p><p><strong>思路：这道题的话，在读完题之后和jp在讨论之后，发现就是如果前后单词是一样的话，那么就算一个句子。所以我想到了上楼梯，和这个有异曲同工之妙。于是我就列了dp方程，那就是n=1的时候，只有1种；n=2的时候分两种情况，相等或者不相等；n&gt;=3的时候，也是分相等和不相等两种情况。当n&gt;=3的时候，要是当前和上一个相等，那就直接$dp[i]=dp[i-1]$；要是不相等，那就是等于前两个相加$dp[i]=dp[i-1]+dp[i-2]$。</strong></p><p><strong>AC代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxx &#x3D; 200010;</span><br><span class="line">const int inf &#x3D; 0x3f3f3f3f;</span><br><span class="line">const int mod &#x3D; 1e9 + 7;</span><br><span class="line">const int G &#x3D; 6.67430 * (1e-11);</span><br><span class="line">using namespace std;</span><br><span class="line">int dp[maxx];</span><br><span class="line">string s[maxx];</span><br><span class="line">int solve(int n)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">        cin &gt;&gt; s[i];</span><br><span class="line">    dp[1] &#x3D; 1;</span><br><span class="line">    if (s[1] !&#x3D; s[2])</span><br><span class="line">        dp[2] &#x3D; 2;</span><br><span class="line">    else</span><br><span class="line">        dp[2] &#x3D; 1;</span><br><span class="line">    for (int i &#x3D; 3; i &lt;&#x3D; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (s[i] !&#x3D; s[i - 1])</span><br><span class="line">            dp[i] &#x3D; (dp[i - 1] + dp[i - 2]) % mod;</span><br><span class="line">        else</span><br><span class="line">            dp[i] &#x3D; dp[i - 1] % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n];</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    cout.tie(0);</span><br><span class="line">    int t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        int n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        memset(dp, 0, sizeof(dp));</span><br><span class="line">        int ans &#x3D; solve(n);</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Deliver-the-Cake-（HDU-6805）（1004）"><a href="#Deliver-the-Cake-（HDU-6805）（1004）" class="headerlink" title="Deliver the Cake （HDU-6805）（1004）"></a>Deliver the Cake （HDU-6805）（1004）</h3><p><strong>题意：给出一个nm的无向图，有边权。张三在起点s，目标是t。点分成左点右点和中间点，到左点的时候必须用左手，到右点的时候必须用右手，中间点没有特殊要求。张三每次切换左右手都要花费额外的时间，询问起点到终点的最短路。</strong></p><p><strong>思路：这道题的话，我们把每个点拆成两个点，L点拆成两个L，R点拆成两个R，M点拆成一个L一个R。然后跑Dijkstra+优先队列即可。</strong></p><p><strong>AC代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxn &#x3D; 4e5 + 10;</span><br><span class="line">const ll inf &#x3D; 1e18;</span><br><span class="line">int n, m, s, t, cost;</span><br><span class="line">string ss;</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">    int u;</span><br><span class="line">    int v;</span><br><span class="line">    int w;</span><br><span class="line">    int next;</span><br><span class="line">&#125; edge[maxn * 8];</span><br><span class="line">int head[maxn * 3];</span><br><span class="line">int tol &#x3D; 0;</span><br><span class="line">void addedge(int u, int v, int w)</span><br><span class="line">&#123;</span><br><span class="line">    edge[tol].u &#x3D; u;</span><br><span class="line">    edge[tol].v &#x3D; v;</span><br><span class="line">    edge[tol].w &#x3D; w;</span><br><span class="line">    edge[tol].next &#x3D; head[u];</span><br><span class="line">    head[u] &#x3D; tol++;</span><br><span class="line"></span><br><span class="line">    edge[tol].u &#x3D; v;</span><br><span class="line">    edge[tol].v &#x3D; u;</span><br><span class="line">    edge[tol].w &#x3D; w;</span><br><span class="line">    edge[tol].next &#x3D; head[v];</span><br><span class="line">    head[v] &#x3D; tol++;</span><br><span class="line">&#125;</span><br><span class="line">ll d[maxn];</span><br><span class="line">int visit[maxn];</span><br><span class="line">char wjm[maxn];</span><br><span class="line">struct qnode</span><br><span class="line">&#123;</span><br><span class="line">    int v;</span><br><span class="line">    ll w;</span><br><span class="line">    bool operator&lt;(const qnode &amp;r) const</span><br><span class="line">    &#123;</span><br><span class="line">        return w &gt; r.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">void dij(int s)</span><br><span class="line">&#123;</span><br><span class="line">    memset(visit, 0, sizeof(visit));</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; 2 * n; i++)</span><br><span class="line">        d[i] &#x3D; inf;</span><br><span class="line">    priority_queue&lt;qnode&gt; q;</span><br><span class="line">    d[s] &#x3D; 0;</span><br><span class="line">    q.push(&#123;s, 0&#125;);</span><br><span class="line">    qnode tmp;</span><br><span class="line">    while (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        tmp &#x3D; q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        int u &#x3D; tmp.v;</span><br><span class="line">        if (visit[u])</span><br><span class="line">            continue;</span><br><span class="line">        visit[u] &#x3D; 1;</span><br><span class="line">        for (int i &#x3D; head[u]; i !&#x3D; -1; i &#x3D; edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            int v &#x3D; edge[i].v;</span><br><span class="line">            int tt;</span><br><span class="line">            if (wjm[u] &#x3D;&#x3D; wjm[v])</span><br><span class="line">                tt &#x3D; 0;</span><br><span class="line">            else</span><br><span class="line">                tt &#x3D; 1;</span><br><span class="line">            if (!visit[v] &amp;&amp; d[v] &gt; d[u] + edge[i].w + tt * cost)</span><br><span class="line">            &#123;</span><br><span class="line">                d[v] &#x3D; d[u] + edge[i].w + tt * cost;</span><br><span class="line">                q.push(&#123;v, d[v]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int T;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;T);</span><br><span class="line">    while (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%d%d%d%d%d&quot;, &amp;n, &amp;m, &amp;s, &amp;t, &amp;cost);</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; n * 2; i++)</span><br><span class="line">            head[i] &#x3D; -1;</span><br><span class="line">        cin &gt;&gt; ss;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (ss[i - 1] &#x3D;&#x3D; &#39;L&#39;)</span><br><span class="line">            &#123;</span><br><span class="line">                wjm[i] &#x3D; &#39;L&#39;;</span><br><span class="line">                wjm[i + n] &#x3D; &#39;L&#39;;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (ss[i - 1] &#x3D;&#x3D; &#39;R&#39;)</span><br><span class="line">            &#123;</span><br><span class="line">                wjm[i] &#x3D; &#39;R&#39;;</span><br><span class="line">                wjm[i + n] &#x3D; &#39;R&#39;;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                wjm[i] &#x3D; &#39;L&#39;;</span><br><span class="line">                wjm[i + n] &#x3D; &#39;R&#39;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        tol &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int u, v, w;</span><br><span class="line">            scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);</span><br><span class="line">            addedge(u, v, w);</span><br><span class="line">            addedge(u + n, v, w);</span><br><span class="line">            addedge(u + n, v + n, w);</span><br><span class="line">            addedge(u, v + n, w);</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans &#x3D; 1e18;</span><br><span class="line">        dij(s);</span><br><span class="line">        ans &#x3D; min(ans, d[t]);</span><br><span class="line">        ans &#x3D; min(ans, d[t + n]);</span><br><span class="line">        dij(s + n);</span><br><span class="line">        ans &#x3D; min(ans, d[t]);</span><br><span class="line">        ans &#x3D; min(ans, d[t + n]);</span><br><span class="line">        printf(&quot;%lld\n&quot;, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Kindergarten-Physics-（HDU-6812）-1011&quot;&gt;&lt;a href=&quot;#Kindergarten-Physics-（HDU-6812）-1011&quot; class=&quot;headerlink&quot; title=&quot;Kindergarten Physics （HDU-6812） (1011)&quot;&gt;&lt;/a&gt;Kindergarten Physics （HDU-6812） (1011)&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;题意：给你两个质点a和b，然后给出a和b的质量和它们之间的距离h，问你经过万有引力的作用之后，在经过t0时间之后，它们之间的距离。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="多校" scheme="https://stephencurry6666.github.io/categories/%E5%A4%9A%E6%A0%A1/"/>
    
    
      <category term="HDU" scheme="https://stephencurry6666.github.io/tags/HDU/"/>
    
  </entry>
  
  <entry>
    <title>2020HDU多校第三场</title>
    <link href="https://stephencurry6666.github.io/2020/07/30/2020HDU%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%B8%89%E5%9C%BA/"/>
    <id>https://stephencurry6666.github.io/2020/07/30/2020HDU%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%B8%89%E5%9C%BA/</id>
    <published>2020-07-30T02:16:42.781Z</published>
    <updated>2020-07-30T02:29:19.660Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Tokitsukaze-and-Multiple-（HDU-6794）-1004"><a href="#Tokitsukaze-and-Multiple-（HDU-6794）-1004" class="headerlink" title="Tokitsukaze and Multiple （HDU-6794）  (1004)"></a>Tokitsukaze and Multiple （HDU-6794）  (1004)</h3><p><strong>题意：有一个长度为n的序列，你现在将序列中连续两个元素合并多次，然后问你在经过一些操作之后，能得到的p的倍数元素的最大可能数量。</strong></p><a id="more"></a><p><strong>思路：这道题的话，我们用map函数来做。</strong></p><p><strong>AC代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxx &#x3D; 100010;</span><br><span class="line">const int inf &#x3D; 0x3f3f3f3f;</span><br><span class="line">const int mod &#x3D; 1000000009;</span><br><span class="line">using namespace std;</span><br><span class="line">map&lt;ll,ll&gt;mapp;</span><br><span class="line">ll a[maxx];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    cout.tie(0);</span><br><span class="line">    int t, n, p;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; p;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">            a[i] %&#x3D; p;</span><br><span class="line">        &#125;</span><br><span class="line">        int ans &#x3D; 0, sum &#x3D; 0;</span><br><span class="line">        mapp[0] &#x3D; 1;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum +&#x3D; a[i];</span><br><span class="line">            sum %&#x3D; p;</span><br><span class="line">            if (mapp[sum] !&#x3D; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                mapp.clear();</span><br><span class="line">                mapp[0] &#x3D; 1;</span><br><span class="line">                sum &#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                mapp[sum] &#x3D; 1;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Little-W-and-Contest-（HDU-6795）-（1005）"><a href="#Little-W-and-Contest-（HDU-6795）-（1005）" class="headerlink" title="Little W and Contest （HDU-6795） （1005）"></a>Little W and Contest （HDU-6795） （1005）</h3><p><strong>题意：现在有n个人，然后每三个人可以组成一队，但是三个之间不能互相认识。比如A认识B，B认识C，那么A就可以通过B认识C。问你随着联系的增加，每次能组成几个队伍。</strong></p><p><strong>这道题的话，我们用并查集来做，将相互认识的人放在同一个并查集中，同一个并查集中的人不能够成为队友。保存总的1能力值人数为num[0]，总的2能力值人数为num[1]。每个并查集中pre[i][0]表示祖先为i点的并查集中的1能力值人数，pre[i][1]表示2能力值人数，队伍组成的情况有两种： 1 2 2 和 2 2 2。注意去重，取余的位置和防止爆int，不要对分子先进行取模，防止造成分子除分母无法刚好除尽的情况，然后对于每次交友之后，形成不同集合之后，对于结果都是有影响的，要去除原本u和v所在的集合与这两个集合之外人组成team的数量，同时也要注意u1*v2等等时可能爆int，要加ll。</strong></p><p><strong>AC代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxx &#x3D; 100010;</span><br><span class="line">const int inf &#x3D; 0x3f3f3f3f;</span><br><span class="line">const int mod &#x3D; 1e9 + 7;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[maxx];</span><br><span class="line">int pre[maxx];</span><br><span class="line">int f[maxx][2];</span><br><span class="line">int num[2];</span><br><span class="line">int getf(int a)</span><br><span class="line">&#123;</span><br><span class="line">    if (a &#x3D;&#x3D; pre[a])</span><br><span class="line">        return a;</span><br><span class="line">    return pre[a] &#x3D; getf(pre[a]);</span><br><span class="line">&#125;</span><br><span class="line">int mer(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    int fa &#x3D; getf(a);</span><br><span class="line">    int fb &#x3D; getf(b);</span><br><span class="line">    if (fa &#x3D;&#x3D; fb)</span><br><span class="line">        return fa;</span><br><span class="line">    pre[fb] &#x3D; fa;</span><br><span class="line">    f[fa][0] +&#x3D; f[fb][0];</span><br><span class="line">    f[fa][1] +&#x3D; f[fb][1];</span><br><span class="line">    return fa;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    cout.tie(0);</span><br><span class="line">    int t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        memset(f, 0, sizeof(f));</span><br><span class="line">        num[0] &#x3D; num[1] &#x3D; 0;</span><br><span class="line">        int n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            pre[i] &#x3D; i;</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">            if (a[i] &#x3D;&#x3D; 1)</span><br><span class="line">            &#123;</span><br><span class="line">                num[0]++;</span><br><span class="line">                f[i][0] &#x3D; 1;</span><br><span class="line">            &#125;</span><br><span class="line">            if (a[i] &#x3D;&#x3D; 2)</span><br><span class="line">            &#123;</span><br><span class="line">                num[1]++;</span><br><span class="line">                f[i][1] &#x3D; 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans &#x3D; 1ll * num[1] * (num[1] - 1) &#x2F; 2 % mod * num[0] % mod + 1ll * num[1] * (num[1] - 1) * (num[1] - 2) &#x2F; 6 % mod;</span><br><span class="line">        cout &lt;&lt; ans % mod &lt;&lt; endl;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; n - 1; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int u, v;</span><br><span class="line">            cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">            if (i &gt;&#x3D; n - 2)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; &quot;0&quot; &lt;&lt; endl;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            int fa &#x3D; getf(u);</span><br><span class="line">            int fb &#x3D; getf(v);</span><br><span class="line">            int u1 &#x3D; f[fa][0], u2 &#x3D; f[fa][1];</span><br><span class="line">            int v1 &#x3D; f[fb][0], v2 &#x3D; f[fb][1];</span><br><span class="line">            int cnt &#x3D; mer(u, v);</span><br><span class="line">            int x &#x3D; f[cnt][0];</span><br><span class="line">            int y &#x3D; f[cnt][1];</span><br><span class="line">            ans -&#x3D; 1ll * u1 * v2 % mod * (num[1] - y) % mod;</span><br><span class="line">            if (ans &lt; 0)</span><br><span class="line">                ans +&#x3D; mod;</span><br><span class="line">            ans -&#x3D; 1ll * u2 * v1 % mod * (num[1] - y) % mod;</span><br><span class="line">            if (ans &lt; 0)</span><br><span class="line">                ans +&#x3D; mod;</span><br><span class="line">            ans -&#x3D; 1ll * u2 * v2 % mod * (n - x - y) % mod;</span><br><span class="line">            if (ans &lt; 0)</span><br><span class="line">                ans +&#x3D; mod;</span><br><span class="line">            cout &lt;&lt; ans % mod &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Tokitsukaze-and-Rescue-HDU-6797-1007"><a href="#Tokitsukaze-and-Rescue-HDU-6797-1007" class="headerlink" title="Tokitsukaze and Rescue (HDU-6797) (1007)"></a>Tokitsukaze and Rescue (HDU-6797) (1007)</h3><p><strong>题意：给出一张无向完全图，现在要求删除k条边，问删除后的最短路的最大值是多少，k最大是5。</strong></p><p><strong>思路：这道题的话，我们可以发现题目中说了所有的边权均是随机数，然后实现就好了，然后用Dijkstra算法。然后找最短路上的边，用记录每个点的前驱来实现的，换句话说每次最短路有且仅有一条。</strong></p><p><strong>AC代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxx &#x3D; 110;</span><br><span class="line">const int inf &#x3D; 0x3f3f3f3f;</span><br><span class="line">const int mod &#x3D; 1000000009;</span><br><span class="line">using namespace std;</span><br><span class="line">int g[maxx][maxx], pre[6][maxx], dis[maxx];</span><br><span class="line">bool vis[maxx];</span><br><span class="line">int n, ans;</span><br><span class="line">void Dijkstra(int m)</span><br><span class="line">&#123;</span><br><span class="line">    memset(dis, inf, sizeof(int) * (n + 5));</span><br><span class="line">    memset(vis, false, n + 5);</span><br><span class="line">    dis[1] &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 1; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int minn &#x3D; inf;</span><br><span class="line">        int u &#x3D; -1;</span><br><span class="line">        for (int j &#x3D; 1; j &lt;&#x3D; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (!vis[j] &amp;&amp; dis[j] &lt; minn)</span><br><span class="line">            &#123;</span><br><span class="line">                minn &#x3D; dis[j];</span><br><span class="line">                u &#x3D; j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[u] &#x3D; true;</span><br><span class="line">        for (int v &#x3D; 1; v &lt;&#x3D; n; v++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (dis[v] &gt; dis[u] + g[u][v])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v] &#x3D; dis[u] + g[u][v];</span><br><span class="line">                pre[m][v] &#x3D; u;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void dfs(int m)</span><br><span class="line">&#123;</span><br><span class="line">    Dijkstra(m);</span><br><span class="line">    if (!m)</span><br><span class="line">    &#123;</span><br><span class="line">        ans &#x3D; max(ans, dis[n]);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    int pos &#x3D; n;</span><br><span class="line">    while (pos !&#x3D; 1)</span><br><span class="line">    &#123;</span><br><span class="line">        int u &#x3D; pos, v &#x3D; pre[m][pos];</span><br><span class="line">        int temp &#x3D; g[u][v];</span><br><span class="line">        g[u][v] &#x3D; g[v][u] &#x3D; inf;</span><br><span class="line">        dfs(m - 1);</span><br><span class="line">        g[u][v] &#x3D; g[v][u] &#x3D; temp;</span><br><span class="line">        pos &#x3D; pre[m][pos];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    cout.tie(0);</span><br><span class="line">    int t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        int m;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; n * (n - 1) &#x2F; 2; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int u, v, w;</span><br><span class="line">            cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">            g[u][v] &#x3D; g[v][u] &#x3D; w;</span><br><span class="line">        &#125;</span><br><span class="line">        ans &#x3D; 0;</span><br><span class="line">        dfs(m);</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Parentheses-Matching-（HDU-6799）（1009）"><a href="#Parentheses-Matching-（HDU-6799）（1009）" class="headerlink" title="Parentheses Matching （HDU-6799）（1009）"></a>Parentheses Matching （HDU-6799）（1009）</h3><p><strong>题意：给你一个含有’(‘，’)’，<em>‘</em>‘的字符串，允许把’*’变为’(‘或’)’或’ ‘，求最小的括号匹配合法序列。</strong></p><p><strong>思路：这道题的话，想要最小的序列，那就需要尽量减少<em>‘</em>’<em>的使用，所以我们需要在原序列中就尽可能的匹配括号。然后可以发现右括号都集中在左边，左括号都集中在右边，于是要构造最小的序列的话就对于右括号来说，尽可能的选靠左的</em>‘<em>’</em>变左括号，而对于左括号来说，尽可能的选靠右的‘*’变右括号即可。</strong></p><p><strong>AC代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxx&#x3D;100010;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef pair&lt;char,int&gt;pii;</span><br><span class="line">stack&lt;pii&gt;q;</span><br><span class="line">char s[maxx];</span><br><span class="line">char t[maxx];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    cout.tie(0);</span><br><span class="line">    int T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    while (T--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; s + 1;</span><br><span class="line">        int n &#x3D; strlen(s + 1);</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            t[i] &#x3D; s[i];</span><br><span class="line">            if (s[i] &#x3D;&#x3D; &#39;(&#39;)</span><br><span class="line">                q.push(pii(s[i], i));</span><br><span class="line">            if (s[i] &#x3D;&#x3D; &#39;)&#39;)</span><br><span class="line">            &#123;</span><br><span class="line">                if (!q.empty())</span><br><span class="line">                &#123;</span><br><span class="line">                    t[q.top().second] &#x3D; t[i] &#x3D; 0;</span><br><span class="line">                    q.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while (!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        bool flag &#x3D; 1;</span><br><span class="line">        int l &#x3D; n + 1, ls &#x3D; 0, rs &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (t[i] &#x3D;&#x3D; &#39;*&#39;)</span><br><span class="line">                ls++;</span><br><span class="line">            if (t[i] &#x3D;&#x3D; &#39;)&#39;)</span><br><span class="line">            &#123;</span><br><span class="line">                if (!ls)</span><br><span class="line">                &#123;</span><br><span class="line">                    flag &#x3D; 0;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                ls--;</span><br><span class="line">                rs++;</span><br><span class="line">            &#125;</span><br><span class="line">            if (t[i] &#x3D;&#x3D; &#39;(&#39;)</span><br><span class="line">            &#123;</span><br><span class="line">                l &#x3D; i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (t[i] &#x3D;&#x3D; &#39;*&#39; &amp;&amp; rs)</span><br><span class="line">            &#123;</span><br><span class="line">                rs--;</span><br><span class="line">                s[i] &#x3D; &#39;(&#39;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ls &#x3D; 0;</span><br><span class="line">        rs &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; n; i &gt;&#x3D; l; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            if (t[i] &#x3D;&#x3D; &#39;*&#39;)</span><br><span class="line">                rs++;</span><br><span class="line">            if (t[i] &#x3D;&#x3D; &#39;(&#39;)</span><br><span class="line">            &#123;</span><br><span class="line">                if (!rs)</span><br><span class="line">                &#123;</span><br><span class="line">                    flag &#x3D; 0;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                rs--;</span><br><span class="line">                ls++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; n; i &gt;&#x3D; l; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            if (t[i] &#x3D;&#x3D; &#39;*&#39; &amp;&amp; ls)</span><br><span class="line">            &#123;</span><br><span class="line">                ls--;</span><br><span class="line">                s[i] &#x3D; &#39;)&#39;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!flag)</span><br><span class="line">            cout &lt;&lt; &quot;No solution!&quot; &lt;&lt; endl;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                if (s[i] &#x3D;&#x3D; &#39;(&#39; || s[i] &#x3D;&#x3D; &#39;)&#39;)</span><br><span class="line">                &#123;</span><br><span class="line">                    cout &lt;&lt; s[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Tokitsukaze-and-Multiple-（HDU-6794）-1004&quot;&gt;&lt;a href=&quot;#Tokitsukaze-and-Multiple-（HDU-6794）-1004&quot; class=&quot;headerlink&quot; title=&quot;Tokitsukaze and Multiple （HDU-6794）  (1004)&quot;&gt;&lt;/a&gt;Tokitsukaze and Multiple （HDU-6794）  (1004)&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;题意：有一个长度为n的序列，你现在将序列中连续两个元素合并多次，然后问你在经过一些操作之后，能得到的p的倍数元素的最大可能数量。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="多校" scheme="https://stephencurry6666.github.io/categories/%E5%A4%9A%E6%A0%A1/"/>
    
    
      <category term="HDU" scheme="https://stephencurry6666.github.io/tags/HDU/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 633(Div.2)</title>
    <link href="https://stephencurry6666.github.io/2020/07/28/Codeforces%20633(Div.2)/"/>
    <id>https://stephencurry6666.github.io/2020/07/28/Codeforces%20633(Div.2)/</id>
    <published>2020-07-28T01:44:50.733Z</published>
    <updated>2020-07-28T01:49:34.884Z</updated>
    
    <content type="html"><![CDATA[<h3 id="A题"><a href="#A题" class="headerlink" title="A题"></a>A题</h3><p><strong>题意：给你n个菱形方块拼成的多边形，然后问你有多少种方法可以由一个菱形通过旋转，翻转，移动得到。</strong></p><a id="more"></a><p><strong>思路：这道题的话，通过读题不难发现，n个菱形就有n种方法。</strong></p><p><strong>AC代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxx &#x3D; 100010;</span><br><span class="line">const int inf &#x3D; 0x3f3f3f3f;</span><br><span class="line">const int mod &#x3D; 1000000009;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    cout.tie(0);</span><br><span class="line">    int t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        int n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="B题"><a href="#B题" class="headerlink" title="B题"></a>B题</h3><p><strong>题意：给你一个数组，要求重新排列后，相邻元素的绝对值递增。</strong></p><p><strong>思路：这道题的话，我们重新排列之后，将数组倒着一小一大存入即可。</strong></p><p><strong>AC代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxx &#x3D; 100010;</span><br><span class="line">const int inf &#x3D; 0x3f3f3f3f;</span><br><span class="line">const int mod &#x3D; 1000000009;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[maxx], b[maxx];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    cout.tie(0);</span><br><span class="line">    int t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        int n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">        sort(a + 1, a + n + 1);</span><br><span class="line">        int ans &#x3D; 1;</span><br><span class="line">        int cnt &#x3D; n;</span><br><span class="line">        for (int i &#x3D; n; i &gt;&#x3D; 1; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            if ((n - i) % 2 &#x3D;&#x3D; 0)</span><br><span class="line">                b[i] &#x3D; a[ans++];</span><br><span class="line">            if ((n - i) % 2 &#x3D;&#x3D; 1)</span><br><span class="line">                b[i] &#x3D; a[cnt--];</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; b[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C题"><a href="#C题" class="headerlink" title="C题"></a>C题</h3><p><strong>题意：给一个数组，你可以在第x秒给一些元素加上2的x−1次方 ,问多少秒后数组可以变成一个不递减序列。</strong></p><p><strong>思路：这道题的话，我们找到数组中一组前后差最大的元素，然后判断需要加几秒即可。</strong></p><p><strong>AC代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxx &#x3D; 100010;</span><br><span class="line">const int inf &#x3D; 0x3f3f3f3f;</span><br><span class="line">const int mod &#x3D; 1000000009;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[maxx];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    cout.tie(0);</span><br><span class="line">    int t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        int n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">        int minn &#x3D; a[n];</span><br><span class="line">        int flag &#x3D; 0, ret &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; n - 1; i &gt;&#x3D; 1; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            if (a[i] &gt; minn)</span><br><span class="line">                flag &#x3D; 1, ret &#x3D; max(ret, a[i] - minn);</span><br><span class="line">            else</span><br><span class="line">                minn &#x3D; min(a[i], minn);</span><br><span class="line">        &#125;</span><br><span class="line">        if (!flag)</span><br><span class="line">            cout &lt;&lt; 0 &lt;&lt; endl;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            int x &#x3D; 1, cnt &#x3D; 0;</span><br><span class="line">            while (ret &gt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                ret -&#x3D; x;</span><br><span class="line">                x *&#x3D; 2;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="D题"><a href="#D题" class="headerlink" title="D题"></a>D题</h3><p><strong>题意：现在给你一颗无根树，然后给无根树每一条边赋值，要求任意两个叶子节点的路径上的边的权值异或和为0，求填写方案中权值种类的最大值和最小值。</strong></p><p><strong>这道题的话，我们先考虑最小值，最好的情况就是全部都是1，那么最小值就为1，但是如果有两个叶子结点之间的距离为奇数的话，异或的结果就不为1，参考样例2，这时候的最小值就为3。判断叶子节点之间的距离奇偶性一个比较好的方法就可以统计所有的深度，如果又有奇数又有偶数的话，就肯定有两个叶子结点之间距离为偶数再来考虑最大值，我们可以试着将所有边权构造为不能的数，但是这样会出现一种情况就是一个父亲节点连接多个叶子，这样是不可能的，这时候答案就为n−1−x，x为符合要求的父亲节点所连接的叶子节点数。</strong></p><p><strong>AC代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxx &#x3D; 100010;</span><br><span class="line">const int inf &#x3D; 0x3f3f3f3f;</span><br><span class="line">const int mod &#x3D; 1000000009;</span><br><span class="line">using namespace std;</span><br><span class="line">vector&lt;ll&gt; G[maxx];</span><br><span class="line">vector&lt;ll&gt; ans;</span><br><span class="line">ll deep[maxx], vis[maxx];</span><br><span class="line">int dfs(ll u, ll pre)</span><br><span class="line">&#123;</span><br><span class="line">    deep[u] &#x3D; deep[pre] + 1;</span><br><span class="line">    vis[u] &#x3D; pre;</span><br><span class="line">    for (auto v : G[u])</span><br><span class="line">    &#123;</span><br><span class="line">        if (G[v].size() &#x3D;&#x3D; 1)</span><br><span class="line">            ans.push_back(u);</span><br><span class="line">        if (v &#x3D;&#x3D; pre)</span><br><span class="line">            continue;</span><br><span class="line">        dfs(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    cout.tie(0);</span><br><span class="line">    int n, u, v;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    for (int i &#x3D; 1; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        G[u].push_back(v);</span><br><span class="line">        G[v].push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    deep[0] &#x3D; -1;</span><br><span class="line">    dfs(1, 0);</span><br><span class="line">    ll f &#x3D; 0, cnt &#x3D; 0, tot &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (G[i].size() &#x3D;&#x3D; 1 &amp;&amp; deep[i] % 2 &#x3D;&#x3D; 0)</span><br><span class="line">            cnt++;</span><br><span class="line">        if (G[i].size() &#x3D;&#x3D; 1 &amp;&amp; deep[i] % 2)</span><br><span class="line">            tot++;</span><br><span class="line">    &#125;</span><br><span class="line">    if (cnt &gt;&#x3D; 1 &amp;&amp; tot &gt;&#x3D; 1)</span><br><span class="line">        f &#x3D; 1;</span><br><span class="line">    if (f !&#x3D; 0)</span><br><span class="line">        cout &lt;&lt; &quot;3 &quot;;</span><br><span class="line">    else</span><br><span class="line">        cout &lt;&lt; &quot;1 &quot;;</span><br><span class="line">    sort(ans.begin(), ans.end());</span><br><span class="line">    ll ma &#x3D; n - 1;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; ans.size(); i++)</span><br><span class="line">        if (i)</span><br><span class="line">        &#123;</span><br><span class="line">            if (ans[i] &#x3D;&#x3D; ans[i - 1])</span><br><span class="line">                --ma;</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; ma;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;A题&quot;&gt;&lt;a href=&quot;#A题&quot; class=&quot;headerlink&quot; title=&quot;A题&quot;&gt;&lt;/a&gt;A题&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;题意：给你n个菱形方块拼成的多边形，然后问你有多少种方法可以由一个菱形通过旋转，翻转，移动得到。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="CF" scheme="https://stephencurry6666.github.io/categories/CF/"/>
    
    
      <category term="CF" scheme="https://stephencurry6666.github.io/tags/CF/"/>
    
  </entry>
  
  <entry>
    <title>2020HDU多校第二场</title>
    <link href="https://stephencurry6666.github.io/2020/07/27/2020HDU%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%BA%8C%E5%9C%BA/"/>
    <id>https://stephencurry6666.github.io/2020/07/27/2020HDU%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%BA%8C%E5%9C%BA/</id>
    <published>2020-07-27T09:12:04.956Z</published>
    <updated>2020-07-27T09:19:16.233Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Total-Eclipse（HDU-6763）（1001）"><a href="#Total-Eclipse（HDU-6763）（1001）" class="headerlink" title="Total Eclipse（HDU-6763）（1001）"></a>Total Eclipse（HDU-6763）（1001）</h3><p><strong>题意：现在有n个城市和m条双向通道用于连接城市，然后每个城市都有一个亮度b。然后现在有人想把所以城市的亮度全部降为0。他可以有k次操作，每次可以选择1~n之间任意数量的城市进行降1的亮度，问你最少需要多少次操作才可以将所以城市亮度都降为0。</strong></p><a id="more"></a><p><strong>思路：这道题的话，在昨天比赛的时候我和我的队友也想到了用并查集来做，但是却没能实现。然后我看了看大佬们实现的代码，有了一些想法。我们可以先将我们的亮度从大到小排序，然后我们依次加入x点，并且加入和这个点相连的所有点，如果新加入的y点的亮度大于x点，那么我们就把他们合并。在之后我们计算答案的时候，对于x节点，当需要删除他的时候他已经减去了他的父亲节点的亮度了，所以只需要再减去剩下的$d−dfather$的答案。所以最后求一下和就可以了。</strong></p><p><strong>AC代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxx &#x3D; 200010;</span><br><span class="line">const int inf &#x3D; 0x3f3f3f3f;</span><br><span class="line">using namespace std;</span><br><span class="line">int d[maxx], pre[maxx], fa[maxx], vis[maxx], num[maxx];</span><br><span class="line">vector&lt;int&gt; g[maxx];</span><br><span class="line">bool cmp(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    return d[a] &gt; d[b];</span><br><span class="line">&#125;</span><br><span class="line">int getf(int a)</span><br><span class="line">&#123;</span><br><span class="line">    if (pre[a] &#x3D;&#x3D; a)</span><br><span class="line">        return pre[a];</span><br><span class="line">    return pre[a] &#x3D; getf(pre[a]);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    cout.tie(0);</span><br><span class="line">    int t, n, m;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">            g[i].clear();</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; d[i];</span><br><span class="line">            pre[i] &#x3D; i;</span><br><span class="line">            vis[i] &#x3D; fa[i] &#x3D; 0;</span><br><span class="line">            num[i] &#x3D; i;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(num + 1, num + 1 + n, cmp);</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int a, b;</span><br><span class="line">            cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">            g[a].push_back(b);</span><br><span class="line">            g[b].push_back(a);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int x &#x3D; num[i];</span><br><span class="line">            vis[x] &#x3D; 1;</span><br><span class="line">            for (auto it : g[x])</span><br><span class="line">            &#123;</span><br><span class="line">                if (!vis[it])</span><br><span class="line">                    continue;</span><br><span class="line">                int fy &#x3D; getf(it);</span><br><span class="line">                if (fy &#x3D;&#x3D; x)</span><br><span class="line">                    continue;</span><br><span class="line">                fa[fy] &#x3D; pre[fy] &#x3D; x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ll res &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">            res +&#x3D; d[i] - d[fa[i]];</span><br><span class="line">        cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Lead-of-Wisdom-HDU-6772-1010"><a href="#Lead-of-Wisdom-HDU-6772-1010" class="headerlink" title="Lead of Wisdom(HDU-6772) (1010)"></a>Lead of Wisdom(HDU-6772) (1010)</h3><p><strong>题意：给你k种类型的物品若干种，一个种类只能选一种物品，求题中DMG的最大值。</strong></p><p><strong>思路：这道题的话，直接暴搜竟然可以，参考了些大佬的思路，感觉自己也明白了。暴搜的话正着dfs会wa，反着dfs即可。</strong></p><p><strong>AC代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxx &#x3D; 1010;</span><br><span class="line">const int inf &#x3D; 0x3f3f3f3f;</span><br><span class="line">using namespace std;</span><br><span class="line">int f[maxx][maxx][5], ans[maxx];</span><br><span class="line">ll res;</span><br><span class="line">int n, m;</span><br><span class="line">void dfs(int x, int a, int b, int c, int d)</span><br><span class="line">&#123;</span><br><span class="line">    if (x &lt; 1)</span><br><span class="line">    &#123;</span><br><span class="line">        ll tmp &#x3D; 1ll * a * b * c * d;</span><br><span class="line">        res &#x3D; max(res, tmp);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!ans[x])</span><br><span class="line">    &#123;</span><br><span class="line">        dfs(x - 1, a, b, c, d);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; ans[x]; i++)</span><br><span class="line">        dfs(x - 1, f[x][i][1] + a, f[x][i][2] + b, f[x][i][3] + c, f[x][i][4] + d);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    cout.tie(0);</span><br><span class="line">    int t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        res &#x3D; 0;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; m; i++)</span><br><span class="line">            ans[i] &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int cnt;</span><br><span class="line">            cin &gt;&gt; cnt;</span><br><span class="line">            ans[cnt]++;</span><br><span class="line">            for (int j &#x3D; 1; j &lt;&#x3D; 4; j++)</span><br><span class="line">                cin &gt;&gt; f[cnt][ans[cnt]][j];</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(1, 100, 100, 100, 100);</span><br><span class="line">        cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="The-Oculus-HDU-6768-1006"><a href="#The-Oculus-HDU-6768-1006" class="headerlink" title="The Oculus(HDU-6768) (1006)"></a>The Oculus(HDU-6768) (1006)</h3><p><strong>题意：给你两个数，每个都是用斐波那契数列（01表示）来表示的，规定$F1=1,F2=2$，再给你他们相乘后的结果C用斐波那契数列来表示，现在我将C中的斐波那契数列的某一位1删掉，问你删掉的是哪一位。</strong></p><p><strong>思路：这道题的话，双哈希过去。因为我们只是把一个1翻成了0，所以枚举C数组遇见0就把他翻转过来看是不是hash值相等，如果相等则答案就是这一位。</strong></p><p><strong>AC代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxn &#x3D; 2000010;</span><br><span class="line">const int inf &#x3D; 0x3f3f3f3f;</span><br><span class="line">const int mod &#x3D; 1e9 + 9;</span><br><span class="line">const int mod1 &#x3D; 1e9 + 7;</span><br><span class="line">using namespace std;</span><br><span class="line">ll f[maxn], f1[maxn];</span><br><span class="line">ll na, nb, nc, sa, sb, sc, sa1, sb1, sc1;</span><br><span class="line">ll a[maxn], b[maxn], c[maxn];</span><br><span class="line">void solve()</span><br><span class="line">&#123;</span><br><span class="line">    scanf(&quot;%lld&quot;, &amp;na);</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; na; i++)</span><br><span class="line">        scanf(&quot;%lld&quot;, &amp;a[i]);</span><br><span class="line">    scanf(&quot;%lld&quot;, &amp;nb);</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; nb; i++)</span><br><span class="line">        scanf(&quot;%lld&quot;, &amp;b[i]);</span><br><span class="line">    scanf(&quot;%lld&quot;, &amp;nc);</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; nc; i++)</span><br><span class="line">        scanf(&quot;%lld&quot;, &amp;c[i]);</span><br><span class="line">    sa &#x3D; sb &#x3D; sc &#x3D; 0;</span><br><span class="line">    sa1 &#x3D; sb1 &#x3D; sc1 &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; na; i++)</span><br><span class="line">        sa &#x3D; (sa + f[i] * a[i]) % mod;</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; nb; i++)</span><br><span class="line">        sb &#x3D; (sb + f[i] * b[i]) % mod;</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; nc; i++)</span><br><span class="line">        sc &#x3D; (sc + f[i] * c[i]) % mod;</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; na; i++)</span><br><span class="line">        sa1 &#x3D; (sa1 + f1[i] * a[i]) % mod1;</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; nb; i++)</span><br><span class="line">        sb1 &#x3D; (sb1 + f1[i] * b[i]) % mod1;</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; nc; i++)</span><br><span class="line">        sc1 &#x3D; (sc1 + f1[i] * c[i]) % mod1;</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; nc; i++)</span><br><span class="line">        if (c[i] &#x3D;&#x3D; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            int tmp &#x3D; (sc + f[i]) % mod, tmp1 &#x3D; (sc1 + f1[i]) % mod1;</span><br><span class="line">            if (tmp &#x3D;&#x3D; (sa * sb) % mod &amp;&amp; tmp1 &#x3D;&#x3D; (sa1 * sb1) % mod1)</span><br><span class="line">            &#123;</span><br><span class="line">                printf(&quot;%lld\n&quot;, i);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    f[1] &#x3D; 1, f[2] &#x3D; 2;</span><br><span class="line">    for (int i &#x3D; 3; i &lt; maxn; i++)</span><br><span class="line">        f[i] &#x3D; (f[i - 1] + f[i - 2]) % mod;</span><br><span class="line">    f1[1] &#x3D; 1, f1[2] &#x3D; 2;</span><br><span class="line">    for (int i &#x3D; 3; i &lt; maxn; i++)</span><br><span class="line">        f1[i] &#x3D; (f1[i - 1] + f1[i - 2]) % mod1;</span><br><span class="line">    int t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while (t--)</span><br><span class="line">        solve();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Total-Eclipse（HDU-6763）（1001）&quot;&gt;&lt;a href=&quot;#Total-Eclipse（HDU-6763）（1001）&quot; class=&quot;headerlink&quot; title=&quot;Total Eclipse（HDU-6763）（1001）&quot;&gt;&lt;/a&gt;Total Eclipse（HDU-6763）（1001）&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;题意：现在有n个城市和m条双向通道用于连接城市，然后每个城市都有一个亮度b。然后现在有人想把所以城市的亮度全部降为0。他可以有k次操作，每次可以选择1~n之间任意数量的城市进行降1的亮度，问你最少需要多少次操作才可以将所以城市亮度都降为0。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="多校" scheme="https://stephencurry6666.github.io/categories/%E5%A4%9A%E6%A0%A1/"/>
    
    
      <category term="HDU" scheme="https://stephencurry6666.github.io/tags/HDU/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 635(Div.2)</title>
    <link href="https://stephencurry6666.github.io/2020/07/27/Codeforces%20635(Div.2)/"/>
    <id>https://stephencurry6666.github.io/2020/07/27/Codeforces%20635(Div.2)/</id>
    <published>2020-07-27T07:44:35.931Z</published>
    <updated>2020-07-27T07:50:36.781Z</updated>
    
    <content type="html"><![CDATA[<h3 id="A题"><a href="#A题" class="headerlink" title="A题"></a>A题</h3><p><strong>题意：给你$a,b,c,d$四个数，然后规定$a&lt;=b&lt;=c&lt;=d$。然后给你$x,y,z$，规定，$a&lt;=x&lt;=b$,$b&lt;=y&lt;=c$,$c&lt;=z&lt;=d$,$x,y,z$可以构成面积为正的三角形，问你$x,y,z$。</strong></p><a id="more"></a><p><strong>思路：这道题的话，根据题意，我们直接输出$b,c,c$即可。</strong></p><p><strong>AC代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxn &#x3D; 100010;</span><br><span class="line">const int inf &#x3D; 0x3f3f3f3f;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    cout.tie(0);</span><br><span class="line">    ll t,a,b,c,d;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    while(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;</span><br><span class="line">        cout&lt;&lt;b&lt;&lt;&quot; &quot;&lt;&lt;c&lt;&lt;&quot; &quot;&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="B题"><a href="#B题" class="headerlink" title="B题"></a>B题</h3><p><strong>题意：kana现在在玩一个游戏，她想猎杀一条龙，龙的初始生命值是x，当$x&lt;=0$的时候，说明猎杀成功。kana有两个技能，第一个技能可以使$x=x/2+10$，第二个技能可以使$x=x-10$。然后第一个技能可以使用n次，第二个技能可以使用m次，问你能不能成功猎杀龙。</strong></p><p><strong>思路：这道题的话，通过读题我们可以发现当$x&lt;20$之后，用第一次技能会使x变大，所以我们就先将x通过第一个技能尽可能的降至大于20且最小的血量，再用第二个技能判断其是否会小于等于0。</strong></p><p><strong>AC代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxn &#x3D; 100010;</span><br><span class="line">const int inf &#x3D; 0x3f3f3f3f;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    cout.tie(0);</span><br><span class="line">    int t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        int x, n, m;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        while (n &amp;&amp; x&gt;20)</span><br><span class="line">        &#123;</span><br><span class="line">            n--;</span><br><span class="line">            x &#x3D; x &#x2F; 2 + 10;</span><br><span class="line">        &#125;</span><br><span class="line">        if (x &lt;&#x3D; m * 10)</span><br><span class="line">            cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;</span><br><span class="line">        else</span><br><span class="line">            cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C题"><a href="#C题" class="headerlink" title="C题"></a>C题</h3><p><strong>题意：给你一颗树，这棵树有两种顶点，一个是旅游节点，一个是工业节点，你如何设置工业节点让每一个工业节点到根节点路上得旅游节点的总和最大。</strong></p><p><strong>思路：这道题的话，我们可以求出每一个节点的深度，这个就是每一个节点能够得到的最大的权值，然后就是计算每一个节点下面有多少个工业节点，因为如果这个作为工业节点的话，那么后面的工业得节点的权值都会减1，所以我们就可以得到每一个节点的计算公式$val=deep−ans$，然后进行排序取k个最大的相加，得到的和就是答案了。</strong></p><p><strong>AC代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxn &#x3D; 200010;</span><br><span class="line">const int inf &#x3D; 0x3f3f3f3f;</span><br><span class="line">using namespace std;</span><br><span class="line">vector&lt;ll&gt; G[maxn];</span><br><span class="line">vector&lt;ll&gt; sum;</span><br><span class="line">int n, k;</span><br><span class="line">bool cmp(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">    return a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line">int dfs(int u, int pre, int deep)</span><br><span class="line">&#123;</span><br><span class="line">    int ans &#x3D; 1;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; G[u].size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int v &#x3D; G[u][i];</span><br><span class="line">        if (v &#x3D;&#x3D; pre)</span><br><span class="line">            continue;</span><br><span class="line">        ans +&#x3D; dfs(v, u, deep + 1);</span><br><span class="line">    &#125;</span><br><span class="line">    sum.push_back(deep - ans);</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    cout.tie(0);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; n - 1; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int u, v;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        G[u].push_back(v);</span><br><span class="line">        G[v].push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(1, 0, 1);</span><br><span class="line">    sort(sum.begin(), sum.end(), cmp);</span><br><span class="line">    ll cnt &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; k; i++)</span><br><span class="line">        cnt +&#x3D; 1ll * sum[i];</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;A题&quot;&gt;&lt;a href=&quot;#A题&quot; class=&quot;headerlink&quot; title=&quot;A题&quot;&gt;&lt;/a&gt;A题&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;题意：给你$a,b,c,d$四个数，然后规定$a&amp;lt;=b&amp;lt;=c&amp;lt;=d$。然后给你$x,y,z$，规定，$a&amp;lt;=x&amp;lt;=b$,$b&amp;lt;=y&amp;lt;=c$,$c&amp;lt;=z&amp;lt;=d$,$x,y,z$可以构成面积为正的三角形，问你$x,y,z$。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="CF" scheme="https://stephencurry6666.github.io/categories/CF/"/>
    
    
      <category term="CF" scheme="https://stephencurry6666.github.io/tags/CF/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 634(Div.3)</title>
    <link href="https://stephencurry6666.github.io/2020/07/25/Codeforces%20634(Div.3)/"/>
    <id>https://stephencurry6666.github.io/2020/07/25/Codeforces%20634(Div.3)/</id>
    <published>2020-07-25T09:19:41.803Z</published>
    <updated>2020-07-25T09:27:05.037Z</updated>
    
    <content type="html"><![CDATA[<h3 id="A题"><a href="#A题" class="headerlink" title="A题"></a>A题</h3><p><strong>题意：你现在有n块糖果，然后你要把n块糖果分给Alice和Betty。Alice分得a块糖果，Betty分得b块糖果。然后约束条件是$a&gt;b$且$a+b=n$，问你有多少种可以表示$n=a+b$的分解方法。</strong></p><a id="more"></a><p><strong>思路：这道题的话，通过看题不难看出当$n&lt;=2$的时候是不能分解的；当$n&gt;2$的时候就是共有$(n-1)/2$种分解方法。</strong></p><p><strong>AC代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxx &#x3D; 100010;</span><br><span class="line">const int inf &#x3D; 0x3f3f3f3f;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    cout.tie(0);</span><br><span class="line">    int t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        int n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        if (n &lt;&#x3D; 2)</span><br><span class="line">            cout &lt;&lt; &quot;0&quot; &lt;&lt; endl;</span><br><span class="line">        else</span><br><span class="line">            cout &lt;&lt; (n - 1) &#x2F; 2 &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="B题"><a href="#B题" class="headerlink" title="B题"></a>B题</h3><p><strong>题意：给你三个整数n,a,b表示在n长度的字符串中，每a个连续的字串中，含有b个不同的字母。然后问你满足要求的字符串。</strong></p><p><strong>思路：这道题的话，我们构造一下即可。首选我们在a-b的位置构造不同的字母，然后b~a的位置再构造相同的字母，最后我们再重复前面的即可。</strong></p><p><strong>AC代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxx &#x3D; 100010;</span><br><span class="line">const int inf &#x3D; 0x3f3f3f3f;</span><br><span class="line">using namespace std;</span><br><span class="line">char s[maxx];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    cout.tie(0);</span><br><span class="line">    int t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        int n, a, b;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        char c &#x3D; &#39;a&#39;;</span><br><span class="line">        memset(s, 0, sizeof(s));</span><br><span class="line">        for (int i &#x3D; 0; i &lt; a; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (i &lt; b)</span><br><span class="line">                s[i] &#x3D; c + i;</span><br><span class="line">            else</span><br><span class="line">                s[i] &#x3D; &#39;a&#39;;</span><br><span class="line">            cout &lt;&lt; s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; a; i &lt; n; i++)</span><br><span class="line">            cout &lt;&lt; s[i % a];</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C题"><a href="#C题" class="headerlink" title="C题"></a>C题</h3><p><strong>题意：给你一个序列a，然后你可以将里面的元素进行分组，第一组的元素全部都要不同的，第二组全部都要相同的最后两组的数量要一样，问最大的数量是多少。</strong></p><p><strong>思路：这道题的话，先用ans记录不同的技能一共有多少人，然后用map记录每个技能的人数有多少人。之后从1~n遍历，如果不同的人数大于相同的，则计算不同的人数；如果不同的人数小于相同的，则计算相同的人数；如果二者相等，求不同的人数减一，因为不同的人数当中包含了相同的，求每一个循环的最大值。</strong></p><p><strong>AC代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxx &#x3D; 200010;</span><br><span class="line">const int inf &#x3D; 0x3f3f3f3f;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[maxx];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    cout.tie(0);</span><br><span class="line">    int t, n;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        map&lt;int, int&gt; h;</span><br><span class="line">        set&lt;int&gt; s;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">            h[a[i]]++;</span><br><span class="line">            s.insert(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        int cnt &#x3D; s.size();</span><br><span class="line">        int m &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (cnt &gt; h[a[i]])</span><br><span class="line">                m &#x3D; max(m, h[a[i]]);</span><br><span class="line">            else if (cnt &#x3D;&#x3D; h[a[i]])</span><br><span class="line">                m &#x3D; max(m, h[a[i]] - 1);</span><br><span class="line">            else</span><br><span class="line">                m &#x3D; max(m, cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; m &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="D题"><a href="#D题" class="headerlink" title="D题"></a>D题</h3><p><strong>题意：给你一个9x9的数独，现在要你改数独，要求每一个3x3的块都包含至少两个相同的数字。</strong></p><p><strong>思路：这道题的话，我们只需要随便找一个数字改成另一个数字即可。</strong></p><p><strong>AC代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxx &#x3D; 10;</span><br><span class="line">const int inf &#x3D; 0x3f3f3f3f;</span><br><span class="line">using namespace std;</span><br><span class="line">char a[maxx][maxx];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    cout.tie(0);</span><br><span class="line">    int t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; 9; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int j &#x3D; 1; j &lt;&#x3D; 9; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                cin &gt;&gt; a[i][j];</span><br><span class="line">                if (a[i][j] &#x3D;&#x3D; &#39;2&#39;)</span><br><span class="line">                    a[i][j] &#x3D; &#39;1&#39;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; 9; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int j &#x3D; 1; j &lt;&#x3D; 9; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; a[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;A题&quot;&gt;&lt;a href=&quot;#A题&quot; class=&quot;headerlink&quot; title=&quot;A题&quot;&gt;&lt;/a&gt;A题&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;题意：你现在有n块糖果，然后你要把n块糖果分给Alice和Betty。Alice分得a块糖果，Betty分得b块糖果。然后约束条件是$a&amp;gt;b$且$a+b=n$，问你有多少种可以表示$n=a+b$的分解方法。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="CF" scheme="https://stephencurry6666.github.io/categories/CF/"/>
    
    
      <category term="CF" scheme="https://stephencurry6666.github.io/tags/CF/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 632(Div.2)</title>
    <link href="https://stephencurry6666.github.io/2020/07/25/Codeforces%20632(Div.2)/"/>
    <id>https://stephencurry6666.github.io/2020/07/25/Codeforces%20632(Div.2)/</id>
    <published>2020-07-25T03:31:20.052Z</published>
    <updated>2020-07-25T03:42:20.887Z</updated>
    
    <content type="html"><![CDATA[<h3 id="A题"><a href="#A题" class="headerlink" title="A题"></a>A题</h3><p><strong>题意：B是有白格子相邻的黑格子数，W是有黑格子相邻的白格子数，合法涂色方案为B=W+1。</strong></p><a id="more"></a><p><strong>思路：这道题的话，给定了矩阵，那么只需要一个角落的格子为白色，其余都为黑色即可。</strong></p><p><strong>AC代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxx &#x3D; 100010;</span><br><span class="line">const int inf &#x3D; 0x3f3f3f3f;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    cout.tie(0);</span><br><span class="line">    int t, n, m;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; m; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if (i &#x3D;&#x3D; 0 &amp;&amp; j &#x3D;&#x3D; 0)</span><br><span class="line">                    cout &lt;&lt; &quot;W&quot;;</span><br><span class="line">                else</span><br><span class="line">                    cout &lt;&lt; &quot;B&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="B题"><a href="#B题" class="headerlink" title="B题"></a>B题</h3><p><strong>题意：给定$a、b$序列，如果$i&gt;j$，若则可以进行操作$a_{j}=a_{i}+a_{j}$，问能不能使a序列变成b序列。</strong></p><p><strong>这道题的话，因为我们是通过操作使得a序列变成b序列，所以我们从后面开始看，如果$b[i]&gt;a[i]$的话，要让$a[i]$变大的话，前面一定要有1；如果$b[i]&lt;a[i]$的话，要让$a[i]$变小的话，前面一定要有-1，否则不合法。然后我们记住最左面的1和-1的位置判断即可。</strong></p><p><strong>AC代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxx &#x3D; 100010;</span><br><span class="line">const int inf &#x3D; 0x3f3f3f3f;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[maxx], b[maxx];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    cout.tie(0);</span><br><span class="line">    int t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        int n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        int ans &#x3D; inf, cnt &#x3D; inf;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">            if (a[i] &#x3D;&#x3D; 1 &amp;&amp; ans &#x3D;&#x3D; inf)</span><br><span class="line">                ans &#x3D; i;</span><br><span class="line">            if (a[i] &#x3D;&#x3D; -1 &amp;&amp; cnt &#x3D;&#x3D; inf)</span><br><span class="line">                cnt &#x3D; i;</span><br><span class="line">        &#125;</span><br><span class="line">        int flag &#x3D; 1;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; b[i];</span><br><span class="line">            if (b[i] &gt; a[i] &amp;&amp; ans &gt;&#x3D; i)</span><br><span class="line">                flag &#x3D; 0;</span><br><span class="line">            if (b[i] &lt; a[i] &amp;&amp; cnt &gt;&#x3D; i)</span><br><span class="line">                flag &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if (flag)</span><br><span class="line">            cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;</span><br><span class="line">        else</span><br><span class="line">            cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C题"><a href="#C题" class="headerlink" title="C题"></a>C题</h3><p><strong>题意：如果一个序列的所有非空子序列的和都不为零，则称该序列是一个好序列。现给定一个序列，求有多少个非空子序列是好序列。</strong></p><p><strong>思路：这道题的话，首先区间$[i,j]$和为$0$,可以得到:$sum[i]=sum[j]$，然后如果一个区间$[i,j]$和为$0$那么从$j+1$开始才存在好区间，最后用$cnt$记录上一个可以包含的左端,那么每次加上$i-cnt$,遍历完就是答案。</strong></p><p><strong>AC代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxx &#x3D; 100010;</span><br><span class="line">const int inf &#x3D; 0x3f3f3f3f;</span><br><span class="line">using namespace std;</span><br><span class="line">map&lt;ll, ll&gt; mapp;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    cout.tie(0);</span><br><span class="line">    ll n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    mapp[0] &#x3D; 1;</span><br><span class="line">    ll m, ans &#x3D; 0, sum &#x3D; 0, cnt &#x3D; 0;</span><br><span class="line">    for (ll i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; m;</span><br><span class="line">        sum +&#x3D; m;</span><br><span class="line">        cnt &#x3D; max(cnt, mapp[sum]);</span><br><span class="line">        ans +&#x3D; (i - cnt);</span><br><span class="line">        mapp[sum] &#x3D; i + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;A题&quot;&gt;&lt;a href=&quot;#A题&quot; class=&quot;headerlink&quot; title=&quot;A题&quot;&gt;&lt;/a&gt;A题&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;题意：B是有白格子相邻的黑格子数，W是有黑格子相邻的白格子数，合法涂色方案为B=W+1。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="CF" scheme="https://stephencurry6666.github.io/categories/CF/"/>
    
    
      <category term="CF" scheme="https://stephencurry6666.github.io/tags/CF/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 631(Div.2)</title>
    <link href="https://stephencurry6666.github.io/2020/07/24/Codeforces%20631(Div.2)/"/>
    <id>https://stephencurry6666.github.io/2020/07/24/Codeforces%20631(Div.2)/</id>
    <published>2020-07-24T06:37:00.526Z</published>
    <updated>2020-07-25T03:32:33.319Z</updated>
    
    <content type="html"><![CDATA[<h3 id="A题"><a href="#A题" class="headerlink" title="A题"></a>A题</h3><p><strong>题意：给你一个a序列代表每次的排名，在n个比赛之后还有x场比赛，然后你去寻找一个最大的v代表这n+x比赛后比赛的连续的最大的排名是多少。</strong></p><a id="more"></a><p><strong>思路：这道题的话，我们可以用cnt去记录此时的最高排名有没有出现过，如果没有的话，那就将x−−，最后当x=0并且cnt此时最后排名没有出现过的话，那么前一个就是答案了。</strong></p><p><strong>AC代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxx &#x3D; 100010;</span><br><span class="line">const int inf &#x3D; 0x3f3f3f3f;</span><br><span class="line">const int mod &#x3D; 1000000009;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[110];</span><br><span class="line">int cnt[1010];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    cout.tie(0);</span><br><span class="line">    int t, n, x;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; x;</span><br><span class="line">        memset(cnt, 0, sizeof(cnt));</span><br><span class="line">        for (int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">            cnt[a[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        int k &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 1; x; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (cnt[i] &#x3D;&#x3D; 0)</span><br><span class="line">                x--, k &#x3D; i, cnt[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; k;; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (cnt[i] &#x3D;&#x3D; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                k &#x3D; i - 1;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;, k);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="B题"><a href="#B题" class="headerlink" title="B题"></a>B题</h3><p><strong>题意：给出一组数，要求分成两部分，一部分假设有m个数，保证这部分的数字从1-m均出现而且仅出现一次。输出所有可能。</strong></p><p><strong>思路：这道题的话，显然分出的两段是合法的，当且仅当段的最大值等于段的长度时段内没有重复元素，于是先扫一遍得到正序倒序第一个重复元素的位置，再正反各扫一遍得到前缀后缀最大值即可。</strong></p><p><strong>AC代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxx &#x3D; 200010;</span><br><span class="line">const int inf &#x3D; 0x3f3f3f3f;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[maxx], p[maxx], q[maxx];</span><br><span class="line">int t, n, l, r;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    cout.tie(0);</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">        set&lt;int&gt; s;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (s.find(a[i]) &#x3D;&#x3D; s.end())</span><br><span class="line">            &#123;</span><br><span class="line">                s.insert(a[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                l &#x3D; i - 1;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s.clear();</span><br><span class="line">        for (int i &#x3D; n; i &gt;&#x3D; 1; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            if (s.find(a[i]) &#x3D;&#x3D; s.end())</span><br><span class="line">            &#123;</span><br><span class="line">                s.insert(a[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                r &#x3D; i + 1;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">            p[i] &#x3D; max(p[i - 1], a[i]);</span><br><span class="line">        for (int i &#x3D; n; i &gt;&#x3D; 1; --i)</span><br><span class="line">            q[i] &#x3D; max(q[i + 1], a[i]);</span><br><span class="line">        vector&lt;int&gt; ans;</span><br><span class="line">        for (int i &#x3D; 1; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (i &lt;&#x3D; l &amp;&amp; i + 1 &gt;&#x3D; r &amp;&amp; p[i] &#x3D;&#x3D; i &amp;&amp; q[i + 1] &#x3D;&#x3D; n - i)</span><br><span class="line">            &#123;</span><br><span class="line">                ans.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans.size() &lt;&lt; endl;</span><br><span class="line">        for (int i : ans)</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; n - i &lt;&lt; endl;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">            p[i] &#x3D; q[i] &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C题"><a href="#C题" class="headerlink" title="C题"></a>C题</h3><p><strong>题意：给你n和m，表示你有m个操作要让n涂满颜色而且每种颜色都要存在，每个m操作都给你一个ai表示涂色的范围，现在问要求你求出pi（pi表示从pi~pi+ai全部都涂成i颜色）。</strong></p><p><strong>这道题的话，根据题意我们先想出不能实现的情况。分为两种，第一种就是把所有的ai加在一起都小于n的话，就不能实现；第二种就是n−ai+1&lt;i的话那么也是不可以的，因为这样会把之前的ith覆盖。然后我们才可以求序列，可以先求出后缀和，然后求出max(i,n−sumi+1)因为sumi是后缀和，表示的是后面的是否可以让此时的i满足剩余的ai涂满色到结尾。</strong></p><p><strong>AC代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxx &#x3D; 100010;</span><br><span class="line">const int inf &#x3D; 0x3f3f3f3f;</span><br><span class="line">using namespace std;</span><br><span class="line">ll a[maxx], sum[maxx];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    cout.tie(0);</span><br><span class="line">    int n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; m; i++)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (n - a[i] + 1 &lt; i)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; &quot;-1&quot; &lt;&lt; endl;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    memset(sum, 0, sizeof(0));</span><br><span class="line">    for (int i &#x3D; m; i &gt;&#x3D; 1; i--)</span><br><span class="line">        sum[i] &#x3D; sum[i + 1] + a[i];</span><br><span class="line">    if (sum[1] &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;-1&quot; &lt;&lt; endl;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int ans &#x3D; max(1ll * i, n - sum[i] + 1);</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;A题&quot;&gt;&lt;a href=&quot;#A题&quot; class=&quot;headerlink&quot; title=&quot;A题&quot;&gt;&lt;/a&gt;A题&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;题意：给你一个a序列代表每次的排名，在n个比赛之后还有x场比赛，然后你去寻找一个最大的v代表这n+x比赛后比赛的连续的最大的排名是多少。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="CF" scheme="https://stephencurry6666.github.io/categories/CF/"/>
    
    
      <category term="CF" scheme="https://stephencurry6666.github.io/tags/CF/"/>
    
  </entry>
  
  <entry>
    <title>Distinct Sub-palindromes（HDU-6754）</title>
    <link href="https://stephencurry6666.github.io/2020/07/24/Distinct%20Sub-palindromes%EF%BC%88HDU-6754%EF%BC%89%EF%BC%882020HDU%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%B8%80%E5%9C%BA%EF%BC%89/"/>
    <id>https://stephencurry6666.github.io/2020/07/24/Distinct%20Sub-palindromes%EF%BC%88HDU-6754%EF%BC%89%EF%BC%882020HDU%E5%A4%9A%E6%A0%A1%E7%AC%AC%E4%B8%80%E5%9C%BA%EF%BC%89/</id>
    <published>2020-07-24T06:27:44.971Z</published>
    <updated>2020-07-24T06:33:43.274Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Problem Description</strong><br>S is a string of length n. S consists of lowercase English alphabets.</p><p>Your task is to count the number of different S with the minimum number of distinct sub-palindromes. Sub-palindrome is a palindromic substring.</p><a id="more"></a><p>Two sub-palindromes u and v are distinct if their lengths are different or for some i (0≤i≤length), ui≠vi. For example, string “aaaa” contains only 4 distinct sub-palindromes which are “a”, “aa”, “aaa” and “aaaa”.</p><p><strong>Input</strong><br>The first line contains an integer T (1≤T≤105), denoting the number of test cases.</p><p>The only line of each test case contains an integer n (1≤n≤109).</p><p><strong>Output</strong><br>For each test case, output a single line containing the number of different strings with minimum number of distinct sub-palindromes.</p><p>Since the answer can be huge, output it modulo 998244353.</p><p><strong>Sample Input</strong><br>2<br>1<br>2</p><p><strong>Sample Output</strong><br>26<br>676</p><p><strong>题意：</strong><br><strong>给你长度为n的字符串，要求子回文串尽可能的少。</strong></p><p><strong>思路：</strong><br><strong>这道题的话，给的题面感觉不好理解，读了好多遍题才读懂，看来阅读要下点功夫了。。。然后跟队友讨论发现就是能组成最少不同子回文串的最少不同字符串数量是n个26相乘。但是后来又发现当n&gt;=4的时候，最少的子回文串就是3个，因为我们只需要3个不同的字母无限填充即可，所以当n&gt;=4的时候就是26<em>25</em>24。</strong></p><p><strong>AC代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxx&#x3D;100010;</span><br><span class="line">const int inf&#x3D;0x3f3f3f3f;</span><br><span class="line">const int mod&#x3D;1000000009;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(0);</span><br><span class="line">    cout.tie(0);</span><br><span class="line">    int t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    while(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        int n;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        if(n&#x3D;&#x3D;1)</span><br><span class="line">        cout&lt;&lt;26&lt;&lt;endl;</span><br><span class="line">        else if(n&#x3D;&#x3D;2)</span><br><span class="line">        cout&lt;&lt;26*26&lt;&lt;endl;</span><br><span class="line">        else if(n&#x3D;&#x3D;3)</span><br><span class="line">        cout&lt;&lt;26*26*26&lt;&lt;endl;</span><br><span class="line">        else</span><br><span class="line">        cout&lt;&lt;26*25*24&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Problem Description&lt;/strong&gt;&lt;br&gt;S is a string of length n. S consists of lowercase English alphabets.&lt;/p&gt;
&lt;p&gt;Your task is to count the number of different S with the minimum number of distinct sub-palindromes. Sub-palindrome is a palindromic substring.&lt;/p&gt;
    
    </summary>
    
    
      <category term="2020HDU多校" scheme="https://stephencurry6666.github.io/categories/2020HDU%E5%A4%9A%E6%A0%A1/"/>
    
    
      <category term="字符串" scheme="https://stephencurry6666.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络实验项目二</title>
    <link href="https://stephencurry6666.github.io/2020/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C2/"/>
    <id>https://stephencurry6666.github.io/2020/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C2/</id>
    <published>2020-06-02T12:22:15.844Z</published>
    <updated>2020-06-02T12:35:24.111Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实验名称：实验项目2-主机系统网络参数配置与测试"><a href="#实验名称：实验项目2-主机系统网络参数配置与测试" class="headerlink" title="实验名称：实验项目2 主机系统网络参数配置与测试"></a>实验名称：实验项目2 主机系统网络参数配置与测试</h2><a id="more"></a><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p><strong>掌握IP地址的基本结构(网络部分与主机部分的区分) 掌握子网掩码的含义 掌握IP包的组成格式 理解IP数据包在网络中的转发方式。</strong></p><h2 id="实验步骤与调试过程-请用简单的文字描述"><a href="#实验步骤与调试过程-请用简单的文字描述" class="headerlink" title="实验步骤与调试过程(请用简单的文字描述)"></a>实验步骤与调试过程(请用简单的文字描述)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1）查看、配置主机和相关网络设备的参数，包括IP地址、物理地址、DNS服务器地址、网关地址等参数。</span><br><span class="line">（2）测试网络的连通性。</span><br><span class="line">（3）IP地址的基本结构及IP数据包在网络中的转发方式。</span><br></pre></td></tr></table></figure><h2 id="实验结果-上传实验结果截图或者简单文字描述"><a href="#实验结果-上传实验结果截图或者简单文字描述" class="headerlink" title="实验结果(上传实验结果截图或者简单文字描述)"></a>实验结果(上传实验结果截图或者简单文字描述)</h2><p><strong>（1）表 2-1 设备/接口参数表。</strong></p><p><img src="https://img-blog.csdnimg.cn/20200602202604195.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg0NjEzOQ==,size_16,color_FFFFFF,t_70" alt="tupian1"></p><p><img src="http://61.163.231.201:8000/Lab//ueditor/jsp/upload/image/20200602/1591069765208094518.png" alt="tupian2"></p><p><img src="http://61.163.231.201:8000/Lab//ueditor/jsp/upload/image/20200602/1591069781271040961.png" alt="tupian3"></p><p><strong>（2）按表 2-2 测试各主机或接口的连通性（从工具栏中选择“AddSimplePDU”工具， 然后依次点击“源主机”、“目的主机”，表示“源主机 ping 目的主机”（也可以打开 PC 机的命令行界 面，输入 “ping 目标 ip 地址”））。</strong></p><p>表 2-2 各主机或接口的连通性测试表</p><p><img src="https://img-blog.csdnimg.cn/2020060220281349.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg0NjEzOQ==,size_16,color_FFFFFF,t_70" alt="tupian4"></p><p><strong>（3）点击 切换到模拟器/simulation模式下，重新测试上一步（2）中表2-2中不能连通的项目。</strong></p><p><img src="http://61.163.231.201:8000/Lab//ueditor/jsp/upload/image/20200602/1591069911036014794.png" alt="tupian5"></p><p><img src="http://61.163.231.201:8000/Lab//ueditor/jsp/upload/image/20200602/1591069920708063120.png" alt="tupian6"></p><p>表2-3 步骤（2）中表2-2测试中不能连通的项目测试表</p><p><img src="https://img-blog.csdnimg.cn/20200602202959409.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg0NjEzOQ==,size_16,color_FFFFFF,t_70" alt="tupian7"></p><p><strong>（4）在步骤（1）的基础上为各 PC 配置默认网关，如表 2-4 所示。完成表 2-5 的测试内容。</strong></p><p><img src="https://img-blog.csdnimg.cn/20200602203115788.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg0NjEzOQ==,size_16,color_FFFFFF,t_70" alt="tupian8"></p><p>点击 切换到模拟器/simulation模式下，按表2-5、2-6要求进行测试，观察网络层和数据链路层<br>协议数据单元（PDU）在源主机PC0和路由器（如果需要通过路由器转发）上的封装情况，完成下表表2-5,2-6 的内容。 </p><p>表 2-5 数据在源主机PC0上的封装情况</p><p><img src="https://img-blog.csdnimg.cn/20200602203210715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg0NjEzOQ==,size_16,color_FFFFFF,t_70" alt="tupian9"></p><p>表 2-6 数据包在路由器上的封装情况</p><p><img src="https://img-blog.csdnimg.cn/20200602203302346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg0NjEzOQ==,size_16,color_FFFFFF,t_70" alt="tupian10"></p><p><strong>PS:</strong></p><p>问题：通过以上实验，请分析默认网关的作用是什么？</p><p>网关是一种充当转换重任的计算机系统或设备，在使用不同的通信协议，数据格式或语言,甚至体系结构完全不同的两种系统时，网关是一个翻译器。与网桥只是简单地传送信息不同，网关对收到的信息要重新打包，以适应目的系统的需求。同时，网关也可以提供过滤和安全功能。这就是为什么我们在有路由器上网的时候，必须要把计算机中的默认网关地址设置成路由器LAN接口的地址的原因，因为路由器的LAN接口就是你所在网络的网关，你的电脑要上网，数据包必须要经过网关转发出去。简单来说，网关是设备与路由器之间的桥梁，正确的网关配置才能保证用户可以正常上网。</p><p><strong>（5）在步骤（4）的基础上只改变 PC1 和 PC3 的子网掩码，如表 2-6 所示。完成表 2-7 连通性测试。</strong></p><p><img src="https://img-blog.csdnimg.cn/20200602203425655.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg0NjEzOQ==,size_16,color_FFFFFF,t_70" alt="tupian11"></p><h2 id="疑难小结-总结个人在实验中遇到的问题或者心得体会"><a href="#疑难小结-总结个人在实验中遇到的问题或者心得体会" class="headerlink" title="疑难小结(总结个人在实验中遇到的问题或者心得体会)"></a>疑难小结(总结个人在实验中遇到的问题或者心得体会)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.刚开始配置路由器IP地址的时候看成了配置交换器IP地址，然后查阅了一些资料把交换器IP地址给配送了，后来才发现不对。</span><br><span class="line">2.在切换到模拟器进行连通性测试的时候，连接错了主机接口，然后不知道怎么取消，又重新连接了一遍拓扑图。</span><br></pre></td></tr></table></figure><h2 id="实验详细操作步骤或程序清单"><a href="#实验详细操作步骤或程序清单" class="headerlink" title="实验详细操作步骤或程序清单"></a>实验详细操作步骤或程序清单</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.连接拓扑图。</span><br><span class="line"></span><br><span class="line">2.按表 2-2 测试各主机或接口的连通性（从工具栏中选择“AddSimplePDU”工具， 然后依次点击“源主机”、“目的主机”，表示“源主机 ping 目的主机”（也可以打开 PC 机的命令行界 面，输入 “ping 目标 ip 地址”））。</span><br><span class="line"></span><br><span class="line">3.点击 切换到模拟器&#x2F;simulation模式下，重新测试上一步（2）中表2-2中不能连通的项目。</span><br><span class="line"></span><br><span class="line">4.在步骤（1）的基础上为各 PC 配置默认网关，如表 2-4 所示。完成表 2-5 的测试内容。 </span><br><span class="line"></span><br><span class="line">5.在步骤（4）的基础上只改变 PC1 和 PC3 的子网掩码，如表 2-6 所示。完成表 2-7 连通性测试。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;实验名称：实验项目2-主机系统网络参数配置与测试&quot;&gt;&lt;a href=&quot;#实验名称：实验项目2-主机系统网络参数配置与测试&quot; class=&quot;headerlink&quot; title=&quot;实验名称：实验项目2 主机系统网络参数配置与测试&quot;&gt;&lt;/a&gt;实验名称：实验项目2 主机系统网络参数配置与测试&lt;/h2&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://stephencurry6666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络上机实验" scheme="https://stephencurry6666.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络实验项目一</title>
    <link href="https://stephencurry6666.github.io/2020/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80/"/>
    <id>https://stephencurry6666.github.io/2020/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E4%B8%80/</id>
    <published>2020-06-02T12:00:16.496Z</published>
    <updated>2020-06-02T12:18:55.537Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实验名称：实验项目1-交换式局域网的构建与交换机的工作原理"><a href="#实验名称：实验项目1-交换式局域网的构建与交换机的工作原理" class="headerlink" title="实验名称：实验项目1 交换式局域网的构建与交换机的工作原理"></a>实验名称：实验项目1 交换式局域网的构建与交换机的工作原理</h2><a id="more"></a><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p><strong>掌握在Packet Tracer软件中搭建实验平台，配置基本的网络参数，测试网络的连通性。 理解交换机的交换原理对不同类型数据帧的处理方式。</strong></p><h2 id="实验步骤与调试过程-请用简单的文字描述"><a href="#实验步骤与调试过程-请用简单的文字描述" class="headerlink" title="实验步骤与调试过程(请用简单的文字描述)"></a>实验步骤与调试过程(请用简单的文字描述)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1）利用Packet Tracer仿真软件搭建一个局域网，主要由交换机和若干台计算机组成。</span><br><span class="line">（2）配置基本的网络参数，测试网络的连通性。</span><br><span class="line">（3）查看交换机的MAC地址映射表并记录相关数据。</span><br></pre></td></tr></table></figure><h2 id="实验结果-上传实验结果截图或者简单文字描述"><a href="#实验结果-上传实验结果截图或者简单文字描述" class="headerlink" title="实验结果(上传实验结果截图或者简单文字描述)"></a>实验结果(上传实验结果截图或者简单文字描述)</h2><p><strong>1.先利用Packet Tracer仿真软件搭建一个局域网，主要由一个交换机和四台计算机组成。</strong></p><p><img src="http://61.163.231.201:8000/Lab//ueditor/jsp/upload/image/20200601/1591004844833082829.png" alt="tupian1"></p><p><strong>2.按照所给IP地址以及掩码表给每一台PC配上IP地址以及掩码。</strong></p><p><img src="http://61.163.231.201:8000/Lab//ueditor/jsp/upload/image/20200601/1591005082068066465.png" alt="tupian2"></p><p><strong>3.发送报文（PC0-&gt;PC1）。</strong></p><p><img src="http://61.163.231.201:8000/Lab//ueditor/jsp/upload/image/20200601/1591005158146044811.png" alt="tupian3"></p><p><strong>4.观察MAC表变化。</strong></p><p><img src="http://61.163.231.201:8000/Lab//ueditor/jsp/upload/image/20200601/1591005223005003171.png" alt="tupian4"></p><p><img src="http://61.163.231.201:8000/Lab//ueditor/jsp/upload/image/20200601/1591005240802072987.png" alt="tupian5"></p><p><img src="http://61.163.231.201:8000/Lab//ueditor/jsp/upload/image/20200601/1591005257771047365.png" alt="tupian6"></p><p><img src="http://61.163.231.201:8000/Lab//ueditor/jsp/upload/image/20200601/1591005266974083309.png" alt="tupian7"></p><p><strong>5.切换到模拟器/simulation模式下，然后打开PC机的命令行界面，输入 ping 目标ip地址（PC2-&gt;PC3）。</strong></p><p><img src="http://61.163.231.201:8000/Lab//ueditor/jsp/upload/image/20200601/1591005322630062107.png" alt="tupian8"></p><p><img src="http://61.163.231.201:8000/Lab//ueditor/jsp/upload/image/20200601/1591005342786085722.png" alt="tupian9"></p><p><strong>6.记录在表。</strong></p><p><img src="https://img-blog.csdnimg.cn/20200602201747501.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg0NjEzOQ==,size_16,color_FFFFFF,t_70" alt="tupian10"></p><p><strong>7.通过实验可以验证交换机的工作原理。</strong></p><p>交换机并不会把收到每个数据信息都以广播的方式发给客户端，是由于交换机可以根据MAC地址智能的转发数据帧。交换机存储的MAC地址表将MAC地址和交换机的接口编号对应在一起，每当交换机收到客户端发送来的数据帧时，它就会根据MAC地址表的信息判断该如何转发。</p><h2 id="疑难小结-总结个人在实验中遇到的问题或者心得体会"><a href="#疑难小结-总结个人在实验中遇到的问题或者心得体会" class="headerlink" title="疑难小结(总结个人在实验中遇到的问题或者心得体会)"></a>疑难小结(总结个人在实验中遇到的问题或者心得体会)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.刚开始下载好Packet Tracer仿真软件时，不知道怎么去使用它，看了老师发的使用说明才知道大概的使用方法。</span><br><span class="line">2.在建立拓扑结构图时，连好PC端和交换机之间的连线时，并不是两头都闪绿，靠近交换机那一头闪红，以为连接错了，结果发现原来需要一段时间去连接。</span><br><span class="line">3.由于刚刚接触这个软件来做计算机网路的实验，还有很多地方感觉到吃力。</span><br></pre></td></tr></table></figure><h2 id="实验详细操作步骤或程序清单"><a href="#实验详细操作步骤或程序清单" class="headerlink" title="实验详细操作步骤或程序清单"></a>实验详细操作步骤或程序清单</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.先利用Packet Tracer仿真软件搭建一个局域网，主要由一个交换机和四台计算机组成。</span><br><span class="line"></span><br><span class="line">2.按照所给IP地址以及掩码表给每一台PC配上IP地址以及掩码。</span><br><span class="line"></span><br><span class="line">3.发送报文（PC0-&gt;PC1）。</span><br><span class="line"></span><br><span class="line">4.观察MAC表变化。</span><br><span class="line"></span><br><span class="line">5.切换到模拟器&#x2F;simulation模式下，然后打开PC机的命令行界面，输入 ping 目标ip地址（PC2-&gt;PC3）。</span><br><span class="line"></span><br><span class="line">6.记录在表。</span><br><span class="line"></span><br><span class="line">7.通过实验可以验证交换机的工作原理。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;实验名称：实验项目1-交换式局域网的构建与交换机的工作原理&quot;&gt;&lt;a href=&quot;#实验名称：实验项目1-交换式局域网的构建与交换机的工作原理&quot; class=&quot;headerlink&quot; title=&quot;实验名称：实验项目1 交换式局域网的构建与交换机的工作原理&quot;&gt;&lt;/a&gt;实验名称：实验项目1 交换式局域网的构建与交换机的工作原理&lt;/h2&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://stephencurry6666.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络上机实验" scheme="https://stephencurry6666.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>数据库原理及应用上机实验三</title>
    <link href="https://stephencurry6666.github.io/2020/06/02/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C%E4%B8%89/"/>
    <id>https://stephencurry6666.github.io/2020/06/02/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C%E4%B8%89/</id>
    <published>2020-06-02T11:42:47.576Z</published>
    <updated>2020-06-02T11:54:51.397Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实验名称：实验三-数据高级查询"><a href="#实验名称：实验三-数据高级查询" class="headerlink" title="实验名称：实验三 数据高级查询"></a>实验名称：实验三 数据高级查询</h2><a id="more"></a><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p><strong>掌握复杂数据查询操作。</strong></p><h2 id="实验步骤与调试过程-请用简单的文字描述"><a href="#实验步骤与调试过程-请用简单的文字描述" class="headerlink" title="实验步骤与调试过程(请用简单的文字描述)"></a>实验步骤与调试过程(请用简单的文字描述)</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">对各表中的数据进行不同条件的连接查询和嵌套查询；</span><br><span class="line">（1）查询每个学生及其选课情况；</span><br><span class="line">（2）查询每门课的间接先修课</span><br><span class="line">（3）将STUDENT,SC进行右连接</span><br><span class="line">（4）查询既选修了2号课程又选修了3号课程的学生姓名、学号；</span><br><span class="line">（5）查询和刘晨同一年龄的学生</span><br><span class="line">（6）选修了课程名为“数据库”的学生姓名和年龄</span><br><span class="line">（7）查询其他系比IS系任一学生年龄小的学生名单</span><br><span class="line">（8）查询其他系中比IS系所有学生年龄都小的学生名单</span><br><span class="line">（9）查询选修了全部课程的学生姓名</span><br><span class="line">（10）查询计算机系学生及其性别是男的学生</span><br><span class="line">（11）查询选修课程1的学生集合和选修2号课程学生集合的差集</span><br><span class="line">（12）查询李丽同学不学的课程的课程号</span><br><span class="line">（13）查询选修了3号课程的学生平均年龄</span><br><span class="line">（14）求每门课程学生的平均成绩</span><br><span class="line">（15）统计每门课程的学生选修人数（超过3人的才统计）。要求输出课程号和选修人数，结果按人数降序排列，若人数相同，按课程号升序排列</span><br><span class="line">（16）查询学号比刘晨大，而年龄比他小的学生姓名。</span><br><span class="line">（17）求年龄大于所有女同学年龄的男同学姓名和年龄</span><br></pre></td></tr></table></figure><h2 id="实验结果-上传实验结果截图或者简单文字描述"><a href="#实验结果-上传实验结果截图或者简单文字描述" class="headerlink" title="实验结果(上传实验结果截图或者简单文字描述)"></a>实验结果(上传实验结果截图或者简单文字描述)</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.经过实验可以知道求总数时可以用count（）函数。</span><br><span class="line">2.在进行分组操作时，用group by 时要用having来限制条件。</span><br><span class="line">3.order by是排序要求 desc是降序 ，asc是升序。</span><br><span class="line">4.any（）函数是任意的意思，all（）是所有。</span><br></pre></td></tr></table></figure><h2 id="疑难小结-总结个人在实验中遇到的问题或者心得体会"><a href="#疑难小结-总结个人在实验中遇到的问题或者心得体会" class="headerlink" title="疑难小结(总结个人在实验中遇到的问题或者心得体会)"></a>疑难小结(总结个人在实验中遇到的问题或者心得体会)</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.在进行求总数操作时，由于一开始我不知道有count函数，很是迷茫，后来查阅了资料之后，才得知。</span><br><span class="line">2.在进行将STUDENT,SC进行右连接的操作时，由于少打了一个关键字，总是报错，后来检查了几遍之后才找到问题。</span><br><span class="line">3.我对SQL语言还有很多地方不是很熟练，需要勤加练习。</span><br></pre></td></tr></table></figure><h2 id="实验详细操作步骤或程序清单"><a href="#实验详细操作步骤或程序清单" class="headerlink" title="实验详细操作步骤或程序清单"></a>实验详细操作步骤或程序清单</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">（1） 查询每个学生及其选课情况</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> student.sno,sname,ssex,sage,sdept,cno,grade</span><br><span class="line"><span class="keyword">from</span> student,sc</span><br><span class="line"><span class="keyword">where</span> student.sno=sc.sno</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>） 查询每门课的间接先修课</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> first.cno,second.cpno</span><br><span class="line"><span class="keyword">from</span> course <span class="keyword">first</span>,course <span class="keyword">second</span></span><br><span class="line"><span class="keyword">where</span> first.cpno=second.cno</span><br><span class="line"></span><br><span class="line">（<span class="number">3</span>） 将STUDENT,SC进行右连接</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> student.sno,sname,ssex,sage,sdept,cno,grade</span><br><span class="line"><span class="keyword">from</span> student <span class="keyword">right</span> <span class="keyword">outer</span> <span class="keyword">join</span> sc <span class="keyword">on</span> student.sno=sc.sno</span><br><span class="line">（<span class="number">4</span>） 查询既选修了<span class="number">2</span>号课程又选修了<span class="number">3</span>号课程的学生姓名、学号</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> student.sno,sname</span><br><span class="line"><span class="keyword">from</span> student <span class="keyword">inner</span> <span class="keyword">join</span> sc <span class="keyword">on</span> student.sno=sc.sno</span><br><span class="line"><span class="keyword">where</span> cno=<span class="string">'3'</span> <span class="keyword">and</span> sc.sno <span class="keyword">in</span></span><br><span class="line">(<span class="keyword">select</span> sno</span><br><span class="line"><span class="keyword">from</span> sc</span><br><span class="line"><span class="keyword">where</span> cno=<span class="string">'2'</span>)</span><br><span class="line"></span><br><span class="line">（<span class="number">5</span>）查询和刘晨同一年龄的学生</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> student.sno,sname</span><br><span class="line"><span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">where</span> sname!=<span class="string">'刘晨'</span> <span class="keyword">and</span> sage=</span><br><span class="line">(<span class="keyword">select</span> sage </span><br><span class="line"><span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">where</span> sname=<span class="string">'刘晨'</span>)</span><br><span class="line"></span><br><span class="line">（<span class="number">6</span>）选修了课程名为“数据库”的学生姓名和年龄</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> sname,sage</span><br><span class="line"><span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">where</span> sno <span class="keyword">in</span></span><br><span class="line">(<span class="keyword">select</span> sno</span><br><span class="line"><span class="keyword">from</span> sc</span><br><span class="line"><span class="keyword">where</span> cno <span class="keyword">in</span></span><br><span class="line">(<span class="keyword">select</span> cno</span><br><span class="line"><span class="keyword">from</span> course </span><br><span class="line"><span class="keyword">where</span> cname=<span class="string">'数据库'</span>))</span><br><span class="line"></span><br><span class="line">（<span class="number">7</span>）查询其他系比<span class="keyword">IS</span>系任一学生年龄小的学生名单</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> student.sno,sname</span><br><span class="line"><span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">where</span> sdept&lt;&gt;<span class="string">'IS'</span> <span class="keyword">and</span></span><br><span class="line">sage&lt;<span class="keyword">any</span></span><br><span class="line">(<span class="keyword">select</span> sage </span><br><span class="line"><span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">where</span> sdept=<span class="string">'IS'</span>)</span><br><span class="line"></span><br><span class="line">（<span class="number">8</span>）查询其他系中比<span class="keyword">IS</span>系所有学生年龄都小的学生名单</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> student.sno,sname</span><br><span class="line"><span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">where</span> sdept&lt;&gt;<span class="string">'IS'</span> <span class="keyword">and</span> </span><br><span class="line">sage&lt;<span class="keyword">all</span></span><br><span class="line">(<span class="keyword">select</span> sage </span><br><span class="line"><span class="keyword">from</span> student </span><br><span class="line"><span class="keyword">where</span> sdept=<span class="string">'IS'</span>)</span><br><span class="line"></span><br><span class="line">（<span class="number">9</span>）查询选修了全部课程的学生姓名</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> sname</span><br><span class="line"><span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">where</span> Sno <span class="keyword">in</span></span><br><span class="line">(<span class="keyword">select</span> Sno <span class="keyword">from</span> SC</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> Sno</span><br><span class="line"><span class="keyword">having</span> <span class="keyword">count</span>(*) = (<span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> course ))</span><br><span class="line"></span><br><span class="line">（<span class="number">10</span>）查询计算机系学生及其性别是男的学生</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> student.sno,sname</span><br><span class="line"><span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">where</span> sdept=<span class="string">'IS'</span> <span class="keyword">and</span> ssex=<span class="string">'男'</span></span><br><span class="line"></span><br><span class="line">（<span class="number">11</span>）查询选修课程<span class="number">1</span>的学生集合和选修<span class="number">2</span>号课程学生集合的差集</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> sno</span><br><span class="line"><span class="keyword">from</span> sc </span><br><span class="line"><span class="keyword">where</span> cno=<span class="string">'1'</span> <span class="keyword">except</span> </span><br><span class="line"><span class="keyword">select</span> sno</span><br><span class="line"><span class="keyword">from</span> sc</span><br><span class="line"><span class="keyword">where</span> cno=<span class="string">'2'</span></span><br><span class="line"></span><br><span class="line">（<span class="number">12</span>）查询李丽同学不学的课程的课程号</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> cno</span><br><span class="line"><span class="keyword">from</span> course</span><br><span class="line"><span class="keyword">where</span> cno <span class="keyword">not</span> <span class="keyword">in</span></span><br><span class="line">(<span class="keyword">select</span> cno</span><br><span class="line"><span class="keyword">from</span> sc</span><br><span class="line"><span class="keyword">where</span> sno <span class="keyword">in</span></span><br><span class="line">(<span class="keyword">select</span> sno</span><br><span class="line"><span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">where</span> sname=<span class="string">'李丽'</span>))</span><br><span class="line"></span><br><span class="line">（<span class="number">13</span>）查询选修了<span class="number">3</span>号课程的学生平均年龄</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">AVG</span>(sage) <span class="keyword">as</span> avgsage</span><br><span class="line"><span class="keyword">from</span> student <span class="keyword">inner</span> <span class="keyword">join</span> sc <span class="keyword">on</span> student.sno=sc.sno</span><br><span class="line"><span class="keyword">where</span> cno=<span class="string">'3'</span></span><br><span class="line"></span><br><span class="line">（<span class="number">14</span>）求每门课程学生的平均成绩</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> cno,<span class="keyword">AVG</span>(grade) <span class="keyword">as</span> avggrade</span><br><span class="line"><span class="keyword">from</span> sc</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> cno</span><br><span class="line"></span><br><span class="line">（<span class="number">15</span>）统计每门课程的学生选修人数（超过<span class="number">3</span>人的才统计）。要求输出课程号和选修人数，结果按人数降序排列，若人数相同，按课程号升序排列</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> course.cno <span class="string">'课程号'</span>, <span class="keyword">count</span>(sc.sno) <span class="string">'人数'</span></span><br><span class="line"><span class="keyword">from</span> course,sc </span><br><span class="line"><span class="keyword">where</span> course.cno=sc.cno </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> course.cno <span class="keyword">having</span> <span class="keyword">count</span>(sc.sno)&gt;<span class="number">3</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">COUNT</span>(sc.sno) <span class="keyword">desc</span>,course.cno <span class="keyword">asc</span></span><br><span class="line"></span><br><span class="line">（<span class="number">16</span>）查询学号比刘晨大，而年龄比他小的学生姓名</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> sname</span><br><span class="line"><span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">where</span> sno&gt;</span><br><span class="line">(<span class="keyword">select</span> sno <span class="keyword">from</span> student <span class="keyword">where</span> sname=<span class="string">'刘晨'</span>)<span class="keyword">and</span></span><br><span class="line">sage&lt;(<span class="keyword">select</span> sage <span class="keyword">from</span> student <span class="keyword">where</span> sname=<span class="string">'刘晨'</span>)</span><br><span class="line"></span><br><span class="line">（<span class="number">17</span>）求年龄大于所有女同学年龄的男同学姓名和年龄</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> sname,sage</span><br><span class="line"><span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">where</span> ssex=<span class="string">'男'</span><span class="keyword">and</span> sage&gt;</span><br><span class="line">(<span class="keyword">select</span> <span class="keyword">MAX</span>(sage) <span class="keyword">from</span> student <span class="keyword">where</span> ssex=<span class="string">'女'</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;实验名称：实验三-数据高级查询&quot;&gt;&lt;a href=&quot;#实验名称：实验三-数据高级查询&quot; class=&quot;headerlink&quot; title=&quot;实验名称：实验三 数据高级查询&quot;&gt;&lt;/a&gt;实验名称：实验三 数据高级查询&lt;/h2&gt;
    
    </summary>
    
    
      <category term="SQL" scheme="https://stephencurry6666.github.io/categories/SQL/"/>
    
    
      <category term="SQL上机实验" scheme="https://stephencurry6666.github.io/tags/SQL%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>数据库原理及应用上机实验四</title>
    <link href="https://stephencurry6666.github.io/2020/06/02/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C%E5%9B%9B/"/>
    <id>https://stephencurry6666.github.io/2020/06/02/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C%E5%9B%9B/</id>
    <published>2020-06-02T11:42:47.576Z</published>
    <updated>2020-06-02T11:54:15.447Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实验名称：实验四-数据更新和视图"><a href="#实验名称：实验四-数据更新和视图" class="headerlink" title="实验名称：实验四 数据更新和视图"></a>实验名称：实验四 数据更新和视图</h2><a id="more"></a><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>1.熟练掌握SQL的常用数据更新操作。</p><p>2.熟练应用INSERT,UPDATE,DELETE语句。</p><p>3.掌握更新操作的各种格式。</p><p>4.掌握视图的创建、更新、删除和查询</p><h2 id="实验步骤与调试过程-请用简单的文字描述"><a href="#实验步骤与调试过程-请用简单的文字描述" class="headerlink" title="实验步骤与调试过程(请用简单的文字描述)"></a>实验步骤与调试过程(请用简单的文字描述)</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">（1）插入如下学生记录（学号：95030，姓名：李莉，年龄：18）；</span><br><span class="line">（2）插入如下选课记录（95030，1）；</span><br><span class="line">（3）计算机系学生年龄改成20；</span><br><span class="line">（4）数学系所有学生成绩改成0；</span><br><span class="line">（5）把低于总平均成绩的女同学成绩提高5分；</span><br><span class="line">（6）修改2号课程的成绩，若成绩小于75分提高5％，成绩大于75时提高4％（两个语句实现，注意顺序）；</span><br><span class="line">（7）删除95030学生信息；</span><br><span class="line">（8）删除SC表中无成绩的记录；</span><br><span class="line">（9）删除张娜的选课记录；</span><br><span class="line">（10）删除数学系所有学生选课记录；</span><br><span class="line">（11）删除不及格的学生选课记录；</span><br><span class="line">（12）查询每一门课程成绩都大于等于80分的学生学号、姓名和性别，把值送往另一个已经存在的基本表STU(SNO,SNAME,SSEX)中；</span><br><span class="line">（13）把所有学生学号和课程号连接追加到新表中；</span><br><span class="line">（14）所有学生年龄增1；</span><br><span class="line">（15）统计3门以上课程不及格的学生把相应的学生姓名、系别追加到另外一个表中。</span><br><span class="line">（16）将学生学号、总成绩、平均成绩定义成一个视图，以便于查询。</span><br><span class="line">（17）将Student表中所有女生记录定义为一个视图F_STU，并限制对视图的更新操作不能超过视图条件限制。</span><br><span class="line">（18）将上一题建立的F_STU视图，更改为给所有男生记录定义的视图，属性包括学号、性别、年龄、所选课程号。</span><br><span class="line">（19）在上一题的视图中找出选修了3号课程的学生。</span><br><span class="line">（20）删除视图F_STU。</span><br></pre></td></tr></table></figure><h2 id="实验结果-上传实验结果截图或者简单文字描述"><a href="#实验结果-上传实验结果截图或者简单文字描述" class="headerlink" title="实验结果(上传实验结果截图或者简单文字描述)"></a>实验结果(上传实验结果截图或者简单文字描述)</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 删除主键表数据如果有外键约束就会报错。</span><br><span class="line"></span><br><span class="line">2. 插入数据用<span class="keyword">insert</span> <span class="keyword">into</span> 表直接+表。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 更新用<span class="keyword">update</span>。</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 删除直接用<span class="keyword">delete</span> 可以直接删除一行数据。</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>操作视图的时候要用到<span class="keyword">create</span> <span class="keyword">view</span>。</span><br></pre></td></tr></table></figure><h2 id="疑难小结-总结个人在实验中遇到的问题或者心得体会"><a href="#疑难小结-总结个人在实验中遇到的问题或者心得体会" class="headerlink" title="疑难小结(总结个人在实验中遇到的问题或者心得体会)"></a>疑难小结(总结个人在实验中遇到的问题或者心得体会)</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.修改数据时，如果省略where自子句，则表示要修改表中的所有元组，一开始不知道这个地方，错了好几次。</span><br><span class="line">2.带子查询的修改语句，因为有<span class="keyword">update</span>有<span class="keyword">where</span>语句，而<span class="keyword">where</span>子句后面可以跟子查询，所以子查询也可以嵌套在<span class="keyword">update</span>语句中，用以构造执行修改操作的条件。</span><br><span class="line"><span class="number">3.</span>进行视图操作的时候，一开始不是很熟悉过程，然后看了老师发的课件。课件里面有讲解，然后才做的实验。</span><br></pre></td></tr></table></figure><h2 id="实验详细操作过程或程序清单"><a href="#实验详细操作过程或程序清单" class="headerlink" title="实验详细操作过程或程序清单"></a>实验详细操作过程或程序清单</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line">（1）插入如下学生记录（学号：95030，姓名：李莉，年龄：18）</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student(sno,sname,sage)</span><br><span class="line"><span class="keyword">values</span> (<span class="string">'95030'</span>,<span class="string">'李莉'</span>,<span class="number">18</span>)</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）插入如下选课记录（<span class="number">95030</span>，<span class="number">1</span>）</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> sc(sno,cno)</span><br><span class="line"><span class="keyword">values</span>(<span class="string">'95030'</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">（<span class="number">3</span>）计算机系学生年龄改成<span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> student</span><br><span class="line"><span class="keyword">set</span> sage=<span class="number">20</span></span><br><span class="line"><span class="keyword">where</span> sdept=<span class="string">'CS'</span></span><br><span class="line"></span><br><span class="line">（<span class="number">4</span>）把数学系所有学生成绩改成<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> sc</span><br><span class="line"><span class="keyword">set</span> grade=<span class="number">0</span></span><br><span class="line"><span class="keyword">where</span> <span class="string">'MA'</span>=</span><br><span class="line">(<span class="keyword">select</span> sdept</span><br><span class="line"><span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">where</span> student.sno=sc.sno)</span><br><span class="line"></span><br><span class="line">（<span class="number">5</span>）把低于总平均成绩的女同学成绩提高<span class="number">5</span>分</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> sc</span><br><span class="line"><span class="keyword">set</span> grade+=<span class="number">5</span></span><br><span class="line"><span class="keyword">where</span> grade&lt;</span><br><span class="line">(<span class="keyword">select</span> <span class="keyword">avg</span>(grade)</span><br><span class="line"><span class="keyword">from</span> sc <span class="keyword">inner</span> <span class="keyword">join</span> student</span><br><span class="line"><span class="keyword">on</span> student.sno=sc.sno</span><br><span class="line"><span class="keyword">where</span> ssex=<span class="string">'女'</span>)</span><br><span class="line"></span><br><span class="line">（<span class="number">6</span>）修改<span class="number">2</span>号课程的成绩，若成绩小于<span class="number">75</span>分提高<span class="number">5</span>％，成绩大于<span class="number">75</span>时提高<span class="number">4</span>％（两个语句实现，注意顺序）</span><br><span class="line"><span class="keyword">update</span> sc</span><br><span class="line"><span class="keyword">set</span> grade=grade*(<span class="number">1</span>+<span class="number">0.05</span>)</span><br><span class="line"><span class="keyword">where</span> cno=<span class="string">'002'</span> <span class="keyword">and</span> grade&lt;<span class="number">75</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> sc</span><br><span class="line"><span class="keyword">set</span> grade=grade*(<span class="number">1</span>+<span class="number">0.04</span>)</span><br><span class="line"><span class="keyword">where</span> cno=<span class="string">'002'</span> <span class="keyword">and</span> grade&gt;<span class="number">75</span>;</span><br><span class="line"></span><br><span class="line">（7）删除95030学生信息</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span></span><br><span class="line"><span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">where</span> sno=<span class="string">'95030'</span></span><br><span class="line"></span><br><span class="line">（<span class="number">8</span>）删除SC表中无成绩的记录</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span></span><br><span class="line"><span class="keyword">from</span> sc</span><br><span class="line"><span class="keyword">where</span> grade <span class="keyword">is</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">（9）删除张娜的选课记录</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span></span><br><span class="line"><span class="keyword">from</span> sc</span><br><span class="line"><span class="keyword">where</span> sno=(<span class="keyword">select</span> sno <span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">where</span> sname=<span class="string">'张娜'</span>)</span><br><span class="line"></span><br><span class="line">（<span class="number">10</span>）删除数学系所有学生选课记录</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span></span><br><span class="line"><span class="keyword">from</span> sc</span><br><span class="line"><span class="keyword">where</span> sno <span class="keyword">in</span> (<span class="keyword">select</span> sno <span class="keyword">from</span> student <span class="keyword">where</span> sdept=<span class="string">'MA'</span>)</span><br><span class="line"></span><br><span class="line">（<span class="number">11</span>）删除不及格的学生选课记录</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span></span><br><span class="line"><span class="keyword">from</span> sc</span><br><span class="line"><span class="keyword">where</span> grade&lt;<span class="number">60</span></span><br><span class="line"></span><br><span class="line">（<span class="number">12</span>）查询每一门课程成绩都大于等于<span class="number">80</span>分的学生学号、姓名和性别，把值送往另一个已经存在的基本表STU(SNO,SNAME,SSEX)中</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> STU</span><br><span class="line">(sno <span class="built_in">char</span>(<span class="number">8</span>),</span><br><span class="line">sname <span class="built_in">char</span>(<span class="number">8</span>),</span><br><span class="line">ssex <span class="built_in">char</span>(<span class="number">2</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> STU(sno,sname,ssex)</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> student.sno,sname,ssex</span><br><span class="line"><span class="keyword">from</span> student,sc</span><br><span class="line"><span class="keyword">where</span> student.sno <span class="keyword">not</span> <span class="keyword">in</span></span><br><span class="line">(<span class="keyword">select</span> sno <span class="keyword">from</span> sc <span class="keyword">where</span> grade&lt;<span class="number">80</span>) <span class="keyword">and</span> student.sno=sc.sno</span><br><span class="line"></span><br><span class="line">（<span class="number">13</span>）把所有学生学号和课程号连接追加到新表中</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> stu1</span><br><span class="line">(</span><br><span class="line">sno <span class="built_in">char</span>(<span class="number">8</span>),</span><br><span class="line">cno <span class="built_in">char</span>(<span class="number">3</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu1(sno,cno)</span><br><span class="line"><span class="keyword">select</span> sno,cno</span><br><span class="line"><span class="keyword">from</span> sc;</span><br><span class="line"></span><br><span class="line">（14）所有学生年龄增1</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> student</span><br><span class="line"><span class="keyword">set</span> sage=sage+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">（15）统计3门以上课程不及格的学生把相应的学生姓名、系别追加到另外一个表中</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> stu2</span><br><span class="line">(</span><br><span class="line">sname <span class="built_in">char</span>(<span class="number">8</span>),</span><br><span class="line">sdept <span class="built_in">char</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu2(sname,sdept)</span><br><span class="line"><span class="keyword">select</span> sname,sdept</span><br><span class="line"><span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">where</span> sno <span class="keyword">in</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> sno</span><br><span class="line"><span class="keyword">from</span> sc</span><br><span class="line"><span class="keyword">where</span> grade&lt;<span class="number">60</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> sno</span><br><span class="line"><span class="keyword">having</span> <span class="keyword">count</span>(grade)&gt;=<span class="number">3</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">（16）将学生学号、总成绩、平均成绩定义成一个视图，以便于查询。</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> grade_sum_avg</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"> <span class="keyword">select</span> sno,<span class="keyword">sum</span>(grade) <span class="keyword">as</span> totalgrade,<span class="keyword">avg</span>(grade) <span class="keyword">as</span> avg_grade</span><br><span class="line"> <span class="keyword">from</span>  sc</span><br><span class="line"> <span class="keyword">group</span> <span class="keyword">by</span> sno;</span><br><span class="line"></span><br><span class="line">（17）将Student表中所有女生记录定义为一个视图F_STU，并限制对视图的更新操作不能超过视图条件限制。</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> F_STU(sno,<span class="keyword">name</span>,dept,sex,age)</span><br><span class="line">    <span class="keyword">as</span></span><br><span class="line">        <span class="keyword">select</span> *</span><br><span class="line">        <span class="keyword">from</span> student</span><br><span class="line">        <span class="keyword">where</span> ssex=<span class="string">'女'</span>;</span><br><span class="line">        <span class="keyword">with</span> <span class="keyword">check</span> <span class="keyword">option</span>;</span><br><span class="line"></span><br><span class="line">（18）将上一题建立的F_STU视图，更改为给所有男生记录定义的视图，属性包括学号、性别、年龄、所选课程号。</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">view</span> F_STU(sno,ssex,sage,cno)</span><br><span class="line">   <span class="keyword">as</span></span><br><span class="line">     <span class="keyword">select</span> student.sno,ssex,sage,cno <span class="keyword">from</span> student,sc</span><br><span class="line">     <span class="keyword">where</span> student.sno=sc.sno <span class="keyword">and</span> ssex=<span class="string">'男'</span></span><br><span class="line"></span><br><span class="line">（<span class="number">19</span>）在上一题的视图中找出选修了<span class="number">3</span>号课程的学生。</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span>    F_STU.sno,sname,cno</span><br><span class="line"><span class="keyword">from</span>      F_STU,sc</span><br><span class="line"><span class="keyword">where</span>     F_STU.sno=sc.sno <span class="keyword">and</span></span><br><span class="line">          sc.cno=<span class="string">'3'</span>;</span><br><span class="line"></span><br><span class="line">（20）删除视图F_STU</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> F_STU;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;实验名称：实验四-数据更新和视图&quot;&gt;&lt;a href=&quot;#实验名称：实验四-数据更新和视图&quot; class=&quot;headerlink&quot; title=&quot;实验名称：实验四 数据更新和视图&quot;&gt;&lt;/a&gt;实验名称：实验四 数据更新和视图&lt;/h2&gt;
    
    </summary>
    
    
      <category term="SQL" scheme="https://stephencurry6666.github.io/categories/SQL/"/>
    
    
      <category term="SQL上机实验" scheme="https://stephencurry6666.github.io/tags/SQL%E4%B8%8A%E6%9C%BA%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
</feed>
